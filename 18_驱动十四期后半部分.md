# 1.DS18B20驱动写时序

在上一章节中，我们编写了DS18B20的复位时序相关的驱动代码，并在最后使用了逻辑分析仪验证了相应的时序，而在本章节中将继续完善DS18B20的驱动程序，添加写时序相关的代码，并在最后使用逻辑分析仪进行时序的验证。

## 1.1 写时序分析

DS18B20数据手册中关于写入的时序图如下所示：

![image-20240226143833222](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261438261.png)

关于DS18B20有写入0和写入1两种时序，他们的时序是不同的，接下来首先对前半部分写入0进行分析。

步骤1：主机拉低总线，从高电平变成低电平，且有时间限制，要确保拉低的时间最少为60微秒，最多为120微秒

步骤2：从机采样读取，主机拉低总线的15us-60us从机开始采样，如果读取到的是0，从机就会接收0，从而成功写入0。

步骤3：拉高总线，恢复总线的高电平状态，且两个写操作的间隔必须大于1微秒。

总结出的写0操作代码如下所示：
~~~c
void ds18b20_writebit_0() {
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出
    
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);    // 将 GPIO 输出设置为指定的位(bit)
    udelay(65);// 延时 65 微秒
        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出    
    udelay(2);// 延时 2 微秒
}
~~~

然后来对写1的步骤进行分析：

步骤1：主机拉低总线，从高电平变成低电平，且有时间限制，要确保拉低的时间最少为1微秒，并且不能超过15微秒

步骤2：拉高总线，恢复总线的高电平状态，

步骤3：从机采样读取，拉高总线之后就会进行采样，如果读取到的是1，从机就会接收1，从而成功写入1.

总结出的写1操作代码如下所示：

~~~c
void ds18b20_writebit_1() {
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出
    
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);    // 将 GPIO 输出设置为指定的位(bit)
    udelay(10);// 延时 65 微秒
        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出    
    udelay(2);// 延时 2 微秒
}
~~~

综合上面写1和写0操作的代码，可以将两个代码进行整合在一起，整合之后的代码如下所示：
~~~c
/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出      
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 拉低

    if (bit){
        udelay(10);//延时 10 微秒
        gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出
    }
    
    udelay(65);// 延时 65 微秒    
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出    
    udelay(2);// 延时 2 微秒
}
~~~

但这样修改之后的代码仅仅只能发送一个字符，如果要连续写入8位字符就需要连续使用8次该函数，而为了更方便，可以重新添加一个函数，从而直接写入一个字节的数据，具体内容如下所示：
~~~c
/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出      
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 拉低

    if (bit){
        udelay(10);//延时 10 微秒
        gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出
    }
    
    udelay(65);// 延时 65 微秒    
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出    
    udelay(2);// 延时 2 微秒
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;
    
    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}
~~~

至此，关于DS18B20的写操作相关函数就编写完成了，会在下个小节编写填加写时序相关函数的驱动。

## 1.2 DS18b20驱动写时序编写

本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\96_ds18b20_03\02_module。

​	相较于上一章节的驱动程序，本小节编写的驱动程序只是将写操作的步骤进行了完善，并在入口函数中调用了ds18b20的复位和写函数进行测试。

​	编写完成的ds18b20.c代码如下所示:

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h> // 添加此头文件
#include <linux/delay.h>

struct ds18b20_data
{
    dev_t dev_num;
    struct cdev ds18b20_cdev;
    struct class *ds18b20_class;
    struct device *ds18b20_device;
    struct gpio_desc *ds18b20_gpio;
};

struct ds18b20_data *ds18b20;

void ds18b20_reset(void)
{
    // 设置 GPIO 方向为输出，输出低电平
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    udelay(700); // 延迟 700 微秒

    // 设置 GPIO 输出高电平，并将 GPIO 方向设置为输入
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    gpiod_direction_input(ds18b20->ds18b20_gpio);

    // 等待直到 GPIO 输入为低电平
    while (gpiod_get_value(ds18b20->ds18b20_gpio))
        ;

    // 等待直到 GPIO 输入为高电平
    while (!gpiod_get_value(ds18b20->ds18b20_gpio))
        ;
    udelay(480); // 延迟 480 微秒
}

/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);

    // 若 bit 为 1，则延时 10 微秒
    if (bit)
    {
        udelay(10);
        // 将 GPIO 方向设置为输出
    	gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    }
        



    // 延时 65 微秒
    udelay(65);

    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;

    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}

int ds18b20_open(struct inode *inode, struct file *file)
{
    return 0;
}

ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs)
{
    return 0;
}

int ds18b20_release(struct inode *inode, struct file *file)
{
    return 0;
}

struct file_operations ds18b20_fops = {
    .open = ds18b20_open,
    .read = ds18b20_read,
    .release = ds18b20_release,
    .owner = THIS_MODULE,
};

int ds18b20_probe(struct platform_device *dev)
{
    int ret;
    printk("This is probe \n");

    // 分配内存给ds18b20_data结构体
    ds18b20 = kzalloc(sizeof(*ds18b20), GFP_KERNEL);
    if (ds18b20 == NULL)
    {
        printk("kzalloc error\n");
        ret = -ENOMEM;
        goto error_0;
    }

    // 分配字符设备号
    ret = alloc_chrdev_region(&ds18b20->dev_num, 0, 1, "myds18b20");
    if (ret < 0)
    {
        printk("alloc_chrdev_region error\n");
        ret = -EAGAIN;
        goto error_1;
    }

    // 初始化字符设备
    cdev_init(&ds18b20->ds18b20_cdev, &ds18b20_fops);
    ds18b20->ds18b20_cdev.owner = THIS_MODULE;
    cdev_add(&ds18b20->ds18b20_cdev, ds18b20->dev_num, 1);

    // 创建设备类
    ds18b20->ds18b20_class = class_create(THIS_MODULE, "sensors");
    if (IS_ERR(ds18b20->ds18b20_class))
    {
        printk("class_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_class);
        goto error_2;
    }

    // 创建设备
    ds18b20->ds18b20_device = device_create(ds18b20->ds18b20_class, NULL, ds18b20->dev_num, NULL, "ds18b20");
    if (IS_ERR(ds18b20->ds18b20_device))
    {
        printk("device_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_device);
        goto error_3;
    }

    // 获取GPIO描述符
    ds18b20->ds18b20_gpio = gpiod_get_optional(&dev->dev, "ds18b20", 0);
    if (ds18b20->ds18b20_gpio == NULL)
    {
        ret = -EBUSY;
        goto error_4;
    }

    // 设置GPIO方向为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    return 0;

    error_4:
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);

    error_3:
    class_destroy(ds18b20->ds18b20_class);

    error_2:
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);

    error_1:
    kfree(ds18b20);

    error_0:
    return ret;
}

const struct of_device_id ds18b20_match_table[] = {
    {.compatible = "ds18b20"},
    {},
};

struct platform_driver ds18b20_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = "ds18b20",
        .of_match_table = ds18b20_match_table,
    },
    .probe = ds18b20_probe,
};

static int __init ds18b20_init(void)
{
    int ret;

    // 注册平台驱动
    ret = platform_driver_register(&ds18b20_driver);
    if (ret < 0)
    {
        printk("platform_driver_register error\n");
        return -1;
    }

    ds18b20_reset(); // 调用复位函数
    ds18b20_writebyte(0xcc);//写入0Xcc字符
    return 0;
}

static void __exit ds18b20_exit(void)
{
    // 释放资源
    gpiod_put(ds18b20->ds18b20_gpio);
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);
    class_destroy(ds18b20->ds18b20_class);
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);
    kfree(ds18b20);
    platform_driver_unregister(&ds18b20_driver);
}

module_init(ds18b20_init);
module_exit(ds18b20_exit);
MODULE_LICENSE("GPL");
~~~

## 1.3 运行测试

### 1.3.1 编译驱动程序

在上一小节中的ds18b20.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += ds18b20.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ds18b20.c和Makefile文件目录下，如下图所示：

![image-20240226161402753](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261614817.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240226161415582](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261614645.png)

编译完生成ds18b20.ko目标文件，如下图所示：

![image-20240226161626832](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261616875.png)

至此驱动模块就编译成功了。

### 1.3.2 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261440694.png)

然后将上一小节编译完成的ds18b20.ko驱动文件拷贝到开发板上，拷贝完成如下所示：
![image-20240226162824020](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261628078.png)

然后根据前面章节内容连接好逻辑分析仪，并设置好相应的软件，然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod ds18b20.ko
~~~

![image-20240226164206711](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261642741.png)

然后来查看逻辑分析仪采集到的波形，第一段波形为复位信号，具体如下所示：
![image-20240226164325622](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261643676.png)

接下来看第二段波形，该波形表示发送的0xcc，具体内容如下所示：
![image-20240226164442426](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261644475.png)		可以根据第一小节的时序图进行对比，发现上图通过逻辑分析仪采集到的波形图是正确的。

# 2.DS18B20驱动读时序

在上个章节中完善了DS18B20驱动的写时序，在本小节中将完善DS18B20的读时序。

## 2.1 读时序分析

DS18B20数据手册中关于读取的时序图如下所示：

![image-20240226144130779](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261441837.png)

关于DS18B20有读0和读1两种时序，他们的时序是不同的，接下来首先对前半部分读0进行分析。

步骤1：主机拉低总线，从高电平变成低电平，且有时间限制，要确保拉低的时间最少为1微秒

步骤2：主机释放总线，从机拉低总线，15us以内主机完成采样工作，如果这时候从机仍旧处于拉低总线的状态，则采集到的就是0.

步骤3：拉高总线，恢复总线的高电平状态，且要求读操作必须大于60毫秒。

总结出的读取0操作代码如下所示：

~~~c
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}
~~~

然后来对读1的步骤进行分析：

步骤1：主机拉低总线，从高电平变成低电平，且有时间限制，要确保拉低的时间最少为1微秒

步骤2：通过电阻进行上拉，15us以内主机完成采样工作，如果这时候处于电阻上拉的状态，则采集到的就是1

总结出的读1操作代码如下所示：

~~~c
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    
    return bit;
}
~~~

综合上面读1和读0操作的代码以及时序图，可以将两个代码进行整合在一起，整合之后的代码如下所示，大家可以神奇的发现该函数和读0中的函数是相同的。

~~~c
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}
~~~

但这样修改之后的代码仅仅只能读取一个字符，如果要读取8位字符就需要连续使用8次该函数，而为了更方便，可以重新添加一个函数，从而直接读取一个字节的数据，具体内容如下所示：

~~~c
/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}
~~~

至此，关于DS18B20的读操作相关函数就编写完成了，会在下个小节编写填加写时序相关函数的驱动。

## 2.2 DS18b20驱动读时序编写

本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\97_ds18b20_04\

​	编写完成的ds18b20.c代码如下所示:

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h> // 添加此头文件
#include <linux/delay.h>

struct ds18b20_data
{
    dev_t dev_num;
    struct cdev ds18b20_cdev;
    struct class *ds18b20_class;
    struct device *ds18b20_device;
    struct gpio_desc *ds18b20_gpio;
};

struct ds18b20_data *ds18b20;

void ds18b20_reset(void)
{
    // 设置 GPIO 方向为输出，输出低电平
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    udelay(700); // 延迟 700 微秒

    // 设置 GPIO 输出高电平，并将 GPIO 方向设置为输入
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    gpiod_direction_input(ds18b20->ds18b20_gpio);

    // 等待直到 GPIO 输入为低电平
    while (gpiod_get_value(ds18b20->ds18b20_gpio))
        ;

    // 等待直到 GPIO 输入为高电平
    while (!gpiod_get_value(ds18b20->ds18b20_gpio))
        ;
    udelay(480); // 延迟 480 微秒
}

/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);

    // 若 bit 为 1，则延时 10 微秒
    if (bit)
    {
         udelay(10);
         // 将 GPIO 方向设置为输出
    	gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    }
        
    // 延时 65 微秒
    udelay(65);

    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;

    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}

/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}

int ds18b20_open(struct inode *inode, struct file *file)
{
    return 0;
}

ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs)
{
    return 0;
}

int ds18b20_release(struct inode *inode, struct file *file)
{
    return 0;
}

struct file_operations ds18b20_fops = {
    .open = ds18b20_open,
    .read = ds18b20_read,
    .release = ds18b20_release,
    .owner = THIS_MODULE,
};

int ds18b20_probe(struct platform_device *dev)
{
    int ret;
    printk("This is probe \n");

    // 分配内存给ds18b20_data结构体
    ds18b20 = kzalloc(sizeof(*ds18b20), GFP_KERNEL);
    if (ds18b20 == NULL)
    {
        printk("kzalloc error\n");
        ret = -ENOMEM;
        goto error_0;
    }

    // 分配字符设备号
    ret = alloc_chrdev_region(&ds18b20->dev_num, 0, 1, "myds18b20");
    if (ret < 0)
    {
        printk("alloc_chrdev_region error\n");
        ret = -EAGAIN;
        goto error_1;
    }

    // 初始化字符设备
    cdev_init(&ds18b20->ds18b20_cdev, &ds18b20_fops);
    ds18b20->ds18b20_cdev.owner = THIS_MODULE;
    cdev_add(&ds18b20->ds18b20_cdev, ds18b20->dev_num, 1);

    // 创建设备类
    ds18b20->ds18b20_class = class_create(THIS_MODULE, "sensors");
    if (IS_ERR(ds18b20->ds18b20_class))
    {
        printk("class_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_class);
        goto error_2;
    }

    // 创建设备
    ds18b20->ds18b20_device = device_create(ds18b20->ds18b20_class, NULL, ds18b20->dev_num, NULL, "ds18b20");
    if (IS_ERR(ds18b20->ds18b20_device))
    {
        printk("device_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_device);
        goto error_3;
    }

    // 获取GPIO描述符
    ds18b20->ds18b20_gpio = gpiod_get_optional(&dev->dev, "ds18b20", 0);
    if (ds18b20->ds18b20_gpio == NULL)
    {
        ret = -EBUSY;
        goto error_4;
    }

    // 设置GPIO方向为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    return 0;

    error_4:
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);

    error_3:
    class_destroy(ds18b20->ds18b20_class);

    error_2:
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);

    error_1:
    kfree(ds18b20);

    error_0:
    return ret;
}

const struct of_device_id ds18b20_match_table[] = {
    {.compatible = "ds18b20"},
    {},
};

struct platform_driver ds18b20_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = "ds18b20",
        .of_match_table = ds18b20_match_table,
    },
    .probe = ds18b20_probe,
};

static int __init ds18b20_init(void)
{
    int ret;

    // 注册平台驱动
    ret = platform_driver_register(&ds18b20_driver);
    if (ret < 0)
    {
        printk("platform_driver_register error\n");
        return -1;
    }

    return 0;
}

static void __exit ds18b20_exit(void)
{
    // 释放资源
    gpiod_put(ds18b20->ds18b20_gpio);
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);
    class_destroy(ds18b20->ds18b20_class);
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);
    kfree(ds18b20);
    platform_driver_unregister(&ds18b20_driver);
}

module_init(ds18b20_init);
module_exit(ds18b20_exit);
MODULE_LICENSE("GPL");
~~~

由于读时序的实验需要后续的知识作为支撑，所以会在下个小节的驱动中完善温度读取相关的函数之后，再进行测试。



# 3.DS18B20驱动温度读取

在上个章节中讲解了DS18B20的读操作相关的时序以及函数代码编写，但是并没有编写实验函数进行验证，那是因为读操作必然要设计到一些其他的知识，导致知识过于混乱，影响理解和记忆，而本章节将会编写DS18B20温度读取相关的代码及相关的测试应用，最后对DS18B20完整的时序逻辑进行讲解。

## 3.1 DS18B20驱动读温度逻辑分析

在介绍单总线的时候提到过，单总线的通信步骤都有着严格的步骤，具体步骤如下所示：

>1.初始化
>
>2.ROM操作命令
>
>3.功能命令

初始化涉及到的函数就是我们在前面章节中所编写的ds18b20_reset函数，而由于在实验中只使用了一个DS18B20所以只需要写入0xCC，忽略序列号即可。

![image-20240227101514260](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271015323.png)

而第三步中的功能命令我们需要获取到当前的温度，所以需要写入0x44进行温度转换，如下图所示：

![image-20240227102135399](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271021445.png)

温度的转换是需要进行一定的时间的，并且不同分辨率下转换时间也是不同的，具体的转换时间和分辨率关系如下所示：

![image-20240227102428711](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271024743.png)

而默认情况下分辨率为12位，所以需要在程序中延时750毫秒，至此温度转换的操作就完成了，编写完成的代码如下所示：

~~~c
int ds18b20_readtemp(void) {
    ds18b20_reset();// 复位 DS18B20    
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）   
    ds18b20_writebyte(0x44);// 发送写入字节命令 0x44（启动温度转换）    
    mdelay(750);// 延时 750 微秒，等待温度转换完成
}
~~~

接下来需要对转换完成之后的温度进行读取，读取操作仍旧需要遵循单总线的三个操作步骤，其中第一步的初始化和ROM操作命令与温度转换时相同，只有在第三步的功能命令会不同，这里是要进行温度的读取，所以需要发送RAM指令中的第二条0xbe，如下所示：

![image-20240227104042912](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271040959.png)

在内部存储中的Byte0和Byte1用来存储转换之后的温度低位和高位，如下图所示，所以需要使用上一章节中编写的读操作来读取转换之后的温度，具体代码如下所示：

![image-20240227104022209](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271040240.png)

~~~c
/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;     
    ds18b20_reset();// 复位 DS18B20        
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）       
    ds18b20_writebyte(0xBE);// 发送写入字节命令 0xBE（读取温度值）        
    temp_l = ds18b20_readbyte();// 读取温度低位字节        
    temp_h = ds18b20_readbyte();// 读取温度高位字节        
    temp_h = temp_h << 8;// 将温度高位字节左移 8 位
    temp = temp_h | temp_l;// 组合温度值
    
    return temp;
} 
~~~

可以将上面温度转换的步骤和温度读取的步骤整合在一起，形成一个完整的函数，具体函数内容如下所示：

~~~c
/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;   
    
    ds18b20_reset();// 复位 DS18B20    
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）   
    ds18b20_writebyte(0x44);// 发送写入字节命令 0x44（启动温度转换）    
    mdelay(750);// 延时 750 微秒，等待温度转换完成
    
    ds18b20_reset();// 复位 DS18B20        
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）       
    ds18b20_writebyte(0xBE);// 发送写入字节命令 0xBE（读取温度值）        
    temp_l = ds18b20_readbyte();// 读取温度低位字节        
    temp_h = ds18b20_readbyte();// 读取温度高位字节        
    temp_h = temp_h << 8;// 将温度高位字节左移 8 位
    temp = temp_h | temp_l;// 组合温度值
    
    return temp;
} 
~~~

至此，温度读取相关的驱动函数就编写完成了，会在下个小节中将温度读取的函数添加到完整的驱动中。

## 3.2 DS18B20驱动读温度代码编写

 本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\98_ds18b20_05\01_module

相较于上一章节的驱动代码，添加了读取温度相关的函数，并在read函数中通过copy_to_user将获取到的温度传递到用户空间。

编写完成的ds18b20.c代码如下所示:

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h> // 添加此头文件
#include <linux/delay.h>
#include <linux/uaccess.h>

struct ds18b20_data
{
    dev_t dev_num;
    struct cdev ds18b20_cdev;
    struct class *ds18b20_class;
    struct device *ds18b20_device;
    struct gpio_desc *ds18b20_gpio;
};

struct ds18b20_data *ds18b20;

void ds18b20_reset(void)
{
    // 设置 GPIO 方向为输出，输出低电平
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    udelay(700); // 延迟 700 微秒

    // 设置 GPIO 输出高电平，并将 GPIO 方向设置为输入
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    gpiod_direction_input(ds18b20->ds18b20_gpio);

    // 等待直到 GPIO 输入为低电平
    while (gpiod_get_value(ds18b20->ds18b20_gpio))
        ;

    // 等待直到 GPIO 输入为高电平
    while (!gpiod_get_value(ds18b20->ds18b20_gpio))
        ;
    udelay(480); // 延迟 480 微秒
}

/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);

    // 若 bit 为 1，则延时 10 微秒
    if (bit){
        udelay(10);  
        // 将 GPIO 方向设置为输出
    	gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    }
       

    // 延时 65 微秒
    udelay(65);

    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;

    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}

/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}

/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;   
    
    ds18b20_reset();// 复位 DS18B20    
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）   
    ds18b20_writebyte(0x44);// 发送写入字节命令 0x44（启动温度转换）    
    mdelay(750);// 延时 750 微秒，等待温度转换完成
    
    ds18b20_reset();// 复位 DS18B20        
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）       
    ds18b20_writebyte(0xBE);// 发送写入字节命令 0xBE（读取温度值）        
    temp_l = ds18b20_readbyte();// 读取温度低位字节        
    temp_h = ds18b20_readbyte();// 读取温度高位字节        
    temp_h = temp_h << 8;// 将温度高位字节左移 8 位
    temp = temp_h | temp_l;// 组合温度值
    
    return temp;
} 

int ds18b20_open(struct inode *inode, struct file *file)
{
    return 0;
}

ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs) {
    int ds18b20_temp;    
    ds18b20_temp = ds18b20_readtemp();// 从 DS18B20 读取温度值    
    // 将温度值复制到用户空间缓冲区
    if (copy_to_user(buf, &ds18b20_temp, sizeof(ds18b20_temp))) {
        return -1; // 复制失败，返回错误代码
    }
    
    return 0; // 成功读取并复制温度值
}

int ds18b20_release(struct inode *inode, struct file *file)
{
    return 0;
}

struct file_operations ds18b20_fops = {
    .open = ds18b20_open,
    .read = ds18b20_read,
    .release = ds18b20_release,
    .owner = THIS_MODULE,
};

int ds18b20_probe(struct platform_device *dev)
{
    int ret;
    printk("This is probe \n");

    // 分配内存给ds18b20_data结构体
    ds18b20 = kzalloc(sizeof(*ds18b20), GFP_KERNEL);
    if (ds18b20 == NULL)
    {
        printk("kzalloc error\n");
        ret = -ENOMEM;
        goto error_0;
    }

    // 分配字符设备号
    ret = alloc_chrdev_region(&ds18b20->dev_num, 0, 1, "myds18b20");
    if (ret < 0)
    {
        printk("alloc_chrdev_region error\n");
        ret = -EAGAIN;
        goto error_1;
    }

    // 初始化字符设备
    cdev_init(&ds18b20->ds18b20_cdev, &ds18b20_fops);
    ds18b20->ds18b20_cdev.owner = THIS_MODULE;
    cdev_add(&ds18b20->ds18b20_cdev, ds18b20->dev_num, 1);

    // 创建设备类
    ds18b20->ds18b20_class = class_create(THIS_MODULE, "sensors");
    if (IS_ERR(ds18b20->ds18b20_class))
    {
        printk("class_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_class);
        goto error_2;
    }

    // 创建设备
    ds18b20->ds18b20_device = device_create(ds18b20->ds18b20_class, NULL, ds18b20->dev_num, NULL, "ds18b20");
    if (IS_ERR(ds18b20->ds18b20_device))
    {
        printk("device_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_device);
        goto error_3;
    }

    // 获取GPIO描述符
    ds18b20->ds18b20_gpio = gpiod_get_optional(&dev->dev, "ds18b20", 0);
    if (ds18b20->ds18b20_gpio == NULL)
    {
        ret = -EBUSY;
        goto error_4;
    }

    // 设置GPIO方向为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    return 0;

    error_4:
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);

    error_3:
    class_destroy(ds18b20->ds18b20_class);

    error_2:
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);

    error_1:
    kfree(ds18b20);

    error_0:
    return ret;
}

const struct of_device_id ds18b20_match_table[] = {
    {.compatible = "ds18b20"},
    {},
};

struct platform_driver ds18b20_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = "ds18b20",
        .of_match_table = ds18b20_match_table,
    },
    .probe = ds18b20_probe,
};

static int __init ds18b20_init(void)
{
    int ret;

    // 注册平台驱动
    ret = platform_driver_register(&ds18b20_driver);
    if (ret < 0)
    {
        printk("platform_driver_register error\n");
        return -1;
    }

    return 0;
}

static void __exit ds18b20_exit(void)
{
    // 释放资源
    gpiod_put(ds18b20->ds18b20_gpio);
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);
    class_destroy(ds18b20->ds18b20_class);
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);
    kfree(ds18b20);
    platform_driver_unregister(&ds18b20_driver);
}

module_init(ds18b20_init);
module_exit(ds18b20_exit);
MODULE_LICENSE("GPL");
~~~

## 3.3 应用程序编写

上一小节编写完成的驱动程序会将采集到的温度值通过copy_to_user函数传递到用户空间，而用户空间需要使用系统调用read函数来读取传递过来的温度数据，需要注意的是这里传递过来的数据还是未经处理的二进制数据，要想得到实际可用的温度值还需要在应用程序中进行后处理操作。

具体关于温度后处理的内容可以查看156.6.2温度测量寄存器寄存器相关章节，编写好的测试程序存放位置为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\98_ds18b20_05\02_app

~~~c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void ds18b20_get_temp(int value) {
    char sig;
    float temp;
    if ((value >> 11) & 0x01) {
        sig = '-';
        value = ~value + 1;  // 取补码，表示负数
        value &= ~(0xF8 << 8);  // 清除高5位，保留低11位
    } else {
        sig = '+';
    }
    temp = value * 0.0625;  // 将温度值乘以0.0625，得到实际温度值
}

int main(int argc, char *argv[]) {
    int fd;
    int data;


    fd = open("/dev/ds18b20", O_RDWR);  // 打开设备文件 /dev/ds18b20
    if (fd < 0) {
        printf("打开文件失败！\n");
        return -1;
    }

    while (1) {
        if (read(fd, &data, sizeof(data)) < 0) {  // 从设备文件中读取数据
            printf("读取数据失败！\n");
            return -1;
        }
        ds18b20_get_temp(data);  // 将读取的数据转换为温度值
        printf("温度为 %c%.4f\n", sig, temp);  // 打印温度值
    }

    close(fd);  // 关闭设备文件
    return 0;
}
~~~



## 3.4 运行测试

### 3.4.1 编译驱动程序

在上一小节中的de18b20.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += de18b20.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ds18b20.c和Makefile文件目录下，如下图所示：

![image-20240227124053773](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271240822.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240227124106952](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271241026.png)

编译完生成ds18b20.ko目标文件，如下图所示：

![image-20240227124127112](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271241160.png)

至此驱动模块就编译成功了。

### 3.4.2 编译应用程序

首先进行应用程序的编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图所示：

~~~shell
aarch64-linux-gnu-gcc app.c -o app
~~~

![image-20240227124229211](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271242271.png)

然后将编译完成的可执行程序拷贝到开发板上

### 3.4.3 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261440694.png)

然后将上两个小节编译完成的ds18b20.ko驱动和可执行程序app文件拷贝到开发板上，拷贝完成如下所示：
![image-20240227124401720](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271244782.png)

然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod ds18b20.ko
~~~

![image-20240227124513082](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271245123.png)

然后运行可执行程序app，可以看到当前的温度就打印了出来，如下图所示：

![image-20240227131903649](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271319727.png)

​	当我用手触摸DS18B20传感器的时候，可以看到温度明显的上升了，接下来查看逻辑分析仪采集到的时序图。

​	首先采集到的波形图为复位时序图，接下来是0XCC的ROM指令，表示跳过ROM指令，0x44表示功能命令，进行温度转换。

![image-20240227135632697](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271356745.png)

第二个采集到的波形复位和ROM指令与第一个波形是相同的，所以这里直接来看后续的功能命令以及采集到的温度，如下所示：
![image-20240227135712187](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271357245.png)

首先发送了0xbe指令，表示读取暂存寄存器，后面的0xBB和0x01分别表示温度的低八位和高8位,换算成10进制为443，然后乘以0.0625可以得到当前的温度为27.6875，至此关于逻辑分析仪采集到的波形就分析完成了。

# 4.DS18B20驱动使用ioctl设置分辨率

在上个章节中成功获取到了DS18B20的温度，默认情况下DS18B20的分辨率为12位，可以通过修改配置寄存器从而改变分辨率的大小，总共支持9位、10位、11位、12位四种分辨率，在本章节中将完善驱动中的ioctl部分，增加分辨率修改相关的代码，然后编写相应的应用程序进行分辨率修改的测试。

## 4.1 ioctl设置分辨率驱动代码编写

 本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\99_ds18b20_06\01_module

相较于上一章节的驱动代码，添加了ioctl设置分辨率相关的函数，除此之外完成了另外两个功能函数，分别为设置 DS18B20 温度传感器的分辨率的set_resolution函数，以及检查参数的有效性的check_args函数，编写完成的ds18b20.c代码如下所示:

~~~c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h> // 添加此头文件
#include <linux/delay.h>
#include <linux/uaccess.h>

#define SET_RESOLUTION _IOW('A', 0, int)
#define SET_RESOLUTION_9 9
#define SET_RESOLUTION_10 10
#define SET_RESOLUTION_11 11
#define SET_RESOLUTION_12 12

struct ds18b20_data
{
    dev_t dev_num;
    struct cdev ds18b20_cdev;
    struct class *ds18b20_class;
    struct device *ds18b20_device;
    struct gpio_desc *ds18b20_gpio;
};

struct ds18b20_data *ds18b20;

void ds18b20_reset(void)
{
    // 设置 GPIO 方向为输出，输出低电平
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    udelay(700); // 延迟 700 微秒

    // 设置 GPIO 输出高电平，并将 GPIO 方向设置为输入
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    gpiod_direction_input(ds18b20->ds18b20_gpio);

    // 等待直到 GPIO 输入为低电平
    while (gpiod_get_value(ds18b20->ds18b20_gpio))
        ;

    // 等待直到 GPIO 输入为高电平
    while (!gpiod_get_value(ds18b20->ds18b20_gpio))
        ;
    udelay(480); // 延迟 480 微秒
}

/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);

    // 若 bit 为 1，则延时 10 微秒
    if (bit){
        udelay(10);  
        // 将 GPIO 方向设置为输出
    	gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    }
       

    // 延时 65 微秒
    udelay(65);

    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;

    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}

/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}

/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;   
    
    ds18b20_reset();// 复位 DS18B20    
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）   
    ds18b20_writebyte(0x44);// 发送写入字节命令 0x44（启动温度转换）    
    mdelay(750);// 延时 750 微秒，等待温度转换完成
    
    ds18b20_reset();// 复位 DS18B20        
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）       
    ds18b20_writebyte(0xBE);// 发送写入字节命令 0xBE（读取温度值）        
    temp_l = ds18b20_readbyte();// 读取温度低位字节        
    temp_h = ds18b20_readbyte();// 读取温度高位字节        
    temp_h = temp_h << 8;// 将温度高位字节左移 8 位
    temp = temp_h | temp_l;// 组合温度值
    
    return temp;
} 

/**
 * 设置 DS18B20 温度传感器的分辨率
 * @param args 分辨率参数
 */
void set_resolution(int args) {
    ds18b20_reset();  // 复位 DS18B20 温度传感器
    ds18b20_writebyte(0xCC);  // 发送跳过 ROM 命令
    ds18b20_writebyte(0x4E);  // 发送写配置寄存器命令
    ds18b20_writebyte(60);  // 发送配置字节 1，设置温度上限阈值
    ds18b20_writebyte(10);  // 发送配置字节 2，设置温度下限阈值

    switch (args) {
        case SET_RESOLUTION_9:  // 设置分辨率为 9 位
            ds18b20_writebyte(0x1F);  // 发送配置字节 3，设置分辨率为 9 位
            break;
        case SET_RESOLUTION_10:  // 设置分辨率为 10 位
            ds18b20_writebyte(0x3F);  // 发送配置字节 3，设置分辨率为 10 位
            break;
        case SET_RESOLUTION_11:  // 设置分辨率为 11 位
            ds18b20_writebyte(0x5F);  // 发送配置字节 3，设置分辨率为 11 位
            break;
        case SET_RESOLUTION_12:  // 设置分辨率为 12 位
            ds18b20_writebyte(0x7F);  // 发送配置字节 3，设置分辨率为 12 位
            break;
        default:
            break;
    }
}

/**
 * 检查参数的有效性
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
int check_args(int args) {
    int ret = -1;  // 返回值，默认为失败

    ds18b20_reset();  // 复位传感器
    ds18b20_writebyte(0xCC);  // 发送指令字节 0xCC
    ds18b20_writebyte(0xBE);  // 发送指令字节 0xBE
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节

    switch (args) {
        case SET_RESOLUTION_9:
            if (ds18b20_readbyte() == 0x1F) {  // 读取一个字节并与 0x1F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_10:
            if (ds18b20_readbyte() == 0x3F) {  // 读取一个字节并与 0x3F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_11:
            if (ds18b20_readbyte() == 0x5F) {  // 读取一个字节并与 0x5F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_12:
            if (ds18b20_readbyte() == 0x7F) {  // 读取一个字节并与 0x7F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        default:
            break;
    }

    return ret;  // 返回结果
}

int ds18b20_open(struct inode *inode, struct file *file)
{
    return 0;
}

ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs) {
    int ds18b20_temp;    
    ds18b20_temp = ds18b20_readtemp();// 从 DS18B20 读取温度值    
    // 将温度值复制到用户空间缓冲区
    if (copy_to_user(buf, &ds18b20_temp, sizeof(ds18b20_temp))) {
        return -1; // 复制失败，返回错误代码
    }
    
    return 0; // 成功读取并复制温度值
}

int ds18b20_release(struct inode *inode, struct file *file)
{
    return 0;
}

/**
 * DS18B20 温度传感器的 ioctl 函数
 * @param file 文件指针
 * @param cmd 命令
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
long ds18b20_ioctl(struct file *file, unsigned int cmd, unsigned long args) {
    printk("this is ioctl\n");
    if (cmd == SET_RESOLUTION) {  // 判断命令是否为设置分辨率
        if (args >= SET_RESOLUTION_9 && args <= SET_RESOLUTION_12) {  // 判断参数是否在有效的分辨率范围内
            set_resolution(args);  // 调用设置分辨率
	    printk("set_resolution ok \n");
            return 0;  // 返回成功
        }
    }
    // 如果不匹配 SET_RESOLUTION 或者 args 不在有效范围内，不执行任何操作
    return -1;  // 返回失败
}

struct file_operations ds18b20_fops = {
    .open = ds18b20_open,
    .read = ds18b20_read,
    .release = ds18b20_release,
    .unlocked_ioctl = ds18b20_ioctl,
    .owner = THIS_MODULE,
};

int ds18b20_probe(struct platform_device *dev)
{
    int ret;
    printk("This is probe \n");

    // 分配内存给ds18b20_data结构体
    ds18b20 = kzalloc(sizeof(*ds18b20), GFP_KERNEL);
    if (ds18b20 == NULL)
    {
        printk("kzalloc error\n");
        ret = -ENOMEM;
        goto error_0;
    }

    // 分配字符设备号
    ret = alloc_chrdev_region(&ds18b20->dev_num, 0, 1, "myds18b20");
    if (ret < 0)
    {
        printk("alloc_chrdev_region error\n");
        ret = -EAGAIN;
        goto error_1;
    }

    // 初始化字符设备
    cdev_init(&ds18b20->ds18b20_cdev, &ds18b20_fops);
    ds18b20->ds18b20_cdev.owner = THIS_MODULE;
    cdev_add(&ds18b20->ds18b20_cdev, ds18b20->dev_num, 1);

    // 创建设备类
    ds18b20->ds18b20_class = class_create(THIS_MODULE, "sensors");
    if (IS_ERR(ds18b20->ds18b20_class))
    {
        printk("class_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_class);
        goto error_2;
    }

    // 创建设备
    ds18b20->ds18b20_device = device_create(ds18b20->ds18b20_class, NULL, ds18b20->dev_num, NULL, "ds18b20");
    if (IS_ERR(ds18b20->ds18b20_device))
    {
        printk("device_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_device);
        goto error_3;
    }

    // 获取GPIO描述符
    ds18b20->ds18b20_gpio = gpiod_get_optional(&dev->dev, "ds18b20", 0);
    if (ds18b20->ds18b20_gpio == NULL)
    {
        ret = -EBUSY;
        goto error_4;
    }

    // 设置GPIO方向为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    return 0;

    error_4:
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);

    error_3:
    class_destroy(ds18b20->ds18b20_class);

    error_2:
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);

    error_1:
    kfree(ds18b20);

    error_0:
    return ret;
}

const struct of_device_id ds18b20_match_table[] = {
    {.compatible = "ds18b20"},
    {},
};

struct platform_driver ds18b20_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = "ds18b20",
        .of_match_table = ds18b20_match_table,
    },
    .probe = ds18b20_probe,
};

static int __init ds18b20_init(void)
{
    int ret;

    // 注册平台驱动
    ret = platform_driver_register(&ds18b20_driver);
    if (ret < 0)
    {
        printk("platform_driver_register error\n");
        return -1;
    }

    return 0;
}

static void __exit ds18b20_exit(void)
{
    // 释放资源
    gpiod_put(ds18b20->ds18b20_gpio);
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);
    class_destroy(ds18b20->ds18b20_class);
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);
    kfree(ds18b20);
    platform_driver_unregister(&ds18b20_driver);
}

module_init(ds18b20_init);
module_exit(ds18b20_exit);
MODULE_LICENSE("GPL");
~~~



## 4.2 应用程序编写

上一小节编写了ioctl设置温度采集分辨率的程序，而ioctl需要跟用户空间的应用程序相配合才能进行使用，所以在本小节将编写测试用的应用程序，编写好的测试程序存放位置为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\99_ds18b20_06\02_app

~~~c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdlib.h>

#define SET_RESOLUTION _IOW('A', 0, int)

/**
 * 根据传感器读取的原始数据计算温度值
 * @param value 传感器读取的原始数据
 */
void ds18b20_get_temp(int value) {
    char sig;   // 温度正负号
    float temp; // 温度值

    // 判断温度正负号
    if ((value >> 11) & 0x01) {
        sig = '-';
        value = ~value + 1;
        value &= ~(0xf8 << 8);
    } else {
        sig = '+';
    }

    // 计算温度值
    temp = value * 0.0625;

    // 打印温度信息
    printf("温度为 %c%.4f\n", sig, temp);
}

int main(int argc, char *argv[]) {
    int fd;    // 文件描述符
    int data;  // 读取的数据
    int args;  // 参数值

    // 打开设备文件
    fd = open("/dev/ds18b20", O_RDWR);
    if (fd < 0) {
        printf("打开设备文件出错\n");
        return -1;
    }

    // 获取命令行参数
    args = atoi(argv[1]);
    printf("参数值为 %d\n", args);

    // 检查参数范围
    if (args < 9 || args > 12) {
        printf("错误！参数范围应为 9 - 12\n");
        return -1;
    }

    // 设置分辨率
    ioctl(fd, SET_RESOLUTION, args);

    while (1) {
        // 读取数据
        read(fd, &data, sizeof(data));

        // 处理并打印温度信息
        ds18b20_get_temp(data);
    }

    return 0;
}
~~~

## 4.3 运行测试

### 4.3.1 编译驱动程序

在上一小节中的de18b20.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += de18b20.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ds18b20.c和Makefile文件目录下，如下图所示：

![image-20240227153301625](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271533677.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240227153318385](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271533444.png)

编译完生成ds18b20.ko目标文件，如下图所示：

![image-20240227153342783](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271533840.png)

至此驱动模块就编译成功了。

### 4.3.2 编译应用程序

首先进行应用程序的编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图所示：

~~~shell
aarch64-linux-gnu-gcc app.c -o app
~~~

![image-20240227153503415](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271535477.png)

然后将编译完成的可执行程序拷贝到开发板上。

### 4.3.3 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261440694.png)

然后将上两个小节编译完成的ds18b20.ko驱动和可执行程序app文件拷贝到开发板上，拷贝完成如下所示：
![image-20240227124401720](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271244782.png)

然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod ds18b20.ko
~~~

![image-20240227124513082](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271245123.png)

然后使用以下命令运行可执行程序app，设置分辨率为9位，然后打印采集到的温度，如下图所示：

~~~c
./app 9
~~~

![image-20240227160717277](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271607345.png)

​	当我用手触摸DS18B20传感器的时候，可以看到温度明显的上升了，并且温度上升的分辨率位9位，也可以设置其他例如10、11位的分辨率，至此，关于通过ioctl设置ds18b20温度采集分辨率的实验就完成了。



# 5.DS18B20驱动使用ioctl读取分辨率

在上个章节中成功在驱动中添加了ioctl相关代码，通过ioctl对DS18B20采集到的温度分辨率进行设置。而在本章节将继续完善驱动程序，对DS18B20采集到的温度分辨率进行读取，然后编写相应的应用程序进行分辨率读取测试。

## 5.1  ioctl读取分辨率驱动代码编写

 本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\100_ds18b20_07\01_module

相较于上一章节的驱动代码，添加了ioctl查看分辨率相关的函数，除此之外完成了查看温度分辨率函数read_resolution()，编写完成的ds18b20.c代码如下所示:

~~~C
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h> // 添加此头文件
#include <linux/delay.h>
#include <linux/uaccess.h>

#define SET_RESOLUTION _IOW('A', 0, int)
#define READ_RESOLUTION _IOR('A', 1, int)

#define SET_RESOLUTION_9 9
#define SET_RESOLUTION_10 10
#define SET_RESOLUTION_11 11
#define SET_RESOLUTION_12 12

struct ds18b20_data
{
    dev_t dev_num;
    struct cdev ds18b20_cdev;
    struct class *ds18b20_class;
    struct device *ds18b20_device;
    struct gpio_desc *ds18b20_gpio;
};

struct ds18b20_data *ds18b20;

void ds18b20_reset(void)
{
    // 设置 GPIO 方向为输出，输出低电平
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    udelay(700); // 延迟 700 微秒

    // 设置 GPIO 输出高电平，并将 GPIO 方向设置为输入
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    gpiod_direction_input(ds18b20->ds18b20_gpio);

    // 等待直到 GPIO 输入为低电平
    while (gpiod_get_value(ds18b20->ds18b20_gpio))
        ;

    // 等待直到 GPIO 输入为高电平
    while (!gpiod_get_value(ds18b20->ds18b20_gpio))
        ;
    udelay(480); // 延迟 480 微秒
}

/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);

    // 若 bit 为 1，则延时 10 微秒
    if (bit){
        udelay(10);  
        // 将 GPIO 方向设置为输出
    	gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    }
       

    // 延时 65 微秒
    udelay(65);

    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;

    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}

/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;        
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);// 将 GPIO 方向设置为输出        
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);// 将 GPIO 输出设置为低电平        
    udelay(2);// 延时 2 微秒        
    gpiod_direction_input(ds18b20->ds18b20_gpio);// 将 GPIO 方向设置为输入   
    udelay(10);// 延时 10 微秒       
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);// 读取 GPIO 的值作为位(bit)       
    udelay(60);// 延时 60 微秒
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}

/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;   
    
    ds18b20_reset();// 复位 DS18B20    
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）   
    ds18b20_writebyte(0x44);// 发送写入字节命令 0x44（启动温度转换）    
    mdelay(750);// 延时 750 微秒，等待温度转换完成
    
    ds18b20_reset();// 复位 DS18B20        
    ds18b20_writebyte(0xCC);// 发送写入字节命令 0xCC（跳过 ROM）       
    ds18b20_writebyte(0xBE);// 发送写入字节命令 0xBE（读取温度值）        
    temp_l = ds18b20_readbyte();// 读取温度低位字节        
    temp_h = ds18b20_readbyte();// 读取温度高位字节        
    temp_h = temp_h << 8;// 将温度高位字节左移 8 位
    temp = temp_h | temp_l;// 组合温度值
    
    return temp;
} 

/**
 * 设置 DS18B20 温度传感器的分辨率
 * @param args 分辨率参数
 */
void set_resolution(int args) {
    ds18b20_reset();  // 复位 DS18B20 温度传感器
    ds18b20_writebyte(0xCC);  // 发送跳过 ROM 命令
    ds18b20_writebyte(0x4E);  // 发送写配置寄存器命令
    ds18b20_writebyte(60);  // 发送配置字节 1，设置温度上限阈值
    ds18b20_writebyte(10);  // 发送配置字节 2，设置温度下限阈值

    switch (args) {
        case SET_RESOLUTION_9:  // 设置分辨率为 9 位
            ds18b20_writebyte(0x1F);  // 发送配置字节 3，设置分辨率为 9 位
            break;
        case SET_RESOLUTION_10:  // 设置分辨率为 10 位
            ds18b20_writebyte(0x3F);  // 发送配置字节 3，设置分辨率为 10 位
            break;
        case SET_RESOLUTION_11:  // 设置分辨率为 11 位
            ds18b20_writebyte(0x5F);  // 发送配置字节 3，设置分辨率为 11 位
            break;
        case SET_RESOLUTION_12:  // 设置分辨率为 12 位
            ds18b20_writebyte(0x7F);  // 发送配置字节 3，设置分辨率为 12 位
            break;
        default:
            break;
    }
}

/**
 * 检查参数的有效性
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
int check_args(int args) {
    int ret = -1;  // 返回值，默认为失败

    ds18b20_reset();  // 复位传感器
    ds18b20_writebyte(0xCC);  // 发送指令字节 0xCC
    ds18b20_writebyte(0xBE);  // 发送指令字节 0xBE
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节

    switch (args) {
        case SET_RESOLUTION_9:
            if (ds18b20_readbyte() == 0x1F) {  // 读取一个字节并与 0x1F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_10:
            if (ds18b20_readbyte() == 0x3F) {  // 读取一个字节并与 0x3F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_11:
            if (ds18b20_readbyte() == 0x5F) {  // 读取一个字节并与 0x5F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_12:
            if (ds18b20_readbyte() == 0x7F) {  // 读取一个字节并与 0x7F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        default:
            break;
    }

    return ret;  // 返回结果
}


/**
 * 读取分辨率。
 *
 * @return 分辨率值
 */
int read_resolution(void) {
    int ret;

    // 复位传感器
    ds18b20_reset();

    // 发送指令字节0xCC，跳过ROM操作，直接与单个设备通信
    ds18b20_writebyte(0xCC);

    // 发送指令字节0xBE，读取当前设备的配置寄存器
    ds18b20_writebyte(0xBE);

    // 读取4个字节的数据，但实际上只有最后一个字节是分辨率信息
    ds18b20_readbyte();
    ds18b20_readbyte();
    ds18b20_readbyte();
    ds18b20_readbyte();

    // 读取最后一个字节，即分辨率信息
    ret = ds18b20_readbyte();

    // 返回分辨率值
    return ret;
}


int ds18b20_open(struct inode *inode, struct file *file)
{
    return 0;
}

ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs) {
    int ds18b20_temp;    
    ds18b20_temp = ds18b20_readtemp();// 从 DS18B20 读取温度值    
    // 将温度值复制到用户空间缓冲区
    if (copy_to_user(buf, &ds18b20_temp, sizeof(ds18b20_temp))) {
        return -1; // 复制失败，返回错误代码
    }
    
    return 0; // 成功读取并复制温度值
}

int ds18b20_release(struct inode *inode, struct file *file)
{
    return 0;
}

/**
 * DS18B20 温度传感器的 ioctl 函数
 * @param file 文件指针
 * @param cmd 命令
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
long ds18b20_ioctl(struct file *file, unsigned int cmd, unsigned long args) {
    int resolution;
    if (cmd == SET_RESOLUTION) {  // 判断命令是否为设置分辨率
        if (args >= SET_RESOLUTION_9 && args <= SET_RESOLUTION_12) {  // 判断参数是否在有效的分辨率范围内
            set_resolution(args);  // 调用设置分辨率的函数
            return 0;  // 返回成功
        }
    }
    else if (cmd == READ_RESOLUTION) {
        // 读取分辨率
        resolution = read_resolution();
        // 将分辨率的值复制给用户空间的args
        if (copy_to_user((int *)args, &resolution, sizeof(resolution))) {
            // 复制失败，返回-1表示失败
            return -1;
        }
    }
    // 如果不匹配 SET_RESOLUTION 或者 args 不在有效范围内，不执行任何操作
    return -1;  // 返回失败
}

struct file_operations ds18b20_fops = {
    .open = ds18b20_open,
    .read = ds18b20_read,
    .release = ds18b20_release,
    .unlocked_ioctl = ds18b20_ioctl,
    .owner = THIS_MODULE,
};

int ds18b20_probe(struct platform_device *dev)
{
    int ret;
    printk("This is probe \n");

    // 分配内存给ds18b20_data结构体
    ds18b20 = kzalloc(sizeof(*ds18b20), GFP_KERNEL);
    if (ds18b20 == NULL)
    {
        printk("kzalloc error\n");
        ret = -ENOMEM;
        goto error_0;
    }

    // 分配字符设备号
    ret = alloc_chrdev_region(&ds18b20->dev_num, 0, 1, "myds18b20");
    if (ret < 0)
    {
        printk("alloc_chrdev_region error\n");
        ret = -EAGAIN;
        goto error_1;
    }

    // 初始化字符设备
    cdev_init(&ds18b20->ds18b20_cdev, &ds18b20_fops);
    ds18b20->ds18b20_cdev.owner = THIS_MODULE;
    cdev_add(&ds18b20->ds18b20_cdev, ds18b20->dev_num, 1);

    // 创建设备类
    ds18b20->ds18b20_class = class_create(THIS_MODULE, "sensors");
    if (IS_ERR(ds18b20->ds18b20_class))
    {
        printk("class_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_class);
        goto error_2;
    }

    // 创建设备
    ds18b20->ds18b20_device = device_create(ds18b20->ds18b20_class, NULL, ds18b20->dev_num, NULL, "ds18b20");
    if (IS_ERR(ds18b20->ds18b20_device))
    {
        printk("device_create error\n");
        ret = PTR_ERR(ds18b20->ds18b20_device);
        goto error_3;
    }

    // 获取GPIO描述符
    ds18b20->ds18b20_gpio = gpiod_get_optional(&dev->dev, "ds18b20", 0);
    if (ds18b20->ds18b20_gpio == NULL)
    {
        ret = -EBUSY;
        goto error_4;
    }

    // 设置GPIO方向为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);

    return 0;

    error_4:
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);

    error_3:
    class_destroy(ds18b20->ds18b20_class);

    error_2:
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);

    error_1:
    kfree(ds18b20);

    error_0:
    return ret;
}

const struct of_device_id ds18b20_match_table[] = {
    {.compatible = "ds18b20"},
    {},
};

struct platform_driver ds18b20_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = "ds18b20",
        .of_match_table = ds18b20_match_table,
    },
    .probe = ds18b20_probe,
};

static int __init ds18b20_init(void)
{
    int ret;

    // 注册平台驱动
    ret = platform_driver_register(&ds18b20_driver);
    if (ret < 0)
    {
        printk("platform_driver_register error\n");
        return -1;
    }

    return 0;
}

static void __exit ds18b20_exit(void)
{
    // 释放资源
    gpiod_put(ds18b20->ds18b20_gpio);
    device_destroy(ds18b20->ds18b20_class, ds18b20->dev_num);
    class_destroy(ds18b20->ds18b20_class);
    cdev_del(&ds18b20->ds18b20_cdev);
    unregister_chrdev_region(ds18b20->dev_num, 1);
    kfree(ds18b20);
    platform_driver_unregister(&ds18b20_driver);
}

module_init(ds18b20_init);
module_exit(ds18b20_exit);
MODULE_LICENSE("GPL");
~~~



## 5.2 应用程序编写

在上一小节中编写了ioctl通过ioctl设置DS18B20获取采集温度分辨率的程序，而ioctl需要跟用户空间的应用程序相配合才能进行使用，所以在本小节将编写测试用的应用程序，编写好的测试程序存放位置为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\100_ds18b20_07\02_app

~~~C
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdlib.h>

#define SET_RESOLUTION _IOW('A', '0', int)
#define READ_RESOLUTION _IOR('A', '1', int)

/**
 * 根据传感器读取的原始数据计算温度值
 * @param value 传感器读取的原始数据
 */
void ds18b20_get_temp(int value) {
    char sig;   // 温度正负号
    float temp; // 温度值

    // 判断温度正负号
    if ((value >> 11) & 0x01) {
        sig = '-';
        value = ~value + 1;
        value &= ~(0xf8 << 8);
    } else {
        sig = '+';
    }

    // 计算温度值
    temp = value * 0.0625;

    // 打印温度信息
    printf("温度为 %c%.4f\n", sig, temp);
}


/**
 * 根据传感器分辨率值打印分辨率信息
 * @param value 传感器分辨率值
 */
void ds18b20_get_resolution(int value) {
    switch (value) {
        case 0x1F:
            printf("分辨率为 9 位\n");
            break;
        case 0x3F:
            printf("分辨率为 10 位\n");
            break;
        case 0x5F:
            printf("分辨率为 11 位\n");
            break;
        case 0x7F:
            printf("分辨率为 12 位\n");
            break;
        default:
            break;
    }
}

int main(int argc, char *argv[]) {
    int fd;    // 文件描述符
    int data;  // 读取的数据
    int args;  // 参数值
    int resolution;  // 返回的分辨率的值

    // 打开设备文件
    fd = open("/dev/ds18b20", O_RDWR);
    if (fd < 0) {
        printf("打开设备文件出错\n");
        return -1;
    }

    // 获取命令行参数
    args = atoi(argv[1]);
    printf("参数值为 %d\n", args);

    // 检查参数范围
    if (args < 9 || args > 12) {
        printf("错误！参数范围应为 9 - 12\n");
        return -1;
    }

    // 设置分辨率
    ioctl(fd, SET_RESOLUTION, args);

    // 读取分辨率
    ioctl(fd, READ_RESOLUTION, &resolution);
    ds18b20_get_resolution(resolution);
    while (1) {
        // 读取数据
        read(fd, &data, sizeof(data));

        // 处理并打印温度信息
        ds18b20_get_temp(data);
    }

    return 0;
}
~~~



## 5.3 运行测试

### 5.3.1 编译驱动程序

在上一小节中的de18b20.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += de18b20.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ds18b20.c和Makefile文件目录下，如下图所示：

![image-20240227162537233](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271625286.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240227162645078](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271626143.png)

编译完生成ds18b20.ko目标文件，如下图所示：

![image-20240227162627206](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271626266.png)

至此驱动模块就编译成功了。

### 5.3.2 编译应用程序

首先进行应用程序的编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图所示：

~~~shell
aarch64-linux-gnu-gcc app.c -o app
~~~

![image-20240227163033721](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271630768.png)

然后将编译完成的可执行程序拷贝到开发板上

### 5.3.3 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261440694.png)

然后将上两个小节编译完成的ds18b20.ko驱动和可执行程序app文件拷贝到开发板上，拷贝完成如下所示：
![image-20240227124401720](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271244782.png)

然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod ds18b20.ko
~~~

![image-20240227124513082](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271245123.png)

然后使用以下命令运行可执行程序app，设置分辨率为9位，然后打印采集到的温度，如下图所示：

~~~c
./app 9
~~~

![image-20240227164648506](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402271646576.png)

​	第一个打印表示我们的传入参数9，第二个打印为通过ioctl获取得到的ds18b20的温度分辨率，可以看到设置和和通过ioctl获取的分辨率相同，且后面得到的温度确实为9位分辨率，证明试验成功，至此，关于通过ioctl获取ds18b20温度采集分辨率的实验就完成了。







