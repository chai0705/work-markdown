

# 2.5 工作记录

==不积跬步无以致千里，不积小流无以成江海。==

___

不是很喜欢现在的样子，意识到了问题所在但仍旧是不知悔改的走进去，你不感觉问题很大吗，相较于之前，在之前的时候还从未认识到这个问题，但是现在认识到问题所在了，依然义无反顾的走进去，这是不对的。昨天真的是困困的，所以酒精还是很重要的，当然酸枣仁膏应该也是有用的，年后的时候买一下。

现在的阻碍还是太小了，有些东西的认识还是不全面，虽然黑白手机确实有一定的阻碍作用，但仍旧是无可避免的要沉迷进去，现在都沉迷在哪些地方呢，淘宝和小说，淘宝的问题是有众多的广告，而小说问题可太大了，目前仍旧不知道如何搞，目前想的是看小说可以，但是不能躺着，一定是要坐着，所以就打算买个人体工学椅试试看。但真的很贵呀，啊啊啊啊，真的太贵了，等等看吧，有一点很重要，好像你自己也不知道你想象中的最好的一天应该是怎样过的，身在局中，却永远无法出去。

___

 编写最简单的输入设备驱动



4907 基础工资 

750 饭补                         15079 

900 技术支持                     14279

3593 工资剩余                    10686 

1700 年假                       8986 

8500 年终奖                    486

500 奖金 0













# 2.4 工作记录

==不积跬步无以至千里，不积小流无以成江海。==

昨天晚上十一点前的行为确实很可以，首先是将显示器挪了一个地方，从右边放到了头的上边，就也还行吧，就目前来看的话，我是比较喜欢现在这个样子，更好的样子，目前还没想出来，等后面有机会再看看，算了，就先这样吧，价值太高了，然后就是开始搞远程桌面，在远程桌面上,遇到了很多的问题，最后应该是administrator，这个单词可是真的坑人，哈哈，昨天算是体验到了心流的好处，时间真的刷刷刷的就过去了，当沉浸感和技巧程度叠相差不大的时候，这种体验确实让人沉醉。然后开始今天的工作了。

____

## 输入子系统框架讲解

先说一下我自己的理解好吧，好像也没啥理解，但是这也是我在看了后面的视频之后才理解的，我应该要如何讲解出来呢？

![image-20240204093851583](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402040938670.png)

其实从最上层的角度来看，不管你要讲解的是什么，都无外乎可以划分这三个，而至于更具体的划分就要看内核源码了。行了，第二遍也看完了，仍旧是说一下看完之后的总结：

![image-20240204095828374](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402040958629.png)

整个视频都是围绕这个来的，分别根据逻辑来讲了一下各个层，首先是事件处理层，它是输入子系统的最上层，用户空间的应用通过设备节点来控制硬件设备，那设备节点是怎样来的呢？事件处理层的作用就出现了，然后是设备驱动层，设备驱动层紧挨着各个对应的硬件设备，所以它的作用就是初始化对应的硬件输入设备，并且采集输入设备的输入信息，那采集到的信息要发送传递给哪个对应的设备节点呢？这就是中间核心层的作用了，用来匹配设备驱动层和事件处理层，没了，这节视频就讲了这么多。

## 输入子系统框架分析

在上个视频中讲解了输入子系统框架，但是也仅仅只是讲解，这个输入子系统框架是怎	样得出来的呢？这节视频讲解的就是输入子系统框架的由来，我第一次听的时候感觉很乱很乱，现在让我听倒是好多了，但是仍旧不是很好写出来，主要是这个视频跟下个视频的间距感太差了，这节课讲解分析的是代码，下节课也是讲解的这些，那他是怎样分开的呢？  

行了，看完了这一节的视频了，这节跟下一节其实是一个，所以这里直接看下一节视频了。

## 输入子系统关键数据结构之间关系

上一节课讲到connect了，但也只是讲解了上层的事件处理层的结构体input_handler ，下层的设备驱动层的input_dev，但是他们是怎么连接起来的呢？通过connect函数，函数连接了这两个结构体，最后都整合到了input_handle这个结构体中，还是有些乱乱的，重新看一下，既然已经分析出来了这个input_handle，那为什么还要向后面分析呢？以这个问题为导向，开始重新看一下视频，这两个小节的手册是真的难写呀。

![image-20240204170638015](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402041706097.png)





# 2.3 工作记录

​	==不积跬步无以至千里，不积小流无以成江海==

昨天晚上的行为还是有问题，不知道换了几天手机了，就目前来看，手机这个东西还是有很大的问题，假如没有了手机，那我的实际行为是不是就有变化了呢？

​	今天做的第一件事情就是将手机换了回来，还是不喜欢安卓，安卓的话真的就是问题太大了，根本没有必要，真的经受不住诱惑的，你懂吗，这些东西真的不是你所能驾驭的，所以这个东西回家之后还是要在那个手机上来买，不然那个手机的作用就没了，等年后重新买三瓶酸枣仁膏，如果有用的话。

但是QQ这个东西还是会妨碍我，现在发现用两个电脑倒是好一点了。

____

早起才能决定早睡，所以以后仍旧是将豆浆放到屋子里来打，嗯，这就对了，也算是找到了一个缘由，至于会不会扰民，这不是扯淡吗，我不信。肯定不会的，那个盒子也打算利用起来，就放在鞋柜里吧，或者有没有在外面放的地方呀，晚上再好好的想一想。

____

firefly

![image-20240203101932535](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031019708.png)

香橙派：
![image-20240203102012807](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031020929.png)



![image-20240203103853677](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031038722.png)



![image-20240203110002957](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031100002.png)

____

行了，终于算是解决了这个PCIE的问题，这个问题真的困扰了我好久了，就挺不容易的，但所幸是解决了，就还好吧。今天下午的任务肯定是继续学习驱动的，放假之前一定是要写完对应的手册，但在此之仍旧是需要先总结一下，目前发现如果只是编译的话，挂载的编译速度跟平常的编译速度是没有很大的区别的，所以以后我就有多个地方来进行编译了，而且还是速度很快的那种，挂载网络硬盘的方式倒也是挺好的，现在是将QQ完全放到了远程上面，这样的话使用QQ就会有些障碍，而这些障碍呢，又会在你在进行真正的行动前阻碍你，现在你懂了吗，现在想把家里的也这样搞，首先是手机的问题，手机你想要的是拍照和虎牙，拍照肯定是可以，但是虎牙有问题，你买手机当时最大的一个原因，不就是为了拍照和录像吗，所以呀，完全没必要呀。这样，先把苹果手机设置为灰度，其实只要颜色到位了，那其他的东西其实也并没有那么吸引人了，所以回家之后先将手机设置为灰度值，其他的目前先不设置，看看这样的效果如何。

家里的电脑我再思考一些，家里电脑给我的诱惑绝大多数都是哔哩哔哩的诱惑，首先我是将哔哩哔哩的首页内容给全部屏蔽掉的，但是昨天在学习的时候发现youtube也会干扰到我，所以youtube也删掉，以后如果是要看哔哩哔哩的视频以后都通过笔记本电脑来看了，这些网络视频以后都通过笔记本的远程来搞定，仍旧是给自己创造障碍物，如果非常想做一件事情，不能立刻让自己很舒服的做，这样称之为，三思而后行。

在公司的时候我总共设置了十个手表闹钟，当然手表也只能设置这十个闹钟，每半个小时一个闹钟，相较于番茄钟更适合我，这样既能起到定时的作用，也可以收到消息，目前打算搞一个小屏幕，我发现两个27寸的屏幕，在家里是真的大呀，要不拿来给苏醒用用也不是不可以。现在来看的话，还是一大一小比较适合我，公司和家里同步是最好的。

看到了一个百度网盘链接到本地磁盘的方法，现在试一下：
[软件下载地址](https://github.com/alist-org/alist/releases/tag/v3.30.0)

下载之后解压到本地，利用cmd打开，输入./alist server

![image-20240203135912571](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031359635.png)

如下图所示：
![image-20240203135942610](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031359667.png)

这是密码Aq0nXPU3，然后打开浏览器输入127.0.0.1:5244,进入下面的界面如下所示：


![image-20240203140245360](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031402543.png)

账号为admin，密码是上面生成的Aq0nXPU3，登录之后如下所示：
![image-20240203140341453](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031403507.png)

然后添加硬盘，如下所示：
![image-20240203140531306](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031405377.png)

要到这里来刷新令牌。
https://alist.nn.ci/tool/baidu/callback.html?code=fe5418188acee140e04f2c36691af33d

这样设置：
![image-20240203140913823](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031409976.png)

然后这样raiDriver下载与配置

官网下载地址：[RaiDrive](https://link.zhihu.com/?target=https%3A//www.raidrive.com/)， 下载后，傻瓜式一直下一步就好啦。跟我一样配置就oK。

![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402031413590.webp)

自启动

~~~vbscript
Set ws = CreateObject("Wscript.Shell")

' 指定目录
directory = "D:\07_alist.exe"

' 切换到目录
ws.CurrentDirectory = directory

' 执行命令
ws.Run "alist.exe server", vbHide
~~~

行了，又搞了一个好玩的东西，心情不错。

_____

1什么是输入子系统?

2确定输入设备对应的设备节点

前两个小节都很简单，我确信现在的已经没问题了。

____



3输入子系统框架讲解

4输入子系统框架分析

在我看来这里真的很难写出来，在我的笔记里面只是写了一个框架图，以及三个层次的介绍

_____



5输入子系统数据结构介绍

6.输入子系统数据结构之间关系分析

这里我也是只写了一节，视频里为什么写成了两节，用文字的形式表现出来，还是感觉不对，这里我用poe的chatgpt来些我确实是写了好多，但是我自己看的都云里雾里，当然更不用说是客户了，你说是吗。

____



7.认识内核中输入子系统的源码和裁剪

这一小节直接过，本来也就没啥，但是他这里讲裁剪，心累呀

____



8.编写最简单的设备驱动层代码

几个函数，一个最简单的设备驱动层代码。

9.从最简单的设备驱动代码入手分析匹配规则

最简单的设备驱动层代码并不简单，透过现象看本质，一点点的剖析出来匹配的根本。

10.多对多的匹配关系分析

用joy.c来讲解一个通用的设备驱动层代码

11.完善设备驱动层代码

​	这里也不算是完善吧，之前的一些操作也仅仅是注册了一个输入设备，但是并没有进行任何的上报事件，按道理来看应该是用按键的，但是在rk上面的按键，为了节省IO口，所以就使用了ADC按键，只需要一个adc引脚，就可以控制多个按键，adc后面会讲，

12.通过应用程序获取上报数据



# 2.2 工作记录

每过一天都应该知道自己在昨天都做了些什么，又有哪些东西，今天可以吸取昨天的教训，即使不能做到立刻改正，下次遇到的时候也应该惊醒自己。昨天的万恶之源发生在想要热水之后，其实你明明是知道自己抵抗不住小说的诱惑的，但还是下载了下来，所以何必呢?而且现在也忘记了当时的心理活动，但是有一点可以确定，那就是对于我来说，有一些事情根本就不能露头，那些诱惑真的可以比作毒品，只要稍微一接触，就会深深的陷入进去，其实你自己才真的懂你自己呀，就像哔哩哔哩的那些。

中午的时候明明可以去做一些其他的事情的，但是你并没有，你难道就不知道这个是为什么吗？

不管了，先开始写手册了。关掉QQ，与世无争，果然还是关掉QQ最简单，什么都不用想，一个小时之后再见了。

____

____

所以呀，突然有了一些感悟，从心流那里学来的，当一件事情的难易程度与自身的技巧差不多的时候，更容易进入心流的状态，少了这些纷乱繁杂，心也确实能静下来了，所以进入心流的状态又多了一个，那就是心静。

以后看视频也不再倍速观看了，倍速观看视频真的会让人浮躁，当今的时代已经挺浮躁了，所以尽可能的远离、摒弃那些让你焦躁的行为。

# 2.1 工作记录

==无论你想成为一个怎样的人，千万要记住，时间在飞逝==

昨天晚上算是尝试的第一天晚上，感觉不错，今天继续，能真切的感受到些许的进步，加油。

# 1.31工作记录

==无论你想成为一个怎样的人，千万要记住，时间在飞逝==

==更重要的是，我们知道不能一直放纵下去，总有一天要停下来，面对放纵之前留下了的烂摊子==

昨天考虑了很久关于QQ的原因，最后也认定了qq真的影响我的工作效率，在非技术支持的工作日，可以使用手环的倒计时功能来限制我看QQ的频率，但是当技术支持的时间，就不能这样了，但这样也没有啥问题，就比如法师在录视频的时候，他当然也不会去回答问题，那我不回答问题当然也可以，因为我有其他的事情在某段时间内，他们的优先级是很高的，也就对应了手表的倒计时，三十分钟的倒计时可能太长了，那十分钟的倒计时还长吗？当然就不长了，法师一录课就是两个小时，难道这两个小时就没有客户吗，那当然是不可能，所以你也不必在心中对于不能非常及时的技术支持耿耿于怀，还是自以为是的责任感的原因，完全没必要呀。

甚至你感觉十分钟的时间也很长，但这是底线了，但仍旧可以交涉，可以定一个五分钟的倒计时，五分钟之后可以看QQ，但是不能回复客户的QQ，只可以回复同事们的QQ，等下一个五分钟之后才能回复客户的QQ，这样就很合理了。

____

然后来思考昨天晚上的所作所为，晚上的时间我本意上也是来学习的，所以现在来反思总结也是为了更好的工作，所以我也不必心里感到愧疚，工作是为了更好的工作，而更好的工作可以获得一个更强大的我。

所以现在来分析一下昨天晚上的整个过程，就跟工作时候的qq一样，找到问题所在，然后寻找探索问题所在的答案呗。

那你最终想要的结果是怎样的呢?是上完一天班之后回家娱乐，当娱乐累了的时候，开始睡觉休息，休息够了之后发现又到了上班的时间段了，那么你说下班娱乐的意义又是什么呢？是为了明天更好的工作，呵呵，不是吗？但其实这只是你探索出来的最终答案，就仍旧以昨天晚上的所作所为做为作为示例进行分析，假如今天不需要上班，或者你没有了工作，在困意来临的时候，你还会选择去睡觉吗，很大的可能是不去睡觉的，正如老岁月在视频中说的那句话，更重要的是，我们知道不能一直放纵下去，总有一天要停下来，面对放纵之前留下了的烂摊子。发现问题所在了吗，我们知道自己不能一直放纵下去，假若我们有机会、有权利一直放纵下去，我们当然愿意一直放纵，然后就是欢迎来到美丽新世界。 

当你没有认清楚这一点的时候，你就会在迷茫、痛苦、沉迷然后再痛苦，再沉迷，周而复始，那我究竟是要认识到什么呢？认识到我很差很差的自制力吗？那我的自制力又为何这么差呢？自制力差总归是要有原因的吧，其实经过了这么多年对自己的认识，你早就意识到这一点了，所以一般的诱惑在出现之后就能立刻分清楚，知道这就是我要面对的诱惑，就像中午下载的哔哩哔哩那样子，下载之后在认识到自己并不能真的克制之后立刻也就卸载了，但假如这是周日呢？假日这是在家里呢？你还能这么快吗？你还是不知道自己真正想要的是什么呀。虽然不知道最终的方向在哪个地方，但至少是知道自己有哪些行为是对的，哪些行为会让自己陷入长时间的沉迷之中，其实知道能让自己沉迷的事情之后也是另外一个方法。

早上来的时候，将手机进行了更换，所以苹果于我的意义有是什么呢，目前来看的话完全没有意义呀，不是吗，而另一个手机的意义在最开始的时候是想看看直播，然后呢，不过是一场虚无罢了，无论是看小说、刷短视频、亦或者看直播都是会上瘾的，而在之前因为离的太原，而没有累到极限而去睡觉，但现在有条件了呀，这些也都无所谓了，我可以睡到八点四十，这些都是可以的，毕竟，现在闹钟也无法叫醒我了呀，现在能叫我起床的只有要工作的闹钟了，顺其自然而已。今天晚上不应该再有小说，也不应该再有直播，其他的无所谓了，只要能正常的睡觉，其他的都无所谓，行了，该正常的工作了。

_____

____

昨天根据逻辑又向后面写了几个小节，相较于之前直接讲解vim，现在的无疑是更有逻辑性了，然后继续向下面写呗。

既然第九节已经学习了vim了，其实用vim查看是最好的，但是呢万一有在命令行查看的需求呢，所以使用命令对文件内容进行查看也是有必要学习的,那个tail和head滚一边去吧，这都啥玩意，这不是扯淡呢吗，

>10 文件内容查看和搜索
>
>​	10.1 文件内容查看：cat命令
>
>​	10.2 文件内容分页查看：less命令
>
>​	10.3 文件内容搜索：grep命令
>
>​	10.4 查找文件：find命令

文件的查找没问题了，我们能学习的也就这么多，接下来的权限相关的命令肯定是要讲解的，但能学习的也不多呀，只需要常用的讲解一下就好了，然后还有什么要讲解的呢？压缩和解压肯定是要讲解一下的，链接和软链接肯定也是要讲解一下的，链接和软连接要讲解的不多，所以放在下面

>11 用户和权限管理
>
>​	11.1 文件权限介绍
>
>​	11.2 root用户介绍
>
>​	11.3 获取root权限：sudo 命令
>
>​	11.4 权限修改：chmod命令



>12 Linux中的快捷方式：链接
>
>​	12.1 硬链接
>
>​	12.2 软链接	

这个放到了前面，感觉跟cp 放一起最合适，其他感觉就没啥命令了，剩下的就没啥了也就剩下了压缩和解压，

> 13 压缩和解压缩：tar命令
>
> ​	13.1 归档
>
> ​	13.2 压缩
>
> ​	13.3 解压缩

这次是真没了，软件包管理本来是不想讲的，但是还是要水一节视频。

>14 软件包管理：apt命令
>
>​	14.1 更新软件包列表
>
>​	14.2 更新软件包
>
>​	14.3 安装软件包
>
>​	14.4 卸载软件包（==除此之外还需要清理不需要的依赖关系和软件包缓存==）

目前来看要学习的命令就这么多了其他的也没啥了,就到这里吧,Linux基础到这里就也还行吧,但是现在要讲解的当然并不只是这些

> 15 Shell基础1：环境变量
>
> ​	15.1 查看环境变量：env命令
>







# 1.30工作记录（下）

==无论你想要成为一个怎样的人，千万要记住，时光在飞逝==

_____

还是那一个问题，你理想中的讲解效果是什么样子的呢？像狂神那样的吗，我想是的，但仍有一些细节我不是很清楚，所以我想要深入的了解一下狂神的讲课风格，在了解完了之后再去看一下黑马老师的讲课风格。

____

狂神与我之间的差别：
			我认为狂神的视频和直播是不一样的，它自带了加速，后来又看了一下狂神其他的视频发现它也并没有加速，所以就证明狂神是切实的自己讲出来的，	

____

黑马:

​	我发现这个老师的风格就跟我很想，我认为黑马的课程都很趋近于底层，只有黑马接近，黑马这个一看就很流畅，一看就是演练了很多遍了，而且有自己的风格，通过字幕的方式就很好。

____

行了，最终的风格确定了，就根据黑马老师的这个来，一个很重要的问题解决了，而里面的具体实施过程就待定了，总不能因为别人的风格就影响了自己的思路，你说对吗，现在可以安心的进行下一步了，解决了风格问题，依然已经有前行者做了一个很好的示范了，那还有什么可担心的，柴哥无所畏惧好吧。

____

行了，继续下一步了，录视频肯定要等法师的交流了，看看法师有没有什么其他的想法，目前认为我的想法和行为无懈可击好吧。所以后面的核心出来了，其他的就是填充就好了，当然一个一个的最终也是要符合逻辑的。目前整理到了tabby的安装和使用章节，也就是说关嵌入式Linux学习的环境搭建已经完成了。然后就是命令相关的了，但在此之前我认为要讲解的是Linux的目录结构。

> 7 目录结构

现在这个时候刚刚将学习Linux的环境搭建完成，但仍旧不能直接来讲解命令，而是先来讲解目录结构，但这时候还需要命令的辅助，三个命令和ls、cd、pwd，有了这三个命令就可以辅助讲解了目录结构了，我这三个命令的排列方式并不是随便拍的

> 7.1 文件和目录操作命令
>
> ​	7.1.1 命令的格式
>
> ​	7.1.2 列出文件和目录：ls命令
>
> ​	7.1.3 切换目录：cd命令
>
> ​	7.1.4 打印当前工作目录：pwd命令
>
> 7.2 Linux目录结构

虽然在上一节课讲解了列出文件和目录的ls命令和切换目录的cd命令，但是实际上文件和目录操作命令还有很多，大家可以根据windows关于文件和目录的操作想一下本节视频要讲解的命令。

> 8 文件和目录操作命令
>
> ​	8.1创建目录：mkdir 命令
>
> ​	8.2 创建文件：touch命令
>
> ​	8.3 删除目录和文件：rm 命令
>
> ​	8.4 复制文件和目录：cp命令
>
> ​	8.5 移动文件和目录：mv命令

这些基本的文件和目录操作命令就讲解完成了，但是当然不应止于此，创建文件之后应该怎样编辑文件呢，所以我认为这个第9小节应该是vim，因为后面是有文件内容的查看的，但是文件里面什么都没有，那查看个屁呀，这不是扯淡吗

>9 文本编辑器vim的使用
>
>​	9.1 vim的安装
>
>​	9.2 vim的三种工作模式
>
>​	9.3 光标的移动
>
>​	9.4 光标的移动（进阶版）
>
>​	9.5 vim文本插入
>
>​	9.6 vim的保存和退出
>
>​	9.7 vim文本删除
>
>​	9.8 vim的复制、粘贴和剪切
>
>​	9.9 撤销类命令
>
>​	9.10 搜索类命令
>
>​	9.11 替换类命令
>
>​	9.12 窗口分割

既然第九节已经学习了vim了，其实用vim查看是最好的，但是呢万一有在命令行查看的需求呢，所以使用命令对文件内容进行查看也是有必要学习的,那个tail和head滚一边去吧，这都啥玩意，这不是扯淡呢吗，

>10 文件内容查看和搜索
>
>​	10.1 文件内容查看：cat命令
>
>​	10.2 文件内容分页查看：less命令
>
>​	10.3 文件内容搜索：grep命令
>
>​	10.4 查找文件：find命令

文件的查找没问题了







































































# 1.30工作记录（上）

==无论你最后要成为一个怎样的人，千万要记住，时间在飞逝==

| 时间 | QQ打开次数 |
| ---- | ---------- |
| 上午 | 4          |
| 下午 |            |

昨天用这个表格，对于QQ的打开频率算是有了一些进步，在打开qq的时候会想一下，现在有没有到对应的时间，如果没有到对应的时间的话会提醒自己，有了一个准则之后就会有约束。但还是有些问题，还是忍不住的想回复，想看一下群里的消息，那应该怎样做呢，目前想的是在第二个屏幕上一直显示QQ，但是不能回复，只有等到时间到了才回复，那还有一个问题，对于这些消息是能看，还是只能看，能互相翻阅吗如果能翻阅，那是不是就回到了从前的那个样子了呢？发现还是不行，不如上面的这种次数记录。

这是必须要度过去的一个门槛，这个门槛度不过去那么工作的效率永远也提不上来，先来回顾一下我都做过了什么，最开始的时候是换了番茄钟，每30分钟一个轮回，但是后来发现还是管不住自己的想法，就算是戴着耳塞的时候都不行，不能控制住自己，时时刻刻那种精神上的蛊惑，让我一刻都不得安心，好像少有人走的路中有提到这个，但我忘记了解决这个问题的方法是什么了，这样的话，效率真的极其低下。

可你都在担忧什么呢？QQ带给你的真的可以说是没有任何的帮助，在想着万一苹果有事情找我咋办，在想着法师是不是有东西发给我，在想着是不是有客户私聊问我问题，在想着是不是有群聊里的问题需要我咋办？这些无不在牵动我的神经，怎样才能有一个好的解决办法呢？这些对我的影响真的太大了，就好比你在做数学题的时候突然被打断了，就导致你这一个数学题再也无法有刚刚的那种状态，你懂这种感觉吗，番茄钟这一解决方法已经放弃了，当我的心情被牵动的时候，那些根本就阻拦不住，所以我就换成了倒计时，换成倒计时之后也阻拦不住，这个快捷按键有影响，右下角的QQ图标也在牵动着我的心，所以我以后的模式都会是请勿打扰，只有倒计时结束之后才能看QQ，无论是谁，无论是谁他们都阻拦了我的进步，那我又为什么对于阻拦我进步的人所负责呢？当然技术支持的钱仍旧在牵动着我的心，以后每个月都有等额的钱，来花费，当然都是工作相关的，可以是买课、买书、买硬件、买装备等等，只要有利于学习的东西都可以买，每个月的钱都花出去吧，本来我打算的是不要技术支持的钱了，但想来想去发现好麻烦，只要我心里面过得去就可以了。这样想心里就舒服多了，我的心意也就通顺了很多，先尝试尝试。

昨天写完了五个小节的稿子，现在还差一个tabby的了，其实这些呀，都挺简单的，但是昨天晚上实际演练的时候就出现了问题，就是突然发现狂神的风格学不来呀，就是语气和语调是不对的，狂神的话就类似于日常讲话，但我这个就不太对了，这个问题很大，等写完tabby的找找问题，这就不止是讲解方式的原因了，有点难，找找问题，看看怎样解决一下。

如果法师找我的话，大部分的时间是直接通过口头的方式来找我，如果是果姐姐的话，我俩是面对面的，当然也会是通过面对面的方式来找我，苏姐姐更习惯于微信和我的大号，其他人的话也无所谓了，哦对，棒棒糖，以后让棒棒糖找我的微信吧，微信的消息我是乐意看的。

____

___

___

写完了tabby的稿子了，晚上回家之后再录一下试试，如果仍旧是按照之前录视频的那种方式，当然可以很快的录完，昨天晚上也测试了我的设备，目前还没发现过大的问题，现在有两个事情要完成，分别是后面内容的确定以及口述方式的确定。

_____

_________

果然呀，有些事情只要想明白了，知道真正的原因之后就好多了，因为我想要进步，所以我在寻找我自身的问题，在寻找问题的时候，我发现工作效率低下，而且在工作中很难进入到心流状态，于是我开始深挖这里面的原因，其中工作效率低下的原因是一直想看QQ，那为什么一直想看QQ呢，是精神的谴责，是内心的希冀，是责任感的鞭挞，责任感归根结底是那100块钱而来的，但其他的呢，你以为的交流，实际上是披着天使外衣的魔鬼，在一步一步的推你走向深渊，慢性毒药，当你认识到这一点的时候，才真正的算是觉醒了，而至于责任感而来的100块钱，我并不想要，但拒绝又很过于繁琐，像我这样怕麻烦的人，以后每个月的钱都用来学习，而且我发现桌子上的表也会控制我的心绪，所以我又将表给了果姐姐，家里的那个表扔在客厅吧，时间呀，或许真的是最害人的东西呀。

____

# 1.29工作记录

==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并整理成网络，分享出去，与更多志同道合的朋友一起进步。==

==无论你想要成为一个怎样的人，千万要记住，时间在飞逝==

| 时间 | QQ打开次数 |
| ---- | ---------- |
| 上午 | 8          |
| 下午 | 8          |

先来说一下热水器的问题，当然我感觉是里面的加热管亦或者是继电器的问题，但是呢仍旧是无可避免的需要售后的问题，出钱肯定是要出钱的，但如果今天不上班的话，那损失不就更大了吗，我说的对吗？所以当今最重要的就是上好今天这一天班，还好把。

___

目前联系的差不多了，感觉应该不会很贵，还好吧，中午这个人去的时候我看情况回一趟家吧，然后把钥匙给我弟，其他应该就没了。

____

然后呢，今天的任务有两个，主线任务是修心，支线任务是继续写后面的稿子。

修心，面临的问题其实有两个，一个是无法控制的看QQ，一个是无法控制的四处点点点。

QQ以后就在非技术支持的时间段，通过专注时间来解决，在专注的时间内，就做专门的事情，等时间到了，可	以有五分钟的时间来四处看。而无法控制的点点点，实际上也是心不静的表现，其实也要找原因，找到问题的根本，才是真正解决一个问题的方法，其实这两个问题都是一个，不知道自己真正想要的是什么，无论是持续的看qq、还是想要打开的那些新闻、热榜，都归为一类，现在呢开始记录自己的次数，上午10次，下午15次，这是一个限制，当然因为今天是第一天，所以单纯的记录一下想要打开的次数就好了，目前我认为，虽然今天并不是强制计算的次数，但是心里已经有了相应的天平了，有了一个初步的准则，这个准则会不由自主的督促你，好像真的很有作用，那这个是不是也可以运用到你的生活中呢？

上面这一切其实都是在静心的前提之下的，如果能一直静心就好了，但那真的可能吗，试一试呗。

___

大家好，这里是嵌入式Linux基础视频的第二节，在上个视频中，讲解了Linux的发展历史以及Linux所具有的优势，本节课的主要内容是对虚拟机进行介绍，这时候可能就有同学问了，我们不是要学习Linux吗，那这节课为什么要学习虚拟机呢？那是因为学习Linux需要先有一个Linux环境，而虚拟机的作用就是在windows下通过软件的方式创建一个Linux系统环境。下面对本节课要讲解的内容进行陈述，既然要使用虚拟机来创建Linux环境，那肯定需要先知道什么是虚拟机，然后了解为什么使用虚拟机，即使用虚拟机的优点.

## 2.1 什么是虚拟机？

虚拟机，从名字就可以看出它是一台虚拟出来的机器。与虚拟机对应的就是我们正在使用的物理计算机。一台物理机可以虚拟出来多台虚拟计算机，每台虚拟计算机都有自己的CPU、内存和操作系统，虚拟机所拥有的功能与物理计算机没有任何区别，具体可以看一下这张图，在物理计算机中通过虚拟机软件虚拟出多个虚拟机，每个虚拟机都有各自的操作系统和分配的虚拟硬件，关于虚拟机目前只需了解这些即可，然后来看为什么使用虚拟机？

![image-20240129132317444](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401291323524.png)

虚拟机：一台虚拟出来的机器（与之对应的为物理计算机）。

==一台物理机可以虚拟出来多台虚拟计算机，每台虚拟计算机都有自己的CPU、内存和操作系统。==

>2.1 什么是虚拟性？
>
>2.2 为什么使用虚拟机（虚拟机的优点）？

![image-20240129132627768](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401291326844.png)

## 2.2 为什么使用虚拟机？

wndows：简单易用，占据了桌面端绝大多数的市场（==绝大多数工作一定都是在windows操作系统上完成的==），最简单的方法是有两台物理计算机，一台装有windows操作系统、一台装有Linux操作系统，但这种方式从成本上就劝退了初学者和学生党，所以这种方式目前来看是不可取的。这时候可能就有人会提到双系统，也就是在一台物理计算机中装有两个不同的系统，在开机的时候通过BIOS进行系统之间的切换，但在实际使用中两个系统之间的切换是非常消耗时间的，其工作效率远远比不上windows系统+Linux虚拟机。综上，目前最合适的选择就是物理机安装windows操作系统，然后通过虚拟机软件在该系统上安装运行Linux操作系统的虚拟机，这里的Linux操作系统因为ui和易用性选择ubuntu操作系统。	

至此，关于使用虚拟机的优点就讲解完成了，最后对本节视频讲解的内容进行总结，在2.1小节讲解了什么是虚拟机？虚拟机就是通过虚拟机软件虚拟出来的机器，有着自己的CPU、内存和操作系统，在2.2小节首先讲解了windows的必要性，然后列举了三种在有windows操作系统的前提下使用Linux操作系统的方法，对比之下，唯有物理机安装windows操作系统，然后通过虚拟机软件在该系统上安装运行Linux操作系统的方法最适合我们。至此，本届视频就总结完成了，会在下个小节讲解虚拟机软件VMware workstation pro的下载和安装。

____

方法1（最简单的方法）：有两台物理计算机，一台装有windows操作系统、一台装有Linux操作系统。

![image-20240129135830588](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401291358632.png)

​	缺点：成本高，劝退学生党和初学者。

___

方法2:双系统，在一台物理计算机中装有两个不同的系统，在开机的时候通过BIOS进行系统之间的切换。

![image-20240129140744139](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401291407182.png)

​	缺点：但在实际使用中两个系统之间的切换是非常消耗时间的，其工作效率远远比不上windows系统+Linux虚拟机。

___

方法3:物理机安装windows操作系统，通过虚拟机软件安装运行Linux操作系统的虚拟机（因为ui和易用性这里选择ubuntu操作系统）

![image-20240129141357264](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401291413317.png)

____

____

____

____

____

大家好，这里是嵌入式Linux基础教程的第三节，在上一个视频中讲解了什么是虚拟机、以及为什么要使用虚拟机，而本小节要演示的是虚拟机软件vmware workstation pro的下载和安装。这里已经展示了详细的安装步骤，这里的笔记肯定都会发给大家，跟着笔记来就可以了，首先点击进入Vmware Workstation pro下载地址，进入Vmware Workstation官方网站之后，在该网页的最下方可以找到Vmware Workstation pro17的下载，对于虚拟机软件的版本来说，建议是越新越好，一般情况下虚拟机软件的版本都会向下兼容，等待安装包下载完成。

安装包下载完成之后，双击该安装包，进入安装界面，然后点击下一步。

然后勾选接受条款，继续点击下一步。

然后更改软件的安装路径，这里建议放到C盘意外的地方，修改完成之后，点击进行下一步。

接下来的产品更新和客户体验计划这里就保持默认即可，然后点击下一步。

创建桌面快捷方式和开始菜单程序文件夹也保持默认勾选，然后点击下一步。

最后点击安装，等待安装完成即可。

安装完成之后，如果有许可证可以输入许可证，没有许可证点击完成即可。没有许可证只能有30天的试用期，如果想要进行后续的使用，大家自行后续操作就行，懂得都懂。到这里vmware workstation pro 虚拟机软件的安装就完成了。会在下一小节通过刚刚安装的vmware workstation pro 虚拟机软件安装ubuntu操作系统。

____

____

____

____

____

大家好，这里是嵌入式Linux基础教程的第四节，在上一节视频演示了虚拟机软件vmware workstation pro的下载和安装，本节视频将会演示ubuntu操作系统的获取和安装。这里已经展示了详细的安装步骤，这里的笔记肯定都会发给大家，跟着笔记来就可以了。首先点击进入ubuntu下载地址，然后点击右下角的“下载22.04.3”即可进行下载，但ubuntu官网的镜像下载可能会比较慢，所以在一般情况下都是通过国内的一些镜像网站进行下载，就比如[ 清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/)或者[中科大的开源软件镜像站](https://mirrors.ustc.edu.cn/ubuntu-releases/)，这里就以清华大学开源镜像站为例进行下载演示,	从这里可以看到，最新的ubuntu版本为23.10.1，但23版本并非长期支持版本，所以我们仍旧选择22.04.03版本，点击进入之后可以看到有desktop桌面版和server服务器版两个版本供我们选择，考虑到大家都是刚接触Linux，需要图形化界面来进行简单的过度，所以这里选择desktop桌面版进行下载。

ubuntu系统的iso镜像下载完成之后，接下来使用Vmware workstation虚拟机软件来安装ubuntu。

首先打开vmware workstation pro软件，然后点击“创建新的虚拟机”

点击之后会进入新建虚拟机向导，这里有两个选项，一个是典型、一个是自定义，自定义里面的一些选项会更细致，所以我们这里选择自定义，然后点击下一步

点击之后需要选择硬件兼容性，这里保持默认最新的即可，然后点击下一步

点击之后会进入操作系统映像文件的选择，这里的映像文件就是刚刚下载完成的ubuntu iso文件，然后点击下一步

点击之后会进入安装信息设置界面，需要设置Linux系统的用户名和密码，后面在系统安装的过程中还需要再进行设置一次，设置完成之后点击下一步

点击之后会进入虚拟机名称和位置设置界面，修改完成之后，继续点击下一步

点击之后会进入处理器配置界面，这里的处理器数量和内核数量需要根据个人电脑CPU的型号来进行设置，这里填写的越高，虚拟机相应的性能也越高，当然这里的数量不能超过你实际物理机的逻辑处理器数量，可以通过任务管理器来查看自己电脑的逻辑处理器数量，设置完成之后点击下一步

接下来进行虚拟机内存的配置，这里的内存配置不建议超过物理机内存的百分之八十，否则会有明显的卡顿，设置完成之后点击下一步

点击之后会进入网络类型配置界面，这里有四种模式供我们选择，分别为桥接模式、NAT模式、仅主机模式和无网络模式，作为入门学习用户，目前我们肯定是需要虚拟机正常上网的，所以只能选择第一个桥接模式或者第二个NAT模式，两种模式的区别在于桥接模式下虚拟机会跟物理主机所在的局域网处于同一网段下，可以ping通局域网内的其他主机，而nat模式相当于将主机和虚拟机又接到了一个新的路由器上，使用一个新的网段，这时候虚拟机不能同局域网内的其他主机进行通信，当然无论是桥接模式还是nat模式都可以正常上网，目前大家只需要保证虚拟机正常上网即可，两种模式可以自由选择，我这里就选择桥接模式了，然后点击下一步

接下来的IO控制器类型和磁盘类型保持默认即可，磁盘选择这里选择第一个创建新虚拟机磁盘，然后点击下一步

点击之后会进入磁盘容量设置界面，如果仅仅是为了学习Linux基础，默认的30G的空间也就够了，但是如果想要进行后续的开发，就比如源码的编译，就需要更大的空间，看个人计算机的空间大小来分配容量即可，然后为了提高读写性能，下面选择存储为单个文件，然后点击下一步

接下来的磁盘文件名保持默认即可，然后点击下一步

至此，关于虚拟机的配置就完成了，最后点击完成即可

然后就会进入系统安装界面，首先是键盘布局的选择，这里保持默认的英文键盘布局即可，然后点击continue继续

接下来是软件的安装，我们并不需要办公软件、游戏、游戏、播放器等一系列软件，所以这里选择第二个精简系统安装，只安装web服务器和一些基础工具即可，然后点击continue继续

点击之后会进入，安装类型选择界面，保持默认的第一个选项即可，由于是虚拟机安装，所以这里并不会对实际的物理磁盘进行清空，点击 install now进行安装即可

安装过程会选择地区，这里选择上海即可，然后点击 continue继续

然后设置用户名称、电脑名称以及密码相关的内容，大家根据喜好自行设置即可，然后设置为自动登录，自动登录可以省去每次开机输入密码的步骤，然后点击continue继续安装

安装完成之后，会出现重启计算机的弹窗，重新启动系统之后，ubuntu就安装完成了。

至此，ubuntu系统的获取和安装就演示完成了，但这个时候的ubuntu系统语言为英文，相对于初学者并不是很友好，所以会在下个小节将ubuntu的系统语言从英文修改为中文。

____

____

____

____

____

大家好，这里是嵌入式Linux基础教程的第五节，在上一节视频中演示了ubuntu的获取和安装，但由于安装完成的Ubuntu系统的默认语言为英文，对于我们这些初学者并不是很有友好，所以本节视频将会给大家演示如果修改系统默认语言为中文。这里已经展示了详细的安装步骤，这里的笔记肯定都会发给大家，跟着笔记来就可以了。

首先点击右上角的开关机按钮，找到setting设置，点击就会进入设置界面

然后找到地区和语言，可以看到目前的语言为英文

然后点击管理安装的语言

首先需要安装一些语言支持包，这里直接点击安装即可

然后将汉语从最后一位拖动到第一位，点击应用到整个系统

接下来重启虚拟机，虚拟机重新启动之后之后就会发现整个系统已经变成了中文了，系统在启动之后会弹出”是否保留旧名称“的弹窗，这里大家根据个人喜好设置即可，我这里选择保留旧的名称。到这里，ubuntu虚拟机就从默认的英文环境修改为了中文环境，虽然ubuntu的图形化界面对于新手十分友好，但是在实际的工作中，很少会用到图形化界面，绝大多数情况下都是通过终端来完成一系列的操作，所以一个终端软件的选择和安装也是一个必须的过程，所以会在下个视频中讲解终端软件tabby的安装和使用。

____

___

____

___

大家好，这里是嵌入式Linux基础教程的第6节，在上个小节中将虚拟机ubuntu从默认的英文环境修改为了中文环境，而本节视频将会讲解tabby终端软件的安装和使用。这时候可能就会有人询问了，我们为什么要使用终端软件呢？在Linux中使用命令交互的效率实际上是远远大于图形化界面的，除此之外，在实际的工作中，无论是开发板的调试还是使用公司服务器，都不会直接使用图形化界面，绝大多数情况都是使用终端软件通过SSH或者串口进行连接，所以本小节将会给大家推荐一个好用的终端软件tabby。本节视频将会分为3个部分，首先会讲解tabby的安装，r然后会在第二小节演示使用tabby通过ssh远程连接ubuntu，最后演示tabby的字体调节。

>3.1 tabby的获取和安装
>
>3.2 通过ssh远程连接ubuntu
>
>3.3 tabby字体调节

## 3.1 tabby的获取和安装

首先来对tabby进行一下简单的介绍， Tabby是一个无限可定制的跨平台终端应用程序，适用于本地的 shell终端、串口终端、SSH终端的连接，我个人更喜欢tabby终端的窗口分割以及字体设置，相较于其他终端软件看起来更舒服。

在文档中已经展示了详细的 tabby安装步骤，这里的笔记肯定都会发给大家，跟着笔记来一步一步进行即可。

首先进入tabby软件的下载地址

## 3.2 通过ssh远程连接ubuntu

## 3.3 tabby字体调节



# 1.27工作记录

==无论你决定成为一个怎样的人，千万要记住，时间在飞逝==

目前第0节的内容已经写完了，其实后面的都很简单，我都感觉我可以明天就录完课程，哈哈，待定了，今天能写完后面的六节吗，反正今天不能，周一应该也可以。

突然发现，就算是写好了文档，跟讲解出来的效果也是不尽相同的，上面的只不过是黄粱一梦罢了，所以现在就该将文档与讲解的内容分隔开来，之前有过这样一个想法，那就是在讲解的过程中复现文档，但目前看来这是不可能的，就连狂神也并不是完全复现出来，不知道狂神是先写的文档还是先录的课程，我想应该是先出的文档，而后才有的教程，我是不相信有人真的这样牛，不可能什么都不备就能讲解出来的，如果换成我的话，我甚至都会斟酌每一个字，表情，语义等等，所以狂神也是先有的文档，然后根据文档的内容即兴开始的课程，我是一个初步入门的小白，我知道我并不厉害，可能也并没有人家勤奋，但是也正因为我是一张白纸，所以也就有了更多的可塑性。回归正题，既然不可能完全复现了，但课堂上的笔记必然也会是包含了绝大多数的内容，尽力即可。

___

大家好，这里是Linux基础教程的第一节课-初识Linux，本节课可以分为三个部分，1.unix的诞生，2.GNU和Linux的发展，3.Linux的优势，相信很多人都有疑问，我们不是要讲Linux操作系统吗，这里为什么又出现了unix？可以这样说，如果没有UNIX，那Linux也就不会出现了，Linux的创作者林纳斯·托瓦兹（Linus Torvalds）正是借鉴了UNIX的设计原则和功能（并不是直接使用UNIX的源代码）设计开发出了Linux,所以本节视频会先简单讲解unix的发展历史，而GNU是一个开源项目，旨在创建一个自由、开源的类Unix操作系统，但在操作系统内核这一方面还有缺陷，正是Linux内核的加入，才真正形成了一个完整的操作系统，最后会讲解Linux操作系统的优势，而这也正是我们学习Linxu操作系统最主要的原因。

>1.unix的诞生(如果没有UNIX，那Linux也不会出现,林纳斯.托马斯正是借鉴了Unix的设计原则和功能设计开发出来的Linux)
>
>2.GNU和Linux的发展（GNU是一个开源项目，旨在创建一个自由、开源的类Unix操作系统。正是Linux内核的加入，才真正形成了一个完整的操作系统）
>
>3.Linux的优势（学习Linux操作系统最主要的原因）

## 1.1 unix的诞生

现在来看第一个内容unix的诞生，在上个世纪60年代 ，美国贝尔实验室的工程师开始开发一个多用户、多任务的操作系统，然而由于该项目过于复杂，导致进展十分缓慢，贝尔实验室就退出了该项目。项目退出之后，贝尔实验室的肯.汤姆森和丹尼斯.里奇决定重新设计一个更简单、更实用的操作系统，于是在1969年，第一版的UNIX就诞生了。而在20世纪70年代，由于半导体和集成电路技术的普及，大大拉低了内存制造成本，于是C语言等高级语言的应用成为了可能，丹尼斯·里奇又着手B语言的改进，就这样我们现在熟知的C语言就诞生了，于是在此基础上肯·汤姆森和丹尼斯·里奇又对unix不断更新迭代，最终于1975年发布了Unix第6版本，第6版本的unix内核由9000行的C语言和700行的汇编语言所实现，让Unix系统的维护和修改变的容易。

___

时间：上个世纪60年代 

地点：美国贝尔实验室

目的：开发一个多用户多任务的操作系统

结果：由于该项目过于复杂，进展十分缓慢，贝尔实验室就退出了该项目。

___

人物：肯.汤姆森和丹尼斯.里奇

<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401271507216.png" alt="image-20240127150722157" style="zoom:200%;" />

目的：重新设计一个更简单、更实用的操作系统

结果：在1969年成功开发出了第一版的UNIX操作系统。

后续发展：而在20世纪70年代，由于半导体和集成电路技术的普及，大大拉低了内存制造成本，于是C语言等高级语言的应用成为了可能，丹尼斯·里奇又着手B语言的改进，就这样我们现在熟知的C语言就诞生了，于是在此基础上肯·汤姆森和丹尼斯·里奇又对unix不断更新迭代，最终于1975年发布了Unix第6版本，第6版本的unix内核由9000行的C语言和700行的汇编语言所实现，让Unix系统的维护和修改变的容易。

## 1.2 GNU和Linux的发展

然后来到第二小节GNU和Linux的发展。在20世纪70年代,末贝尔实验室的总公司AT&T对UNIX操作系统的源代码的使用做出了限制，禁止将其供给学生群体使用，并收回了UNIX的版权，并不再开源，由于这一限制，广大用户和学校面临着没有操作系统可用的困境。

这时候一个名叫理查德·斯托曼的大佬站了出来，他对当时UNIX操作系统的私有化和限制使用感到担忧，于是决定创建一个完全由免费软件组成的类Unix计算机操作系统，这就是GNU项目。GNU项目始于1983年，GNU它是一个递归写法，意味着"GNU's Not UNIX"（GNU不是UNIX），强调了GNU操作系统与UNIX的区别。GNU项目的核心是开发一系列自由软件工具，例如GNU编译器也就是我们后面会用到的GCC、GNU调试器GDB、命令行解释器GNU bash等。然而，GNU项目的发展遇到了一个重要的挑战，它缺少操作系统内核这一核心组件。

然后来看Linux的诞生，在1991年一个名叫林纳斯·托瓦兹（Linus Torvalds）的芬兰大学生发布了一个名为Linux的操作系统内核，Linux内核采用了类似UNIX的设计理念，具有高度的可移植性和可扩展性。最终，Linux内核与GNU项目相结合，为用户提供了一个完整而自由的操作系统，也就是我们所熟知的GNU/Linux操作系统。

Linux可以分为内核版本和发行版本，内核是操作系统的核心，负责管理硬件资源，并提供进程管理、内存管理等操作系统的核心功能。而发行版本是基于GNU/Linux构建的完整操作系统，包含了内核、源代码及相关应用程序。常见的发行版本有Ubuntu、Red Hat、Debian等。而由于Ubuntu的图形化界面相对于初学者更加友好，所以本套课程选用Ubuntu进行Linux的学习。

最后再简单陈述一下Linux的发展，在早期的时候Linux只适用于386处理器，后来经过全世界的网友的帮助，使得Linux最终能够兼容多种架构，包括x86、ARM、PowerPC等，据统计，Linux服务器占据着整个服务器市场的高达85% – 90%的份额，而数以十亿计个人手机所运行的安卓系统使用的也是Linux内核。

GNU/Linux操作系统的成功得益于GNU项目和Linux内核的共同努力。随着时间的推移，GNU/Linux操作系统逐渐发展壮大，并在不同领域得到广泛应用，包括个人计算机、服务器、移动设备以及嵌入式系统等。它成为了开源软件运动的重要代表之一，也促进了自由软件和开放源代码的发展。

____

时间：20世纪70年代末

事情的起因：贝尔实验室的总公司AT&T对UNIX操作系统的源代码的使用做出了限制，禁止将其供给学生使用，并不在开源。

人物：理查德.斯托曼（==对当时UNIX操作系统的私有化和限制使用感到担忧==）

动作：决定创建一个完全由免费软件按组成的类Unix计算机操作系统，

名称：GNU项目（GNU意味着"GNU's not Unix"，强调了GNU和Unix的区别）

核心：开发一系列自由软件工具，如GNU编译器（GCC）、GNU调试器（GDB）、命令行解释器GNU bash等。

挑战：缺少操作系统内核这一核心组件。

___

时间：1991年

人物：林纳斯.拖瓦兹

事件：发布了一个名为Linux的操作系统内核（采用了Unix的设计理念，具有高度的可移植性和可扩展性）

最终结果：Linux内核与GNU项目相结合，为用户提供了一个完整而自由的操作系统（**GNU/Linux操作系统**）。

___

==Linux可以分为内核版本和发行版本。==

- 内核版本：是操作系统的核心、负责管理硬件资源并提供进程管理、内存管理等操作系统的核心功能。
- 发行版本：是基于GNU/Linx构建的完整操作系统，包含了内核、源代码以及相关应用程序，常见的发行版本有**Ubuntu**、red hat、debian等。

![image-20240127161852653](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401271618745.png)

由于Ubuntu的图形化界面相对于初学者更加友好，所以本套课程选用ubuntu进行Linux的学习。

____

==Linux的发展==

早期：Linux只适用于386处理器

发展：后来经过全世界的网友的帮助，使得Linux最终能够兼容多种架构，包括x86、ARM、PowerPC等。

结果：Linux服务器占据了如今整个服务器市场的高达85% – 90%的份额，而数以十亿计个人手机所运行的安卓系统使用的也是Linux内核。

## 1.3 Linux的优势

最后对Linux操作系统所具有的优势进行陈述，正是因为LInux具有其他系统所没有的优点，所以我们才能聚在这里学习Linxu基础。

Linux最重要的优点为开源免费，即用户可以免费获取和使用Linux而无需支付额外的费用。第二点为稳定性和可靠性，由于Linux的开源特性，Linux得到了广泛的测试、审查和改进，可以长时间运行而且不容易崩溃或故障，并且具有极高的安全性。第三点为硬件兼容性，Linux系统可以运行在多种硬件平台上，第四点为高度可定制性，用户可以根据自己的需求和偏好进行自定义配置，这使得服务器或者嵌入式设备通过定制Linux系统从而运行在各种不同的应用场景，最后一点是Linux具有很好应用生态系统，Linux开源社区提供了各种开源软件和工具，用户可以充分利用已有的软件资源，无需从头开发，除此之外Linux社区还提供了广泛的资料和支持文档，可以帮助用户轻松解决问题。

1. 免费开源：用户可以免费获取和使用Linux而无需支付额外的费用。

2. 稳定性、可靠性和安全性：由于Linux的开源特性，Linux得到了广泛的测试、审查和改进，可以长时间运行而且不容易崩溃或故障，并且具有极高的安全性。

3. 硬件兼容性：Linux系统可以运行在多种硬件平台上。

4. 高度可定制性：用户可以根据自己的需求和偏好进行自定义配置，这使得服务器或者嵌入式设备通过定制Linux系统从而运行在各种不同的应用场景。

5. 应用生态系统：Linux开源社区提供了各种开源软件和工具，用户可以充分利用已有的软件资源，无需从头开发，除此之外Linux社区还提供了广泛的资料和支持文档，可以帮助用户轻松解决问题。

____

到这里，嵌入式Linux基础教程中的第一节内容就讲解完成了，现在对讲解的内容进行回顾，在1.1小节中讲解了unix的诞生，贝尔实验室的肯·汤姆森和丹尼斯·里奇在1969年开发出了一种名为unix的操作系统，而我们要学习的Linux正是借鉴了Unix的设计原则和功能设计开发出来的，然后来看1.2小节GNU和Linux的发展，Unix不再开源之后理查德·斯托曼发起了一个名为GNU的项目，该项目的核心是开发一系列自由软件工具，但是因为缺少操作系统内核，所以GNU的发展遇到了障碍，在1991年林纳斯·托瓦兹发布了一个名为Linux的操作系统内核，该内核采用了类似Unix的设计理念，具有高度的可移植性和可扩展性，所以GNU项目和Linux内核相结合，形成了一个完整而自由的GNU/Linux操作系统，得益于开源的优势，Linux在全世界网友的帮助下，最终兼容了多种架构，现如今绝大多数的服务器、嵌入式设备以及手机的安卓系统所使用的都是Linux内核，最后是1.3小节 Linux的优势，Linux可以将优点总结为五个方面，分别是开源免费，与其他系统相比具有更好的稳定性、可靠性和安全性，具有硬件兼容性，可以运行在多种架构的硬件平台上，具有高度的可定制性，用户可以根据需求进行系统的自定义，从而适用于不同的应用场景，最后是Linux具有良好的应用生态，可以充分利用现有的软件资源和帮助文档，更好的进行后续的开发。

至此，第一节视频的总结就完成了，会在下个小节对虚拟机进行介绍，我们下个视频见。

# 1.26工作记录

==我希望用一生的时间不断学习和深入电子计算机行业的一切知识，并将其整理为网络，分享出去，与更多志同道合的朋友一起进步。==

==无论你最后想要成为一个怎样的人，千万要记住，时间再飞逝。==

昨天晚上和今天早上进行了反思，也算是找到了我焦虑的源头，那从今天开始，就重新回到Linux基础的任务上来，也不要求你继续向后写对应的内容，只是开始写前面的稿子，从行为上进行演练。只有开始之后才能真正的解决我当前的焦虑。那开始吧。

在工作之余，也要适当的总结，怎样才能在技术支持的时候有最好的耐心，并且不会耽误正常的工作，目前

___

第一节视频，肯定是总领，学习大纲之类的东西，但是由于我目前也没有一个完整的章程或者一个我想象中一个较为优秀的框架，所以我本来打算是先跳过这一节的，但是刚刚又转念一想，可以直接从总领开始的，因为虽然没有一个整体的框架，但至少一大半的框架是有的，所以直接从最开始的来就行了，能写到哪里就写道哪里,而写不出来的，就是后面要填充的内容。

先来陈述第一个视频的大体概述，第一个问题，是只介绍linux基础要讲解的内容呢，还是要将后面的系统编程、QT、camke、makefile等内容都大致的提一下呢？目前的想法是不提，因为你自己也不确定，到底能不能讲到后面，不是吗，所以在这一小节只需要介绍本期视频讲解的内容即可。

___

大家好，欢迎来到北京迅为电子推出的全新嵌入式Linux基础教程！在2020年，我们发布了嵌入式学习Linux入门篇，而如今四年过去了，嵌入式Linux相关的知识也日新月异，过去的内容可能已经不再适应当前的需求和趋势，所以迅为决定推陈出新，录制一个全新的、更容易让初学者所接受的Linux基础教程。

![image-20240126105205038](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401261052117.png)

本节视频是嵌入式Linux基础教程的第0节，属于整期视频的总领部分，在本节视频中会对整期视频的内容进行简单的概括，在学习之前先有一个初步的认识，从而更有利于后面的学习。

第一节可以总结为“初识Linux”。既然我们要学习Linxu，首先肯定要了解Linux是什么，Linux又有哪些优点，这里的优点又可以换个描述方式，也就是我们为什么要学习Linux，我们不正是因为Linux有着其他系统所不具备的优势才来学习Linxu的吗。

在初步认识Linux之后，我们第二节的内容为虚拟机的介绍，这时候可能就有同学问了，我们不是已经知道什么是Linux了吗，下一步不应该进行Linux的学习吗，别急，要学习Linux我们需要先有一个Linux环境，那Linux环境是怎样搭建的呢，这就要用到上面提到的虚拟机了，所以在第二小节会讲解虚拟机是什么，以及我们为什么要使用虚拟机来搭建Linux环境？

在了解了什么是虚拟机之后，后面当然是使用虚拟机来搭建Linux环境了，所以第三节的内容为虚拟机软件vmware workstation pro的下载和安装，紧跟着的第四节为获取并安装ubuntu操作系统，这里简单提一下ubuntu系统是Linux的常用发行版之一，有着极为友好的图形用户界面，适合早期的入门学习。

ubuntu系统安装完成之后，默认的系统语言为英文，对于初学者来说并不友好，所以第五节内容为修改ubuntu系统语言为中文。

到这里用于学习的ubuntu环境就搭建完成了，而在实际的工作中，很少会用到图形化界面，绝大多数情况下都是通过终端来完成一系列的操作，所以在第六节会给大家推荐一款名为tabby的终端软件，讲解tabby的安装和使用，tabby是我目前感觉ui、字体以及功能最优秀的一个终端软件，所以极力推荐给大家。

接下来就真正的进入到Linux学习阶段了，==后面的内容还在规划，等一等==

___



# 1.25 工作记录

==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理为网络，分享出去，与更多志同道合的朋友一起进步。==

==无论你最后想要成为一个怎样的人，千万要记住，时间在飞逝。==

____

对于读书就先到这里了，很多思想都不是突然就明白的，而是一个循序渐进的过程，现在要做的就是对书中的内容进行整理、总结、反思和实践，最先要确定的是属于自己的、立在心中的一个目标。当然仅仅只有一个目标是不够的，你仍是要忍受外界的诱惑，脱离了外部的实际只有空想，那当时是不可能成的，所以我看到了娱乐至死，当娱乐和网络连结成了一个不可分割的事务，那整个时代又会是怎样的腐朽不堪呢，而我们个人又永远不可能脱离时代，独自活着，所以我应用屏蔽插件，尽可能的屏蔽一切有关娱乐的东西，就像这样。

![image-20240125094550591](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401250945787.png)

只有搜索，然后对于一些需要的网页，直接上对应的链接和图标，而哔哩哔哩的主页，乱花渐欲迷人眼，只要进入就会混乱，出现很多问题，除此之外，还屏蔽了搜索的历史，右边的推送，上面的传送门等等，都是用来克制娱乐化的一系列手段，如下所示：
![image-20240125095250754](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401250952960.png)

当你获取到的内容毫无用处，你还会想继续吗，接下来的是美丽新世界，所以当你真正直面自己欲望之后，你会发现那些可耻的快感并不值得你蹉跎一生。

___

行了，然后回到工作中来，上面都是关于最近的一些认识，然后继续昨天的学习，昨天开始分析input框架的由来，但是有一些C语言的基础我还并不是很懂，所以先去学习对应的C语言知识。

___

~~~ c
static struct input_handler evdev_handler = {
	.event		= evdev_event,
	.events		= evdev_events,
	.connect	= evdev_connect,
	.disconnect	= evdev_disconnect,
	.legacy_minors	= true,
	.minor		= EVDEV_MINOR_BASE,
	.name		= "evdev",
	.id_table	= evdev_ids,
};

static int __init evdev_init(void)
{
	return input_register_handler(&evdev_handler);
}
~~~

问题1： struct input_handler evdev_handler 这个结构体定义我就不是很懂，按照我昨天晚上学习的情况来看struct后面是跟的类型，就比如这个样子：
~~~c
struct Person {
    char name[50];
    int age;
};
~~~

这个我懂呀Person包含name和age两个，那struct input_handler evdev_handler是啥呢？我可能知道了，我靠，这个地方我可能懂了，这个地方并不是结构体的定义，而是他喵的结构体的使用,而input_handler是已经在其他地方定义，然后在input.h中找到了他的定义，如下所示：

~~~c
struct input_handler {

	void *private;

	void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
	void (*events)(struct input_handle *handle,
		       const struct input_value *vals, unsigned int count);
	bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
	bool (*match)(struct input_handler *handler, struct input_dev *dev);
	int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
	void (*disconnect)(struct input_handle *handle);
	void (*start)(struct input_handle *handle);

	bool legacy_minors;
	int minor;
	const char *name;

	const struct input_device_id *id_table;

	struct list_head	h_list;
	struct list_head	node;
};
~~~

程序示例2：
~~~c
#include <stdio.h>
#include <string.h>

struct Person {
    char name[50];
    int age;
};

int main() {
    struct Person p = {
        .name = "John",
        .age = 25
    };

    printf("Person's name: %s\n", p.name);
    printf("Person's age: %d\n", p.age);

    return 0;
}
~~~

![image-20240125102630642](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401251026696.png)

这种方式是使用结构体初始化器，并通过成员名字来指定赋值。具体来说，这个语法使用了结构体成员的初始化器（Member Designator）来指定每个成员的赋值。

在这个例子中，结构体 `Person` 的变量 `p` 被初始化为一个新的 `Person` 对象。通过使用成员初始化器，可以直接指定每个成员的赋值。在花括号 `{}` 内，通过成员名字和赋值表达式来指定每个成员的初始值。

所以，这段代码的含义是创建一个名为 `p` 的 `Person` 结构体对象，其中成员 `name` 被赋值为 `"John"`，成员 `age` 被赋值为 `25`。这种方式可以更明确地指定每个成员的值，而不依赖于成员的定义顺序。

除此之外还有其他平常的赋值方法，具体如下所示：

1. 逐个赋值：可以使用点运算符 `.` 来逐个赋值结构体的成员。例如：

   ```c
   struct Person p;
   strcpy(p.name, "John");
   p.age = 25;
   ```

   这种方式需要逐个对每个成员进行赋值。

2. 使用结构体初始化器：可以在定义结构体变量时使用结构体初始化器来初始化成员。例如：

   ```c
   struct Person p = {"John", 25};
   ```

   这种方式在定义结构体变量的同时给成员赋值，按照定义结构体时的成员顺序进行初始化。

3. 通过指针访问成员进行赋值：可以使用指针来访问结构体的成员，并进行赋值。例如：

   ```c
   struct Person p;
   struct Person *ptr = &p;
   strcpy(ptr->name, "John");
   ptr->age = 25;
   ```

   这种方式通过指针 `ptr` 访问结构体 `p` 的成员，并进行赋值。

行了现在稍微懂了。

## 函数指针

函数指针是一种特殊的指针类型，在C语言中用于存储和调用函数的地址。函数指针允许程序在运行时动态地选择要调用的函数，从而增加了程序的灵活性和可扩展性。

在C语言中，函数本质上是一段代码，可以通过函数名来调用。而函数指针则允许我们将函数的地址存储在一个指针变量中，以便在需要时进行调用。

函数指针的声明包括以下几个要素：

1. 返回类型：指定了函数指针所指向函数的返回值的类型。
2. 指针名：用于标识函数指针变量的名称。
3. 参数列表：指定了函数指针所指向函数的参数类型和顺序。

一般函数指针的声明形式为：`return_type (*pointer_name)(parameter_list)`。

下面我们将通过一个示例来详细解释函数指针的用法。

```c
#include <stdio.h>

// 声明一个函数指针类型
typedef int (*Operation)(int, int);

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int subtract(int a, int b) {
    return a - b;
}

// 乘法函数
int multiply(int a, int b) {
    return a * b;
}

// 除法函数
int divide(int a, int b) {
    return a / b;
}

int main() {
    // 声明一个函数指针变量
    Operation operation;

    // 将函数指针指向加法函数
    operation = add;

    // 使用函数指针调用加法函数
    int result = operation(5, 3);
    printf("Addition result: %d\n", result);

    // 将函数指针指向乘法函数
    operation = multiply;

    // 使用函数指针调用乘法函数
    result = operation(5, 3);
    printf("Multiplication result: %d\n", result);

    return 0;
}
```

在这个示例中，我们首先定义了四个函数：`add`、`subtract`、`multiply` 和 `divide`，它们分别执行加法、减法、乘法和除法操作。

然后，我们声明了一个函数指针类型 `Operation`，它指向一个返回类型为 `int`，参数列表为两个 `int` 类型的函数。

接下来，在 `main` 函数中，我们声明了一个 `Operation` 类型的函数指针变量 `operation`。

我们将 `operation` 指针赋值为 `add` 函数的地址，即 `operation = add;`。此时，`operation` 指向了 `add` 函数。

然后，我们使用函数指针调用 `add` 函数，即 `int result = operation(5, 3);`。这实际上会调用 `add` 函数并返回结果，将结果存储在 `result` 变量中。

同样的步骤，我们将 `operation` 指针赋值为 `multiply` 函数的地址，并使用函数指针调用 `multiply` 函数。

通过函数指针，我们可以在运行时根据需要选择要调用的函数，从而实现代码的动态性和灵活性。

需要注意的是，函数指针的类型必须与所指向函数的类型匹配。也就是说，函数指针的返回类型和参数列表必须与所指向函数的返回类型和参数列表相同或兼容。

~~~c
static struct input_handler evdev_handler = {
	.event		= evdev_event,
	.events		= evdev_events,
	.connect	= evdev_connect,
	.disconnect	= evdev_disconnect,
	.legacy_minors	= true,
	.minor		= EVDEV_MINOR_BASE,
	.name		= "evdev",
	.id_table	= evdev_ids,
};
~~~

所以evdev_event是一个函数名称，要赋值给input_handler结构体中的函数指针event，现在可能是懂了，然后继续向后学习。

















# 1.24 工作记录

==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理为网络，分享出来，与更多志同道合的朋友一起进步。==

==无论你最后想要成为怎样的人，千万要记住，时间在飞逝。==

​	挺有感触的，娱乐至死，娱乐、至死，up的一系列总结像一根根刺一样扎入我的思想，于是开始反思，开始醒悟，开始想着改变自己，但一切都不是一蹴而就的，要努力，要适应，要开始，带着新生的枝桠，向前走呀。

问题1：
~~~c
static struct input_handler evdev_handler = {
	.event		= evdev_event,
	.events		= evdev_events,
	.connect	= evdev_connect,
	.disconnect	= evdev_disconnect,
	.legacy_minors	= true,
	.minor		= EVDEV_MINOR_BASE,
	.name		= "evdev",
	.id_table	= evdev_ids,
};

static int __init evdev_init(void)
{
	return input_register_handler(&evdev_handler);
}
~~~

分析 input_register_handler 是一个函数，传入的是evdev_handler的地址，而evdev_handler是一个结构体，其实对于结构体相关的内容我也不是很清楚虽然我学了很多次了，但说实话真的很不好，你懂我的意思吧。

`struct`是C语言中的关键字，用于定义自定义的数据类型，可以将多个不同类型的变量组合在一起形成一个结构体，从而创建一个包含多个成员的复合数据类型。

`struct`是C语言的关键字，用于定义自定义的数据类型，可以将多个不同类型的变量组合在一起形成一个结构体，从而创建一个包含多个成员的符合数据结构类型。

结构体的定义通常包括以下几个部分：

1. `struct`关键字：用于声明一个结构体类型
2. 结构体标签：用于表示结构体类型的名称，可以在定义时指定，也可以忽略
3. 成员列表：定义结构体的成员，每个成员包括类型和名称

结构体的定义通常包括以下几个部分：

1. `struct`关键字：用于声明一个结构体类型。
2. 结构体标签：用于标识结构体类型的名称，可以在定义时指定，也可以省略。
3. 成员列表：定义结构体的成员，每个成员包括类型和名称。

下面是一个简单的示例，展示了如何使用`struct`定义一个包含姓名和年龄的人员信息结构体：

```
struct Person {
    char name[50];
    int age;
};
```

在上面的示例中，`struct`关键字用于定义一个名为`Person`的结构体类型。该结构体有两个成员：`name`和`age`，分别表示人员的姓名和年龄。

定义结构体后，就可以声明结构体变量并使用它们，如下所示：

```
struct Person person1;
struct Person person2;

strcpy(person1.name, "John Smith");
person1.age = 30;

printf("Person 1: Name = %s, Age = %d\n", person1.name, person1.age);

person2 = person1;  // 结构体变量之间可以进行赋值操作

printf("Person 2: Name = %s, Age = %d\n", person2.name, person2.age);
```

在上面的示例中，我们声明了两个`Person`类型的结构体变量`person1`和`person2`。然后，我们使用`strcpy`函数将字符串"John Smith"复制到`person1`的`name`成员中，并将30赋值给`person1`的`age`成员。最后，我们打印了`person1`和`person2`的姓名和年龄。

结构体变量的成员可以通过`.`运算符来访问，即`结构体变量名.成员名`。可以像访问普通变量一样访问结构体变量的成员。

使用结构体可以更好地组织和管理相关数据，将多个相关的数据打包在一起，方便进行传递和处理。结构体还可以嵌套定义，允许在一个结构体中包含另一个结构体作为成员，从而形成更复杂的数据结构。



# 1.23 工作记录

昨天请了一天的假，感觉良好，但你让我今天再重复昨天，我想我是不乐意的，昨天的问题仍旧还有很多，但作为改变的第一天，仍旧可以接受，只需要一天比一天进步就行了，然后其他的就继续慢慢的探索吧。

在公司遵守昨天写的那四个规定，有时间一定要注意时间，用最大的时间来等待，规定的时间看qq，手机远离，其他的等需要的时候再补充。

==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理成网络，分享出来，与更多志同道合的朋友一起进步==

![image-20240123092314586](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401230923713.png)

有了一个崇高的追求之后，自然而然就有了为之努力的动力，如果不能，那就是这个追求还并没有刻骨铭心。

____

今天的任务有不少，罗列一下：

1. 年终总结
2. 本周计划
3. 课程完成步骤整理

年终总结确实是要写一下，其实现在倒是挺困难的，年终总结我都不晓得做过啥了，工作记录啥的倒也是有，但仍旧是无法提取内容，看大致的看一下时间线。

上半年，一直持续到了七月一直再看ai的视频，但以目前的眼光来看，这是完全不对的，当然对于那时候的我来说确实很可以了，半年的时间如果让我沉下心来学习，其实能学好多的东西了，所以这些其实是正常水平，但我仍旧相信，我们这些人对于ai的认识还是太短浅了，无论是从认识的深度还是广度来说，都是很有问题的，还是精力分配的问题，而人们的目光总是具有一定的局限性，无论是谁，其实这些吧可以自洽就行了。

当然在上半年的期间还重新写了一遍系统编程的手册，对于现在的我来说，这些当然仍旧是漏洞百出，问题很大，有很多的东西现在我其实也并没有真的认识到，只能说越学习，越深入只会感觉自己越渺小，要学习的可真的太多了，打算等后面录制到系统编程这一阶段课程的时候，可以有新的认识。

然后就是两个月的驱动手册编写了，对于驱动这个地方，问题也挺大的，还是学习的不深入，并没有一个自己的理解，还有很多相关的知识点的认识还仅仅停留在表面上，并没有形成一个专属于自己的框架，这是后面不断努力的一个方向。

其他绝大多数时间都在完善ubuntu和debian文件系统的构建，这就设计到了很多的方面，包括编译脚本的完善，那些RK专属特性功能的移植，就比如GPU加速、VPU编解码、RGA 图形加速单元等等，都增长了关于系统这方面的理解，当然目前的理解仍旧还停留在表面上，现在也仅仅是知道这些特性的功能是怎样的，如何让它们在自己构建的ubuntu系统上正常使用，但是对于更深层次使用就不仅仅是这样了，无论是编解码、GPU还是RGA，要想真正的使用他们，仍有花费更多的功夫，希望明年有机会接触到这些。

___

又一年过去了，感觉一年的时间过的真的太快了。

回顾过去的一年，上半年一直在学习人工智能相关的知识并录制RKNPU视频，当时还感觉做的还可以，但从现在的眼光来看，里面有问题的地方还挺多的，不论是从讲解的风格上、还是讲解的技巧上都有很多改进的地方，这也说明那时候对人工智能的认知还是不太对，无论是在深度还是广度上，都存在问题。而接下来要录制的Linux基础视频就应该用一种新的、更容易让客户接受和理解的风格。

除此之外，在上半年期间，还重新编写了系统编程手册，现在来看的花，系统编程的手册仍然存在许多漏洞和问题，可能当时的自己以为理解了，而实际上理解的并不够，每个阶段都有每个阶段的看法，学习的越多越感觉之前的问题越多，一点点慢慢的解决吧，等后面录制系统编程阶段的视频时，应该又能有新的认识和理解。

接下来，花了两个多月的时间编写驱动手册。在编写驱动手册的过程中，我也遇到了很多问题，仍旧是感觉学习的还不够深入，对于驱动的理解还没有形成一个属于完整的框架，对于很多相关知识点的认识仅限于表面，可能看到它的时候会认识，但是实际使用的时候根本想象不到还有这个内容，所以仍旧是需要后续不断努力，朝着更深入的方向学习。

剩下绝大部分时间都用来完善 Ubuntu 和 Debian 文件系统的构建。最主要的内容就是编译脚本的改进和移植 RK（Rockchip）平台的专属功能，编译脚本这里尽可能的写的规范，并添加详细的中文注释，方面后续文件系统构建手册的编写以及对应视频的录制，然后是一系列的特性例如 GPU 加速、VPU 编解码、RGA 图形加速单元等。这些特性方面增强了我对系统方面的理解，同样的目前对于这些的理解仍然较为表面。我现在只知道这些特性的功能是如何在自己构建的 Ubuntu 系统上正常使用它们，但要想更深入地使用编解码、GPU 或 RGA 等功能，仍需付出更多努力。希望明年有机会能更深入地探索这些领域。

上面就是一年完整的事件记录，其他零零散散的事情就不再陈述了。明年，我希望能在目前的基础上继续学习，加深对于上述相关知识的认识，然后整理成相应的网络，提升自己。

___

本周的工作任务和年终总结写完了，然后就是继续整理Linux基础的后续路线了，我认为以后不管要做的是什么，都应该要符合逻辑和因果，逻辑正确才是我做人任何事情的核心，就以昨天一天的事情为例来总结，为什么昨天能请一天假呢？是因为前天有一个up主的观点深刻的影响了我，我认为能从up主这里获得救赎，但是实际上呢，白天或许真的救赎了，但是晚上的时候仍旧是出现了问题，还是自身意志力的因，将手机带出去了，并且还看了一下子小说，所以就导致浪费了两个多小时的时间，不，也不止两个小时，除了看小说的时间，还有着在电脑前刷哔哩哔哩的时间，所以目前看来意志力是有限度的，当我在家学习了一天之后。

___

看来一下多巴胺，然后我就发现作者所看的书好像他自己的一个探索的过程呀，将自己的观点进行输出，完善自己的科学价值体系，真的就很厉害了，而我从里面要学习到的，是人家不断深入、不断探索，最终还能给人们讲出来的这种品格，这真的是人家的三观的具体体验，而我呢？还在慢慢慢慢的探索，一个道理的收获当然不仅仅是学习到了就行了，更重要的还是实际的所做所为。

___

就这样吧，我可以确定以及肯定当前的大方向肯定是没问题的，我所说的大方向是当前的这种录视频的方式以及内容之间的逻辑性，就目前来看是没问题的，今天下午开始继续看法师的视频，然后整理，感觉法师的视频总是一些讲解的内容，目前给我的感觉是不难写，其他的待定。



# 1.21 工作记录

___

___

不好搞呀，这个压缩的这个想法就先这样吧，不是很容易，浪费一点时间就浪费一点时间吧，主要是还要改脚本，这可真的是太难了。

行了，玩了一天了，也该学习学习了，昨天也重申了一下学习的第一要义，而且法师也说了要了一切在于开始，只要开始了，那一切的设想就都会落在地上，必须要早日开始了，但这也仍旧不能阻拦我的开始。

___



# 1.20 工作记录

找找问题好吧，先来简单的叙述一下当前遇到的问题吧，那就是心静不下来了，而且还找不到真正的原因,可能在过程中的我还看不清楚，但是当我不在局中的时候就看到了问题所在，在家的时候因为要看哔哩哔哩，这就导致了，有很大的一部分时间都会花在那些华丽花哨、云里雾里的哔哩哔哩首页，其实很早之前就已经察觉到了，这些首页的东西才是真正害人的东西，你永远也不知道下一个会刷出来什么东西，所以无可避免的就会一直期待着下一页的故事。所以接下来的第一个要改变的东西就是关于哔哩哔哩，既然首页会吸引你，那么就继续将哔哩哔哩的首页给屏蔽呗，这真的是一个很好的选择，而且不会分心。

第二个问题已经解决了其实，那就是在上班的时候会一直看手机，手机这个东西又会给人一种负反馈，而且会时时刻刻的想要看一眼，当手机不在桌子上的时候，就自然而然减少了看的欲望，所以对于我来说唯有从根源上才能解决，这里就先这样了。

第三个问题，现在看视频的时候，总给人一种特别快感觉，根本就沉不住气，你懂这个感觉吗，无论是王老师的视频还是哔哩哔哩上一些老师的视频，亦或者是那些短视频都已经不能真正的沉下心来看了，而且这个是无分在哪里的视频的，无论是下载好的视频，还是在线的网络视频，都有着很大的问题，而且在看的时候很容易就分心了，就比如昨天晚上的时候就一直在看小说，这就导致效率真的极其低下，当然你也是知道的，这样肯定是不对的，但仍旧是改不了这个臭毛病，现在想到的办法是无论看什么视频都要写相应的笔记，是的，无论什么，只有强制才能真的有作用，否则对于你来说，就是没有丝毫限制的，你懂吗，行了，今天的反思就这样了，然后就该开始今天的工作了，中午也不会再看哔哩哔哩了，确实很浪费时间，亦或者回个家？好像也不是不行。

___

开始看视频了，在学一个东西之前我总是要知道要学的这个东西是什么对吧，而且不管是啥，我自己肯定也会对这个东西有一个基本的认知，就算之前没学习过，也应该会有相应的认识才对，不然为啥要学这个东西呢？今天是学习一个东西的第一个开始，肯定要应该有对应的章程才对。

1. 要学习的是什么？
2. 为什么要学习它？
3. 要怎样学习它？

经典的三个问题，是什么、为什么以及怎么做，这三个问题真的贯穿了好多

___

3588的触摸出现问题了，研究解决一下，但还好吧，可以听听音乐了。

问题解决了，是我的编译脚本出问题了，很尴尬，打包和上传又要耗费很长的时间，唉，继续回到法师的视频上面来。

____

问题1：要学习的是什么？

第13期的视频名称是输入子系统，我对于输入子系统的概念还停留在最初的记忆，也就是cat /proc/bus/input/devices 我只知道可以通过这个来获取输入子系统的设备，然后在dev目录下有对应的event节点，通过hex命令可以查看对应的输入信息，其他的我就一概不知了。

问题2：为什么要学习输入子系统？

不好意思，我也不知道，其实我现在都不知道学习了这个东西之后会有什么作用，好像只是因为工作需求而完成的，当然能给我一点点的提升，而且是内在的提升，不知道具体的实际的提升，先看看吧，可能在学习的过程中，我就能知道真正的答案了。

问题3：要怎样学习输入子系统？

一切其实也只是法师的视频，除此之外也没有什么其他的方法，当然肯定是要记笔记的，没有笔记的学习其实根本就不算是学习了，你懂吗，这是昨天的时候你说的。

| 视频名称                                    | 学习前的预测                                                 |
| ------------------------------------------- | ------------------------------------------------------------ |
| 总领：本期视频介绍                          | 视频的总览，很重要，正好可以趁这个机会学习借鉴一下法师的风格 |
| 什么是输入子系统？                          | 开篇第一节，肯定是陈述要讲解的东西是什么，有一个总览         |
| 如何确定输入设备与节点的对应关系？          | 这个我懂，我感觉是我上面描述的哪个                           |
| 实践：确定输入设备对应的设备节点            | 这个我也懂，当然也只是可能懂                                 |
| 输入子系统框架讲解                          | 讲解框架                                                     |
| 输入子系统框架分析                          | 分析框架                                                     |
| 输入子系统关键数据结构之间关系              | 整理数据结构之间的关系                                       |
| 认识输入子系统源码以及裁剪                  | 子系统源码和裁剪？？？？很牛                                 |
| 编写一个最简单的设备驱动层代码              | 编写一个输入子系统范例                                       |
| 通过最简单设备驱动代码分析匹配规则和流程    | 分析驱动流程                                                 |
| 引入多对多的匹配关系                        | 从名字可以看出来一对一和一对多                               |
| 继续编写设备驱动层代码（理论指导）          | 继续编写驱动代码1                                            |
| 继续编写设备驱动层代码（实现循环上报）      | 继续编写驱动代码2                                            |
| 编写应用程序获取上报数据                    | 应用程序1                                                    |
| 输入子系统上报数据格式分析                  | 分析数据格式                                                 |
| 通用事件处理层驱动分析：connect函数分析     | 分析connect函数                                              |
| 通用事件处理层驱动分析：分配设备号          | 分配设备号                                                   |
| 通用事件处理层驱动分析：open函数分析        | open函数分析                                                 |
| 设备驱动层上报数据流程分析                  | 上报数据流程分析                                             |
| 通用事件处理层驱动分析：event函数分析-      | event函数分析-                                               |
| 通用事件处理层驱动分析：read和write函数分析 | read和write函数分析                                          |
| 核心层代码分析                              | 核心层代码分析                                               |
| 实践：固定输入设备的设备节点                | 实践1                                                        |
| 实践：固定usb设备的设备节点                 | 实践2                                                        |

## 本期视频介绍

法师会根据这个图来讲解一下要讲解的知识，具体如下所示：
![image-20240120142607205](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201426425.png)

## 什么是输入子系统？

input子系统顾名思义就算输入子系统，所以可以从输入设备入手， 拿什么是输入设备呢，就比如你现在敲的键盘，鼠标以及触摸屏等等。

输入设备的驱动是有一些共同点的，那就是这些设备都是要获取数据，然后上报给用户，所以Linux就将这些通用的代码编写好，而将那些差异化的代码留给了工程师自己来完成，从而就出现了input子系统，综上：输入子系统就是Linux专门为了输入类设备编写的一个子系统，从而规范驱动开发，降低开发难度，并且有着很高的通用性和兼容性。

## 如何区分节点和设备的对应关系？

 设备名可以分为通用设备名和专用设备名，通用设备名可以通过名字来看出该输入设备是什么设备，而通用设备名无法通过名字看出具体的设备。

![image-20240120150328914](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201503990.png)

可以使用cat命令来测试性查看具体的设备，如下图所示：
![image-20240120150640955](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201506102.png)

也可以使用hexdump命令来二进制查看上面乱码的具体值，如下所示：

![image-20240120150746590](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201507669.png)

查看所有输入设备的信息：
~~~bash
cat /proc/bus/input/devices
~~~

![image-20240120150920993](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201509216.png)

## 确定输入设备的设备节点

这节课没啥，就不写了，这些相关的知识我已经学过了。

## 输入子系统框架

​	具体的狂徒如下所示：

![image-20240120153016443](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401201530703.png)

input子系统分为三个层次，分别为事件处理层、inpit核心层、设备驱动层。 

## 输入子系统框架分析

事件处理层代码evdev.c,事件处理层代码一般不需要我们去编写，内核实现了一个通用的事件处理层代码，对应的设备节点就是event0和event1，但如果是有特殊的需求，就需要自己编写事件处理层代码了，代码所在路径为drivers/input/evdev.c。

evdev_init:

~~~c
static int __init evdev_init(void)
{
	return input_register_handler(&evdev_handler);
}
~~~



evdev_handler:

~~~c
static struct input_handler evdev_handler = {
    .event = evdev_event,
    .events = evdev_events,
    .connect = evdev_connect,
    .disconnect = evdev_disconnect,
    .legacy_minors = true,
    .minor = EVDEV_MINOR_BASE,
    .name = "evdev",
    .id_table = evdev_ids,
};
~~~



input.h evdev_handler:

~~~c
struct input_handler {
    struct input_handler *f;
    void *private;
    void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
    void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count);
    bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
    bool (*match)(struct input_handler *handler, struct input_dev *dev);
    int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
    void (*disconnect)(struct input_handle *handle);
    void (*start)(struct input_handle *handle);
    bool legacy_minors;
    int minor;     
    const char *name;
    const struct input_device_id *id_table;
    struct list_head h_list;
    struct list_head node;
};
~~~

- `f`: 指向其他处理器的指针（可能是父处理器）
- `private`: 用于存储私有数据的指针
- `event`: 处理输入事件的回调函数
- `events`: 处理多个输入事件的回调函数
- `filter`: 输入事件过滤器的回调函数
- `match`: 匹配输入设备与处理器的回调函数
- `connect`: 连接输入设备与处理器的回调函数
- `disconnect`: 断开输入设备与处理器的回调函数
- `start`: 启动处理器的回调函数
- `legacy_minors`: 是否使用旧的次设备号
- `minor`: 次设备号
- `name`: 处理器的名称
- `id_table`: 输入设备 ID 表格
- `h_list`: 用于链接到处理器链表的列表头
- `node`: 用于链接到处理器链表的节点



input.c input_register_handler:

~~~c
int input_register_handler(struct input_handler *handler) {
    struct input_dev *dev;
    int error;

    error = mutex_lock_interruptible(&input_mutex);
    if (error)
        return error;

    INIT_LIST_HEAD(&handler->h_list);
    list_add_tail(&handler->node, &input_handler_list);

    list_for_each_entry(dev, &input_dev_list, node)
        input_attach_handler(dev, handler);

    input_wakeup_procfs_readers();

    mutex_unlock(&input_mutex);
    return 0;
}
~~~



input_attach_handler

~~~~c
static int input_attach_handler(struct input_dev *dev, struct input_handler *handler) {
    const struct input_device_id *id;
    int error;

    id = input_match_device(handler, dev);
    if (!id)
        return -ENODEV;

    error = handler->connect(handler, dev, id);
    if (error && error != -ENODEV)
        pr_err("failed to attach handler %s to device %s, error: %d\n",
               handler->name, kobject_name(&dev->dev.kobj), error);

    return error;
}
~~~~

## 输入子系统关键数据结构之间关系



![image-20240123135050716](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401231350923.png)

​	这个图法师确实是画的很好，但目前我的问题是什么，是我不清楚这些层次关系里面的调用，简单来说就是我的C语言语法有问题

## 认识输入子系统源码以及裁剪

input子系统源码路径

rk356x_linux/kernel/drivers/input

![image-20240123141841867](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401231418910.png)

- apm-power.c: 提供与 APM (Advanced Power Management) 相关的输入设备接口。
- evbug.c: 提供一个用于调试的虚拟输入设备，可以模拟按键、鼠标移动等事件。
- evdevc 和 evdev.o: 提供通用的输入事件层，将所有输入设备的事件转化为标准化的输入事件格式，并提供给上层用户空间程序使用。
- ff-core.c 和 ff-core.o: 提供力反馈设备的支持，允许输入设备发送力反馈信息。
- f-memless.c 和 ff-memless.o: 提供一种无需分配内存的力反馈设备支持，可以在只能使用静态内存的系统中使用。
- gamepot/-: 提供支持游戏控制器的驱动程序。
- input.c 和 input.o: 提供输入子系统的初始化和事件处理等操作。
- input-compatc 和 input-compat.h: 提供向后兼容的接口，用于支持旧版本的输入系统。
- input-leds.c 和 inputleds.o: 提供LED指示灯设备的支持，例如在笔记本电脑键盘上的NumLock、CapsLock、ScrollLock等键。
- input-mtc 和 input-mt.o: 提供多点触控设备的支持，如在触摸屏上使用多个手指进行操作。
- input-polldev.c 和 input-polldev.o: 提供轮询式输入设备的支持，例如通过串口或并口接收数据的输入设备。
- joydev.c: 提供支持游戏杆的驱动程序。
- keyboard/-: 提供支持键盘的驱动程序。
- matrix-keymap.c 和 matrix-keymap.o: 提供矩阵键盘的支持。
- misc/-: 提供其他类型输入设备的驱动程序，如红外线遥控器、输入音频等。
- mouse/ 和 mousedev.c: 提供支持鼠标的驱动程序。
- modules.builtin 和 modules.order: 提供内核中使用的模块列表。
- remotectl/-: 提供支持远程控制的驱动程序。
- rmi4/-: 提供支持触控板和其他 I2C 设备的驱动程序。
- serio/-: 提供支持通过串行端口接入的输入设备的驱动程序。

## 编写一个最简单的设备驱动层代码



步骤一:

1. 创建input_dev结构体变量，使用input_allocate_device函数来动态分配输入设备结构体内存。

步骤二:

1. 初始化input_dev结构体变量。
2. 设置事件类型：
   - 在头文件kernel/include/dt-bindings/input/rk-input.h中，Linux已经定义了一些事件类型的常量。
   - 选择适合您设备的事件类型，并将其设置给input_dev结构体的evbit成员。

以下是已定义的事件类型：

- EV_SYN (0x00): 用于同步事件，表示一组输入事件的结束。
- EV_KEY (0x01): 用于按键事件，表示按下、释放或重复一个键。
- EV_REL (0x02): 用于相对位移事件，表示设备的相对位置变化，如鼠标的移动。
- EV_ABS (0x03): 用于绝对位移事件，表示设备的绝对位置变化，如触摸屏的坐标。
- EV_MSC (0x04): 用于杂项事件，包含一些特殊目的的事件类型，例如设备状态变化等。
- EV_SW (0x05): 用于开关事件，表示开关的状态变化，如电源按钮、开合盖等。
- EV_LED (0x11): 用于LED事件，表示LED灯的状态变化。
- EV_SND (0x12): 用于声音事件，表示声音的播放相关事件。
- EV_REP (0x14): 用于重复事件，表示键盘重复发送事件。
- EV_FF (0x15): 用于力反馈事件，表示力反馈设备的输出事件。
- EV_PWR (0x16): 用于电源事件，表示电源状态变化。
- EV_FF_STATUS (0x17): 用于力反馈状态事件，表示力反馈设备的状态变化。
- EV_MAX (0x1f): 输入事件类型的最大值。
- EV_CNT: 输入事件类型的数量。



~~~c
struct input_dev {
	const char *name;                   // 设备名称
	const char *phys;                   // 设备物理地址
	const char *uniq;                   // 设备唯一标识符
	struct input_id id;                 // 设备ID信息

	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];   // 设备属性位图
	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];             // 支持的事件类型位图
	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];           // 支持的按键事件位图
	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];           // 支持的相对位移事件位图
	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];           // 支持的绝对位移事件位图
	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];           // 支持的杂项事件位图
	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];           // 支持的LED事件位图
	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];           // 支持的声音事件位图
	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];             // 支持的力反馈事件位图
	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];             // 支持的开关事件位图

	unsigned int hint_events_per_packet;                    // 每个输入事件包中的事件数量的提示值

	unsigned int keycodemax;            // 键值的最大值
	unsigned int keycodesize;           // 键值的大小（以字节为单位）
	void *keycode;                      // 键值数组指针

	int (*setkeycode)(struct input_dev *dev,
			  const struct input_keymap_entry *ke,
			  unsigned int *old_keycode);                   // 设置键值的回调函数
	int (*getkeycode)(struct input_dev *dev,
			  struct input_keymap_entry *ke);                // 获取键值的回调函数

	struct ff_device *ff;               // 力反馈设备

	unsigned int repeat_key;            // 重复按键的按键码
	struct timer_list timer;            // 用于重复按键的定时器

	int rep[REP_CNT];                   // 按键重复设置

	struct input_mt *mt;                // 多点触控数据

	struct input_absinfo *absinfo;      // 绝对位移事件信息

	unsigned long key[BITS_TO_LONGS(KEY_CNT)];              // 当前按键状态位图
	unsigned long led[BITS_TO_LONGS(LED_CNT)];              // 当前LED状态位图
	unsigned long snd[BITS_TO_LONGS(SND_CNT)];              // 当前声音状态位图
	unsigned long sw[BITS_TO_LONGS(SW_CNT)];                // 当前开关状态位图

	int (*open)(struct input_dev *dev);                     // 打开设备的回调函数
	void (*close)(struct input_dev *dev);                   // 关闭设备的回调函数
	int (*flush)(struct input_dev *dev, struct file *file); // 刷新设备的回调函数
	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); // 处理事件的回调函数

	struct input_handle __rcu *grab;                        // 当前占用设备的input_handle指针

	spinlock_t event_lock;              // 事件锁
	struct mutex mutex;                 // 互斥锁

	unsigned int users;                 // 设备使用计数
	bool going_away;                    // 设备是否正在释放

	struct device dev;                  // 内核设备结构体

	struct list_head h_list;            // input_handle链表
	struct list_head node;              // 设备链表节点

	unsigned int num_vals;              // 输入值的数量
	unsigned int max_vals;              // 最大输入值数量
	struct input_value *vals;           // 输入值数组

	bool devres_managed;                // 是否由设备资源管理

	ktime_t timestamp[INPUT_CLK_MAX];   // 时间戳数组
};
~~~

步骤三：
注册`input_dev`结构体变量，完成设备的匹配工作。使用`input_register_device()`函数。

步骤四：
上报事件。

步骤五：
注销和释放`input_dev`，使用`input_free_device()`和`input_unregister_device()`函数。

下面是整理后的代码注释：

```c
// 步骤三：注册input_dev结构体变量，完成设备的匹配工作
input_register_device(dev);

// 步骤四：上报事件

// 在适当的时机上报事件，例如按下按钮时
input_event(dev, EV_KEY, BTN_LEFT, 1); // 按下左键
input_sync(dev); // 同步事件

// 步骤五：注销和释放input_dev
input_unregister_device(dev);
input_free_device(dev);
```

示例：
~~~c
#include <linux/input.h>
#include <linux/module.h>

struct input_dev *myinput_dev;

// 模块初始化函数
static int myinput_dev_init(void)
{
    int ret;

    // 分配输入设备结构体
    myinput_dev = input_allocate_device();
    if (myinput_dev == NULL) {
        printk("myinput_dev_init: input_allocate_device分配输入设备失败\n");
        return -1;
    }

    // 设置设备名称
    myinput_dev->name = "myinput_dev";

    // 设置支持的事件类型
    set_bit(EV_KEY, myinput_dev->evbit);

    // 设置支持的按键事件类型
    set_bit(KEY_1, myinput_dev->keybit);

    // 注册输入设备
    ret = input_register_device(myinput_dev);
    if (ret < 0) {
        printk("myinput_dev_init: input_register_device注册输入设备失败\n");
        goto error;
    }

    return 0;

error:
    // 发生错误时释放输入设备资源
    input_free_device(myinput_dev);
    return ret;
}

// 模块退出函数
static void myinput_dev_exit(void)
{
    // 注销输入设备
    input_unregister_device(myinput_dev);
}

module_init(myinput_dev_init);
module_exit(myinput_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("fashi");
MODULE_VERSION("V1.0");
~~~

## 引入多对多的匹配关系

## 继续编写设备驱动层代码

![image-20240123161531216](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401231615316.png)

## 编写应用程序获取上报数据



# 1.19工作记录

在我们的底板上很是正常，一共使用了五根引脚，分别是I2C3 的 sda和scl，然后是VCC和GND，最后是有一个RES的引脚，这个引脚接到3.3v就可以了。

在客户的底板上使用的好像是I2C4，但这个I2C4是不是那个1.8V的呢？ 查看了一下原理图确实是1.8V的，所以改一下源码呗，试试。

# 1.18 工作记录

​	耳塞这个东西，还是很有用的，就比如昨天的时候，很是烦躁，但是在戴上耳机之后依然是可以安静下来的，昨天在白天的时候将黑马的课程看完了，然后开始看狂神的课程，狂神的因为是随性演讲，所以他的手书还有很大的上升空间，我可以在这个基础上来进行发挥，既有黑马的严谨和字幕，还有手书的工整和深入人心，然后精益求精加上下面的可可爱爱的进度条，这不是就很好。

4K分辨率下具体的信息如下所示：

~~~bash

45的小人高度

60的进度条高度

100的字体高度

进度条坐标 2090 
~~~

目前来看所有的都是3840*2160，也可能是我的这些个屏幕都是这么大的，但现在看起来好像都是这个样子了，这样也无所谓了，知道一个具体的大小即可，然后重新实验一遍。还挺简单的，就先这样，然后继续看狂神的视频了。

___

这样吧以后中午的时候就不看哔哩哔哩了。其实有好多东西可以看的，只是沉迷在哔哩哔哩中肯定是不行的，就比如你可以学习一下PCB，就算是这些东西也比你看哔哩哔哩强的多，你说是吧，今天中午就来重新看第一节。其他的就先无所谓了，只希望不再是看一中午的哔哩哔哩了。现在的话就先继续看狂神的Linux了。

___

烦躁、还是烦躁，只有戴上耳塞才能冷静下来，可是为什么会烦躁呢？不是很懂，上午的时候重温了一下那个关键帧和可视化的进度条，感觉还可以，之后我讲解的时候肯定是要加上的。然后现在看完了狂神的Linux基础课程，也不能说看完吧，现在是将vim之前的一些内容都看过了，有些东西很有用，但是有些东西感觉是不需要的，而我讲的时候既要学习黑马的详细，但有些对于嵌入式工程师没有作用的命令，或者使用极其少的命令，尽可能的做删减，黑马的那个口号是什么，少一句不行，多一句没有，而我想的就是继承人家的想法。命令这个地方差不多了，然后开始整理要讲解的命令的逻辑。

___

现在来回忆完整的逻辑，先从黑马的课程开始吧。先不看黑马的具体目录，我希望是从我的笔述中来进行回忆出来的。

最开始的时候是引入了硬件和软件的概念，计算机的组成原理，随后设计牵引出来了Linux的诞生。1991年一个21岁的大学生，编写出了Linux内核的0.01版，此后的三十年就迎来了Linxu发展的黄金时期，为什么学习Linux暂且先不谈，先来思考一下后续要怎样学习Linux，无论如何都是要安装ubuntu操作系统的，但是怎样安装，安装到什么地方都是问题，目前有三种安装Linux的方法，一种是在一台物理计算机上安装双系统，用到哪个系统只需在电脑启动的时候进行切换即可，第二种方法是有两台物理计算机。一台装有Linux系统，而另一台装有windows操作系统，两台电脑的成本较高，对于我们这些初学者来说，很不现实，所以就只剩下最后一种方式可选，那就是在windows操作系统当中使用虚拟机软件虚拟出来一个Linux系统，日常办公使用windwos操作系统，而学习使用虚拟机软件中的Linxu操作系统。接下来就是虚拟机软件的安装、ubuntu操作系统的安装，在安装好系统之后第一件事情我认为也是最重要的一件那就是修改为中文界面，对于初学者来说，肯定是中文界面更亲切，当然后面非常熟悉Linux操作系统之后，英文环境和中文环境这些无所谓了。再然后是tabby的安装，其实我是有一些动摇的，因为tabby的sftp的传输速率是真的慢呀，但貌似只有这一个坏处，其他的都很好，总是要给客户提供一些更好用的终端软件的，不能因循守旧，必须要尽可能的拥抱新鲜事物，从而不被时代所抛弃，本来想的是后面再也不用图形化界面了，但是在看其他大佬的视频的时候，发现在早期的时候使用图形化界面和终端相对比的方式更容易让人理解，所以我后面也会打算使用类似的方式进行讲解。在讲解tabby的时候因为要安装ssh和net-tools，所以这时候要讲解一下ubuntu终端打开的方式。

然后就要进入真正的操作章节了，我第一节讲解的是vim，这是第一个有疑问的地方，真的第一节就要讲vim吗，手册的那些地方当然可以不用管，这些都是通用的，所以vim这个章节是可以向后放的，但是要放到什么地方，这也是一个问题呀。

那就算不讲解vim，第一个要讲解的也会是Linux的目录结构，但这个地方要怎么讲呢，我认为狂神讲解的不对，肯定是不能在root模式下讲解的，就跟图形化界面一样，能少用就少用，所以是不是应该先来讲一下普通用户和特权用户，创建用户这相关的命令没什么作用，肯定是不会讲解的，在实际的使用中肯定是用不到的，所以该略过的就略过。但这个地方就讲解用户和权限是不是也不太好，因为后面会有一个专门的章节来讲解权限，多思考思考总归是没有问题的。但从这个地方确实可以引出来权限。

还是黑马的正确，目录结构是必须的，而每个目录存放了哪些东西，都有什么用处，这个是没有必要的。至少，目前还没这个必要讲。

















































# 1.17 工作记录

==愿先生心境永远四季如春==

​	昨天晚上看了一下黑马的课程，真的不错，今天继续看，目前也不需要做笔记，只需要将大体的内容了解一下即可，然后救赎我的总结，而且他的这些东西并不是全部都要看，当然也要分开，有些东西也不是给我们看的呀，有用的看一下，那些用不到的当然就算了。

___

下午的四点半终于是将黑马的视频看完了，也大体上确定了我在后续讲解时的一些风格，从老师那里学来的是课程总览、字母、课后总结、可视化的进度条，真的很可以了，当然是不可能跟人家保持一致的，最新的ubuntu22、最新的vmware workstation，应用于嵌入式，然后用markdown的风格来写，也理所应当的要走出一个自己的一个风格。学习一下剪辑吧，熟悉一下剪映https://chai0705.github.io/2023/09/03/0%20windows%E6%90%AD%E5%BB%BAhexo/。	

# 1.16 工作记录

==愿先生心境永远四季如春==

​	总算是解决了adb的问题，但是呢具体为什么会这个样子还是不清楚，而且在3588上面就很正常呀，奇怪很奇怪~，这个就先这样了，目前的问题解决了就好，而邮票孔的问题等新板子到了再说吧。

___

所以有的客户还是很牛的，我没找到的问题客户能找到，帮了我一个很大的忙，原来问题出在ls上，我当时就盲目的信任了这个文件，就导致我根本没有在这个方面去想，行了问题解决了，终于可以回到正轨上来了，两天时间没有正常学习了，确实有很多的东西还不会呢，而且在我心里会有一些莫名的恐惧感，对于一个新兴事物的恐惧，但终究要进步的，你说是吧，所以还有两个小时，但仍是要学会记录的，我感觉量化这些东西很重要，至少再有了时间的概念之后，不会一直的想要看群，而且就算有想看的冲动之后也会有一个声音在劝导着我回头，行了，今天的感慨就先到这个地方，新的一天加油。

___

行了，对于每家的视频，都有了一定的认识，每一家都有每一家的优点，当然了每一家也都有缺点，接下来的这些天都自己努力吧，先整体学习一下，就先学习黑马的，其实也就十个小时的视频，其他的就先向后放放。行了今天就到这里吧。



# 1.13 工作记录

==愿先生心境永远四季如春==

==所以读几遍，也不如写出来来的管用。==

[github开源Linux命令查询网站](https://wangchujiang.com/linux-command/hot.html)

昨天的时候写了半天的总结，后续的方向大致是明朗了，但里面的具体内容还没下结论，之前法师说的详细，现在理解起来又有了新的想法，那就是思想放的还是太高，根本就不知道什么是真正的小白，既不是一眼能看出来问题所在的大佬，也不是什么都不懂的小白，这种思想境界，是最尴尬的地方，不能有大佬的高瞻远瞩，也没有小白的白纸一般，那种什么都不知道的心情，所以闭门造车总是不对的，必须要借鉴其他人的录制课程的经验，然后找到其中的优点，找到自己认知的浅薄，逐渐完善。先把目前哔哩哔哩上开放的那些视频列举一下：

[韦东山](https://www.bilibili.com/video/BV1w4411B7a4?p=1&vd_source=f06237b57d9754575c93eaa6db881c53)

[正点原子](https://www.bilibili.com/video/BV1vE411h7Fi?p=1&vd_source=f06237b57d9754575c93eaa6db881c53)

[黑马程序员](https://www.bilibili.com/video/BV1n84y1i7td/?spm_id_from=333.337.search-card.all.click)

[野火](https://www.bilibili.com/video/BV1JK4y1t7io/?spm_id_from=333.337.search-card.all.click&vd_source=f06237b57d9754575c93eaa6db881c53)

然后是狂神的docker，这个视频给了我一个很大的启发，这种教学模式就非常非常的吸引人，而且获得了很好的注意，这是链接[狂神说docker](https://www.bilibili.com/video/BV1og4y1q7M4/?spm_id_from=333.337.search-card.all.click&vd_source=f06237b57d9754575c93eaa6db881c53)

___

先来看看各个家的评论，还有我的第一印象。

___

## 黑马

### 评论1

![image-20240113160322954](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131603038.png)

内容提取

1. 课程笔记写的很适合实操
2. 将所有的命令进行分类讲解
3. 每节课的最后都有当节课程的总结
4. 每一节都有相对应的字幕

学到的东西：
	视频要自己剪辑，之前录的视频是我根据稿子来制作的视频，本来以为这样是有问题的，但是看到黑马的视频之后发现人家讲解的确实好，无论是逻辑还是清晰程度，都比正点原子的好的多，而且我以为讲解这些个视频是不会有字幕的，因为你不知道会不会有遮挡啥的，黑马的老师就用事实告诉我，这是可以的，这一点我肯定是要学习的，还有之前了解到的那个分段视频，目前我想到的就是，我的一个视频最少分为三个部分，每一个视频的开头和结尾内容都是固定的，在开头的时候会讲本节课的内容概览，讲解一下原因和因果，在结尾的时候因为已经提前写完了手册，所以可以根据手册从上到下来重新追一下。、

还是之前已经理解过的那句话，付出多少努力，不一定会有对应的回报，但是不努力，肯定就不会有回报。	

### 评论2

![image-20240113160632208](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131606253.png)

还是那一句话，不能与新学习的小白所共情，很多时候你以为的只是你以为的，你以为你讲解的已经足够细致了，但实际上呢，往往站在小白的角度是不一样的，你既然现在能写出来，就证明你可能懂了，但到具体实施的时候可能还是不够的，尽可能的将身段放低。

### 评论3

![image-20240113160811493](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131608548.png)

这句话的评论很对,不管是野火还是正点原子，他们的视频在我看起来都有问题，就连最基础的韦东山的视频都有一堆人在下面说，这个不适合基础，很不理解，目前认为韦东山的就是讲解的有一些乱，可能是迫切的想要将所有的板子融合在一起吧，所以不免有些混乱，在我讲解Linux基础的这一段时间内，是没有必要讲关于开发板相关的，而法师也说了，要讲就要脱离开发板来讲，反正在讲解Linux应用之前是没必要的，正点原子的就是根本没有经过系统的梳理，跟黑马比起来简直就是天上地下，那两百多个小时的视频都是水的吧，真的完蛋。

### 评论4

![image-20240113161031265](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131610311.png)

其实还是练习的原因，我之前也是这样的，直到有一天，发现了markdown，发现了博客，才终于是改变了这一现状，之前还停留在用手写的年代，现在看起来真的是太low了，当然人都是在进步的，我没有拘束在之前旧的观念里，就已经很好了。

___

## 正点原子

### 评论1

![image-20240113175802351](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131758401.png)

我后面肯定是要使用这个插件的，无论是写shell脚本的时候，还是后面写系统编程手册的时候，都要用vscode插件的

### 评论2

![image-20240113175919426](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131759464.png)

我不这么认为，翻车是因为没规划好，目前我的思想还没这样。

### 评论3

![image-20240113180021165](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401131800220.png)

哈哈，说的对，我可能带点感性，但是我也感觉他的视频很有问题，口语化太多了，这可能也是正点原子的通病，时常确实多，但真的没有必要，有些东西该讲，有些东西不该将，没有一句废话，没有一个重点遗漏，学学黑马嵌入式，才是正确的道路。

## 韦东山

[韦东山](https://www.bilibili.com/video/BV1w4411B7a4?p=1&vd_source=f06237b57d9754575c93eaa6db881c53)

### 评论1

![image-20240116162517032](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161625121.png)

这个人我是在前面的黑马程序员那里看到过的，他的评论也很激烈，而且说的还都是实话，所以我肯定是要引以为鉴的，韦东山的跳跃的真的太多了吗，我一定不能这样。

### 评论2

![image-20240116162702943](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161627002.png)

### 评论3

![image-20240116162848648](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161628691.png)

### 评论4

![image-20240116162948085](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161629140.png)

### 评论5

![image-20240116163010216](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161630269.png)

### 评论6

![image-20240116163123661](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161631721.png)

### 评论7

![image-20240116163236097](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161632156.png)

## 野火

[野火](https://www.bilibili.com/video/BV1JK4y1t7io/?spm_id_from=333.337.search-card.all.click&vd_source=f06237b57d9754575c93eaa6db881c53)

### 评论1

![image-20240116165507689](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161655730.png)

### 评论2

![image-20240116165650134](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161656173.png)

## 迅为电子

突然发现我们家的评论可真的不错呀，哈哈

![image-20240116163825681](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401161638766.png)

继往开来，辞旧迎新，当然要做的比法师更好，也没理由不比法师好，我是真的热爱，也是真的尽力想要做的很好，所以我要加油。

行了，就先这样吧，然后继续我自己的学习。

# 1.12 工作记录

==还是戴着耳塞比较适合我，能安静很多。==

==少年呀，心还是不安静了呀==

[Linux基础课程](https://edu.51cto.com/lesson/741324.html)

[shell编程学习](https://edu.51cto.com/topic/1634.html)

___

tabby的一些快捷按键我需要适应一下，得跟客户一样才行，我不能因为我的喜好而影响客户。

|                   操作                   | 快捷键                        |
| :--------------------------------------: | ----------------------------- |
|                   复制                   | ctrl+shift+c                  |
|                   粘贴                   | ctrl+shift+v 或者shift+insert |
|                   全选                   | ctrl + shift +a               |
|                   行首                   | Home                          |
|                   行尾                   | End                           |
|             跳转到上一个单词             | ctrl + 方向左                 |
|             跳转到下一个单词             | ctrl + 方向右                 |
|              删除上一个单词              | ctrl+回退按键                 |
|                 删除整行                 | ctrl+shift+回退按键           |
|              删除下一个单词              | ctrl+delect                   |
|                   放大                   | ctrl + +                      |
|                   缩小                   | ctrl + -                      |
|                 重置缩放                 | ctrl+0                        |
|              智能复制和粘贴              | ctrl+c                        |
|                   搜索                   | ctrl+shift+f                  |
|              滑动到终端顶端              | ctrl+pageup                   |
|              滑动到终端底部              | ctrl+pagedown                 |
|             终端向上滑动一页             | alt+pageup                    |
|             终端向下滑动一页             | alt+pagedown                  |
|                 打开设置                 | ctrl+,                        |
|                 切换窗口                 | ctrl+空格                     |
|              显示命令选择器              | ctrl+shift+p                  |
|              显示配置选择器              | ctrl+shift+e                  |
|               切换全屏模式               | F11或者alt+回车               |
|               重命名标签页               | ctrl+shift+r                  |
|                关闭标签页                | ctrl+shift+w                  |
|           重新打开最后的标签页           | ctrl+shift+z                  |
|             进入下一个标签页             | ctrl+shift+右                 |
|             进入上一个标签页             | ctrl+shift+左                 |
|                移动标签页                | ctrl+shift+pageup和pagedown   |
|         显示窗格标签用于调整位置         | ctrl+shift                    |
| 将当前标签页所在的窗格更改为单独的标签页 | ctrl+shift+.                  |
|       将所有标签页合并到当前标签页       | ctrl+shift+,                  |
|                 向右拆分                 | ctrl+shift+e                  |
|                 向下拆分                 | ctrl+shift+o                  |

____

昨天将vim的内容大致是写好了，突然不知道后续要做什么了，现在最好是继续向下规划，但是向下规划一定就是对的吗，我对这一点很是充满疑惑，所以摆在面前的路有几条呢，先来思考这个问题：

- 继续向下完善内容
  	目前是有了六个小节的内容，后面其实就该讲命令了，命令这里需要讲的其实挺多的，但讲解命令也要有逻辑，所有的一切都要讲逻辑和顺心意，如果下一步是整理命令的话，希望保持严谨性
- 整理全篇的讲解逻辑和开篇语。
  目前只是写好了对应的手册，但是呢，无论是讲解的实际逻辑还是开篇语都是没有的，在是在心中仍旧是没有一个完整的蓝图，或者一个完整的预演，都不能想象出来一个完整的画面是什么，是时候停下来看看了吗，但是一个整体的框架是不是更重要，所以这里我就开始纠结了下了

还是想不出来，还是继续向下进行把，但是要做一点点的改变，本来也就是这样想的，当前面的一些基础内容搞完之后，整个教程也就定调了，法师的意思是尽可能的详细，那怎样才能被称之为详细呢？或者怎样做才能对新手、小白更友好呢？可能法师说的详细并不是我理解的那个详细，我理解的是内容的详细，而法师的意思现在我认为应该是讲解时候的详细，而且要友善，用markdown写笔记的我肯定友善呀，而且边讲边写客户听的倒也还好，而且适当的加速，不能用一倍速，这个具体的调速的倍率后面再说。

所以目前的整体大方向是对的，只是现在有了一个岔路，不知道先走哪一条，后走哪一条了，先整理一下逻辑吧。

在最开始的第一节应该是一个总览，要说都要讲哪些东西，一个总览的作用，也就是海之蓝所说的那个摸象和总览，一个好的总览总是能给人带来不一样的感受，那是不是我录视频也需要一个总览呢，目前看来是需要的。

其实这也是两条路，一条是内在的讲解方式，一条是宏观的内容脉络，目前内容脉络还没有理清楚，先理清楚宏观脉络。目前是进行到了vim，打算后面要讲命令，那讲完命令之后呢？你要怎么办，到这里就结束了？那总是不可能吧。现在我想看其他人都是怎样讲的？无论是韦东山、还是野火、亦或者正点原子或者王老师，他们是怎么讲解的呢？看也是看他们讲解的内容，而不是看他们各自的讲解方式，具体的一些内容还是有一些矛盾，我先来说一说我自己的想法吧，现有一个自己的想法，然后再一点点的向里面填充其他人的内容。

__________________________________

我的想法，目前我所写完的就是我的想法，在学习一个东西之前，你总是要知道他能用来做什么吧，或者说为什么一定要学它吧，这个条件成立之后才能开始后续的内容，否则一切都是无稽之谈，然后呢，要想学这个东西总是要有相应的环境才行，所以开始进行Linux环境的搭建，这里选择vmware虚拟机加ubuntu，然后为了更友好的看打印信息，所以率先将英文修改为了中文，然后因为想尽早培养大家不依赖图形化界面的习惯，所以要寻找一个好用且好看的终端软件，所以接下来讲解了tabby的简单使用，以及ssh连接到虚拟机ubuntu。到这里基础的环境就搞完了，然后就开始真正的Linux基础的讲解了。

这肯定不能跟windows一样，直接图形化界面开始摸索，毕竟一开始就是贯彻的非图形化界面的思想，那没有图形界面，那在linux中要怎样进行文件的编辑呢，那就是vim，当然对于vim的介绍肯定远不止与此，具体的描述后续再说，这个不急，然后呢要讲什么，先说一下都要讲什么吧。

下面是chatgpt给出来的学习路线

> 1. 了解Linux的基本概念：
>    - 了解Linux的起源和发展历史。
>    - 理解Linux操作系统的特点和优势，例如开源性、灵活性和安全性。
> 2. 安装Linux操作系统：
>    - 选择适合你的需求的Linux发行版（如Ubuntu、Fedora、Debian等），并下载安装镜像文件。
>    - 创建Linux安装媒介（如USB驱动器或DVD）。
>    - 按照安装向导的指示，将Linux操作系统安装到计算机上。
> 3. 掌握基本的命令行技能：
>    - 学习Linux命令行的基本语法和常用命令，如文件和目录操作、文本处理、文件权限等。
>    - 理解Linux文件系统的层次结构，并学会使用`ls`、`cd`、`pwd`等命令进行导航。
>    - 练习使用基本的文件和目录操作命令，如`mkdir`、`cp`、`mv`、`rm`等。
>    - 学习使用文本编辑器（如`vi`或`nano`）进行简单的文本编辑。
> 4. 理解Linux用户和权限管理：
>    - 学习Linux用户和用户组的概念，以及它们在系统中的作用。
>    - 掌握用户和用户组管理命令，如`useradd`、`usermod`、`groupadd`等。
>    - 了解Linux文件权限模型，包括文件所有者、文件所属组和其他用户的权限。
>    - 学习使用`chmod`和`chown`等命令来修改文件和目录的权限和所有者。
> 5. 学习软件包管理：
>    - 了解Linux软件包管理系统（如APT、DNF、YUM等）的概念和工作原理。
>    - 掌握软件包的安装、更新和卸载命令，如`apt-get`、`dnf`等。
>    - 学习使用软件包管理工具来搜索、安装和管理软件包。
> 6. 深入学习Shell脚本编程：
>    - 学习Shell脚本编程的基础知识，包括变量、条件语句、循环和函数等。
>    - 练习编写简单的Shell脚本来自动化常见的任务。
> 7. 了解网络配置和管理：
>    - 学习Linux网络配置的基本知识，包括IP地址、子网掩码、网关等。
>    - 掌握网络配置命令，如`ifconfig`、`ip`等。
>    - 学习使用网络诊断工具，如`ping`、`traceroute`等。
> 8. 学习系统监控和故障排除：
>    - 了解Linux系统监控的基本概念，如CPU、内存、磁盘使用等。
>    - 掌握系统监控命令，如`top`、`htop`、`free`等。
>    - 学习故障排除技巧，如查看日志文件、使用调试工具等。

___

文件互传肯定是在后面的因为里面会涉及到路径相关的内容，所以一些基础的命令绝对绝对是要讲解的。所以命令肯定是放在前面的，而命令都要讲哪些东西呢，就像哪些cat命令这些真的用的到吗，我咋认为用不到呀。

什么是命令？命令的通用格式是什么

- 基本的文件和目录操作：
  - `ls`：列出目录中的文件和子目录。01-Linux目录结构
  - `cd`：切换当前工作目录。
  - `pwd`：显示当前工作目录的路径。
  - `mkdir`：创建新的目录。
  - `touch`：创建新的空文件或更新现有文件的时间戳。
  - `cp`：复制文件和目录。
  - `mv`：移动文件和目录，或重命名文件和目录。
  - `rm`：删除文件和目录。
- 文件内容查看和编辑：
  - `cat`：在终端中显示文件的内容。
  - `more`或`less`：逐页显示文件的内容。
  - `head`：显示文件的前几行。
  - `tail`：显示文件的后几行。
  - `grep`：在文件中搜索指定的模式。
  - `vi`或`nano`：常用的文本编辑器，用于编辑文件。
- 用户和权限管理：
  - `sudo`：以超级用户权限执行命令。
  - `useradd`：创建新用户。
  - `passwd`：设置用户密码。
  - `chown`：修改文件或目录的所有者。
  - `chmod`：修改文件或目录的权限。
- 网络相关命令：
  - `ping`：测试与另一台计算机的网络连接。
  - `ifconfig`或`ip`：查看和配置网络接口。
  - `ssh`：远程登录到其他计算机。
  - `scp`：在本地计算机和远程计算机之间复制文件。
- 系统状态监控：
  - top：实时显示系统的整体资源使用情况，包括CPU、内存、进程等。
  - htop：类似于top命令，但提供了更多的交互式功能和信息展示。
  - ps：显示系统当前运行的进程列表。
  - kill：终止正在运行的进程。
  - free：显示系统内存的使用情况。
  - df：显示磁盘空间的使用情况。
  - du：计算文件或目录的磁盘使用量。

____

windows和ubuntu之间的文件互传  		

- scp
- sftp
- 直接拖动
- 共享文件夹
- samba

来一个可能有用的链接：[博客](https://blog.csdn.net/zhi_Alanwu/article/details/131262822?ops_request_misc=&request_id=&biz_id=102&utm_term=windows%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131262822.142)

____

____

1. Shell的概念：Shell是Linux操作系统中的命令行解释器，它接收用户输入的命令，并将其转化为操作系统可以理解的指令。学习Shell编程意味着学习如何编写一系列的Shell命令，以实现自动化和脚本化任务。
2. Shell脚本文件的创建：Shell脚本是一系列Shell命令的文本文件，通常以`.sh`为扩展名。你可以使用文本编辑器创建脚本文件，如`vi`或`nano`。
3. 基本语法：
   - 注释：使用`#`符号来添加注释，注释将被Shell忽略。
   - 变量：在Shell编程中，你可以使用变量来存储和操作数据。变量名通常是大写字母，等号（=）用于给变量赋值，例如`name="John"`。
   - 输出：使用`echo`命令可以输出文本或变量的值到终端，例如`echo "Hello, World!"`或`echo $name`。
   - 输入：使用`read`命令可以从终端读取用户的输入，并将其存储到一个变量中，例如`read name`。
   - 命令执行：使用反引号（`）或`$()`来执行命令，并将其结果赋值给变量，例如`files=`ls`"或`files=$(ls)`。
4. 控制流结构：
   - 条件语句：使用`if`语句进行条件判断，根据结果执行不同的命令块。
   - 循环语句：使用`for`、`while`或`until`语句实现循环执行一系列命令的功能。
5. 函数：使用函数可以将一系列命令封装起来，并在需要时多次调用。函数有助于提高代码的重用性和可读性。
6. 参数传递：你可以在运行Shell脚本时传递参数，并在脚本中访问这些参数。使用特殊变量`$1`、`$2`等来引用传递的参数。
7. 文件处理：Shell编程也涉及文件的读取、写入和处理。你可以使用命令如`cat`、`grep`、``等来处理文件内容。

___

vmware虚拟机的网络设置

- 桥接模式
- nat模式
- usb网卡
- 笔记本

___

假如我是一个新接触Linux的小白，我的第一步、第二步、第三步都是要学啥呢？]

可以多去网上看看人家录制好的课程，看一看那些大佬们是如何讲解的，都讲解了哪些内容，学习一下人们的讲课风格，学过来然后讲出去。目前看到了[黑马的课程](https://www.bilibili.com/video/BV1n84y1i7td?p=11&vd_source=f06237b57d9754575c93eaa6db881c53),讲的很是小白，我突然意识到我的层次降的还是不够低，































# 1.11 工作记录

## 1.更新3588源码

```
rk3588-evb7-lp4-v10-linux.dts 
```



~~~
#include "rk3588-evb7-lp4.dtsi"
#include "rk3588-linux.dtsi"
#include "topeet_rk3588_config.dtsi"
~~~



#include "rk3588-evb7-lp4.dtsi"

~~~
#include "rk3588.dtsi"
#include "rk3588-evb.dtsi"
#include "rk3588-rk806-single.dtsi"

#include "topeet_screen_lcds.dts"
#include "topeet_camera_config.dtsi"
~~~

## 2.继续写vim

第1节 vim的三种工作模式

第2节 光标的移动

第3节 光标的移动进阶版

第4节 vim文本插入

第5节 vim保存和退出

第6节 vim文本删除

第7节 vim的复制、粘贴和剪切   

第8节 vim内容搜索

第9节 vim内容替换

第10节 标签页和窗口分割

## 3.总结

今天终于是将vim的那个文件写完了，讲解vim的文件，现在先确认一下最终的讲解路线，首先是讲解一下讲解的逻辑，



# 1.10 工作记录

昨天晚上和今天早上看了一下老师的视频，之前看的时候就没这个感觉，但是现在让我讲出来感觉就不一样了，当然也可能是看的次数多了，书读百遍其意自现，都有可能吧，但也确实确定了一个事情，任何一件事情，都应该要善于总结，而且最好是要讲出去，不然你可能学了也只是学了。

___

有了一个好的想法，在视频最开始讲解演示本节视频要讲解的内容，然后在视频的结束根据写好的文档过一遍讲解过的内容。这个逻辑感觉挺好的。

___

然后回到实际来，昨天晚上的vim多了几分内容，那个vim的文件需要内容的增加，就比如今天早上要学习的标签页、分页等等，都是需要改进的，今天的任务是确定vim的讲解文件内容，当然其实我学习的问题也不小，傲慢了，现在将那个三体的话重复一遍==弱小和无知并不是生存的障碍，傲慢才是==，确实傲慢了，就比如很看不起单词的跳转，以为只凭借上下左右移动就能万事无忧吗，还是守旧的心太强了，认为只要会这个方法，那么都可以，而实际上呢，也确实是可以的，但效率是真的弱，而且你还不知道有方法可以怎加效率，虽然你站在了巨人的肩膀上，但你的目光始终是向下的，所以你看的并不会更远，值得反思。

现在先根据老师的ppt来整理应该要讲解的内容。当然不能完全按照老师的来，我只是想看看我目前有什么是欠缺的，有什么是要给客户讲的，而又能怎样将内容以一个轻松的水平讲解出来。讲解先向后放，目前先去看内容。

____

当前内容如下所示：

- 第1讲：vim的三种工作模式
- 第2讲：移动光标
- 第3节：VIM的进入、保存和退出
- 第4节：文本编辑之删除单个字符
- 第5节：文本编辑之操作整行
- 第6节：文本编辑之插入.
- 第7节：撤消类命令
- 第8节：替换类命令
- 第9节：定位、跳转及文件状态
- 第10节：搜索类命令
- 第11节：配对括号跳转
- 第12节：替换命令
- 第13节：保存文件副本
- 第14节：复制粘贴文本
- 第15节：剪切文本
- 第16节：设置类命令的选项

我先自己来填充一下上面的内容。看看我自己的熟练程度：
~~~
- 第1讲：vim的三种工作模式
	
- 第2讲：移动光标
	
- 第3节：VIM的进入、保存和退出
	
- 第4节：文本编辑之删除单个字符
	
- 第5节：文本编辑之操作整行
	
- 第6节：文本编辑之插入

- 第7节：撤消类命令

- 第8节：替换类命令

- 第9节：定位、跳转及文件状态

- 第10节：搜索类命令

- 第11节：配对括号跳转

- 第12节：替换命令
	
- 第13节：保存文件副本

- 第14节：复制粘贴文本

- 第15节：剪切文本

- 第16节：设置类命令的选项

~~~



____

这里的vim还是不能只在这个文本里操作，还是边操作边写markdown比较好，直接操作谁看了都会懵，所以这个手册只是一个演示，实际的还是要markdown写出了。

___

~~~
光标的移动 可以加上数字

w: 将光标移动到下一个单词的开头
b: 将光标移动到前一个单词的开头
e: 将光标移动到下一个单词的词末
单词的移动也能加上数字

$: 将光标移动到当前行的行尾
0：将光标移动到当前行的行首

半屏滚动: ctrl+u/ctrl+d
全屏滚动: ctrl+f/ctrl+b


定位光标的位置
zz：将光标置于屏幕的中间
zt: 将光标移动到屏幕的顶部
zb：将光标移动到屏幕的底部

dw: 删除一个单词(从光标处到空格)
d2w: 删除从当前光标开始处的 2 个单词
d$: 删除从光标到一行末尾的整个文本
d0: 删除从光标到一行开头的所有单词

dd: 删除当前光标处的一整行=D
5dd: 删除从光标开始处的 5 行代码
dgg: 删除从光标到文本开头
dG: 删除从光标到文本结尾


y: 复制，p:粘贴
yw: 复制一个单词
y2w: 复制 2 个单词
y$: 复制从当前光标到行结尾的所有单词
y0: 复制从当前光标到行首的所有单词
yy: 复制一整行
2yy: 复制从当前光标所在行开始的 2 行
复制文本块
    1.首先进入 visual 模式：v
    2.移动光标选择文本
    3.复制与粘贴的操作
    
    
标签页的新建：tabedit file/tab split
标签页的切换: tabn/tabp
按键：gt/gT
标签页的关闭: tabclose 关闭当前的标签页，:tabonly

分割窗口
split/vsplit filename
窗口间跳转
ctrl+w w

close: 关闭一个窗口
qall: 退出所有窗口
qall!: 放弃修改，退出所有窗口
wqall: 保存并退出所有窗口
wall: 保存所有窗口
~~~

___

___



___

还是要思考讲解vim的逻辑连贯性，不能老师写啥就写啥，或者那个教程写啥就写啥，目前的初版已经差不多了，现在来规整其中的逻辑，其实那个文件的逻辑还可以的其实，就是将内容向里面填充就行了，但是不是也不能过于复杂呢？

~~~
第一节 三种模式（不需要更改）

第二节 光标的移动

第三节 光标的移动进阶版
	gg
	G
	ctrl + g
	w: 将光标移动到下一个单词的开头
    b: 将光标移动到前一个单词的开头
    e: 将光标移动到下一个单词的词末
    单词的移动也能加上数字

    %：匹配大括号、小括号、中括号从而跳转
    $: 将光标移动到当前行的行尾
    0：将光标移动到当前行的行首

    半屏滚动: ctrl+u/ctrl+d
    全屏滚动: ctrl+f/ctrl+b


    定位光标的位置
    zz：将光标置于屏幕的中间
    zt: 将光标移动到屏幕的顶部
    zb：将光标移动到屏幕的底部
    
第四节 vim文本插入

第五节 vim保存和退出

第6节 vim文本删除
	x 删除单个字符

    dw: 删除一个单词(从光标处到空格)
    d2w: 删除从当前光标开始处的 2 个单词
    d$: 删除从光标到一行末尾的整个文本
    d0: 删除从光标到一行开头的所有单词

    dd: 删除当前光标处的一整行=D
    5dd: 删除从光标开始处的 5 行代码
    dgg: 删除从光标到文本开头
    dG: 删除从光标到文本结尾
    
第7节 vim的复制、粘贴和剪切   

第8节 vim内容搜索

第9节 vim内容替换

第10节 标签页和窗口分割

~~~

第1节 vim的三种工作模式

第2节 光标的移动

第3节 光标的移动进阶版

第4节 vim文本插入

第5节 vim保存和退出

第6节 vim文本删除

第7节 vim的复制、粘贴和剪切   

第8节 vim内容搜索

第9节 vim内容替换

第10节 标签页和窗口分割











​	



# 1.9 工作记录

关于unix 和Linux的发展能尽可能的简洁就简洁，现在更重要的是理清楚最终要讲解的主线以及讲课的风格。

再来反思一下海之蓝所说的，海之蓝的意思是先有一个整体的菜单，这样客户在学起来的时候才不会一头雾水，不然，哪怕你的细节问题处理的再好，客户不懂的欣赏那也是没有意义的，其次是你讲解的风格，目前的想法是沿用狂神老师的风格，通过笔记的方式来讲解，然后一点一点的截图。通过截图的方式写手册，这是一个很好的方式，我需要再去看一看狂神的风格，总结一下。

- 第一节的课程大纲，简单的将整个课程要讲解的内容整体概述一下，以狂神的docker为例，他的大纲如下所示：

![image-20240109133055121](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091330183.png)

用手将要讲解的内容敲出来,客户看的舒服，当然我讲的也舒服，我应该是达不到狂神在讲课时候的等级了，现在其实就很疑惑人们为什么能这么流利的语言不用备课就能如此牛的讲解出来呢，还是训练的问题，菜就多练。

- 熟练运用markdown，文档内容和视频里的笔记内容不需要完全一致，甚至在视频里的笔记可以简单的写，只要你可以非常友好的讲解出来就行了，例如这个是在视频里的笔记，可以看到不能说十分的潦草吧，但是很简洁。
- ![image-20240109135501982](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091355139.png)

然后来看实际笔记里的内容，具体如下所示：

![image-20240109140007337](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091400446.png)

可以看到实际的手册资料可比视频里面讲解的时候详细的多，但是在视频里面都用通俗的语言讲解了出来。

目前总结的就这两个，我认为狂神老师也不应该是直接就能讲出来的，他也必然是现有的手册，而后面才有的视频，就算没有一个详细的手册也会有一个大体的框架，不然是没办法讲出来的。而我当前也是写好了手册，然后呢，就看到时候要怎样讲出来了，我的手册肯定不是稿子，这是给用户来看的，趁这个机会来真正的入门，这是一个很好的机会，希望你珍惜。

今天早上也说明了跟工作任务相匹配的情况下进步最快的，所以晚上要做什么，你懂了吗。

前面的内容差不多了，然后是不是要讲解vim了？我想应该是的，在tabby章节学习了远程SSH连接ubuntu，而我们要学习的第一个工具就是vim，apt安装就不管了。我要怎样讲解vim呢，其实vim提供了一个手册的，我目前的想法是讲这个手册进行修改，保留下我想要的部分。



















# 1.8 工作记录

新的一周，重新开始。

关注度也是存在问题的，这样吧，在上班的时候定一个小规矩，只有有人@你，即下方小企鹅闪烁才会看群，其他时候不看群，这个总是可以的吧。

仍旧是上周没有解决的问题，

问题 1.Linux的发展历史

问题2.Linux可以在哪些设备上运行

**笨方法学Linux**
https://edu.51cto.com/topic/2917.html?utm_source=acrt

**从零开始编译、构建自己的Linux实战视频课程**
https://edu.51cto.com/course/9283.html

上面两个视频看起来都很好，感觉可以买一下，看看吧，具体问题具体分析。

## 问题 1.Linux的发展历史

### 1.1 unix操作系统的历史

贝尔实验室的阁楼

肯·汤普森(Ken Thompson) 1969年花费了三周时间写出了内部测试版本的unix。C语言创始人。

丹尼斯·里奇 

道格·麦基尔罗伊 程序员和数学家，通过算法实现了很多好用的命令例如spll、diff、aph、 speak、sort、echo、tee

美国电话电报公司（AT&T）是一家美国电信公司，创建于1877年，曾长期垄断美国长途和本地电话市场。 AT&T在近20年中，曾经过多次分拆和重组。AT&T是美国最大的本地和长途电话公司， 总部位于得克萨斯州圣安东尼奥。

起因：
	麻省理工大学希望对当时的兼容分时系统CTSS进行升级，作为面向大众提供计算服务的信息处理工具，这套系统叫做“MULTICS”,但是麻省理工大学的能力不足以完成这个项目，于是联合了贝尔实验室和通用电气，但由于向MULTICS添加的功能太多也过于复杂，就形成了一个四不像，于是贝尔实验室就退出了这个项目。而肯·汤普森作为贝尔实验室的一员，在退出之后仍想搞操作系统，于是在一个PDP7的古老电脑上写出了太空旅行的游戏，游戏顺利完成之后发现只差三个部分就可以实现一个新的操作系统了，三个部分分别位用来创建代码的编辑器，用来将代码转为机器语言的汇编器和内核的外层，一周写一个三周就可以实现了。于是在1969年unix诞生了。

然后就是肯·汤普森和丹尼斯·里奇 对unix的不断修改和优化，后面出现了不同的版本，第六版和第七版是两个重要的里程碑，分别发布于1975年和1979年，这两个版本一个是正式对外发布的版本一个是后面遍地开花的unix分叉点，C语言和C++也是在这两个版本中诞生的。

在unix之前，内存是非常昂贵的，2kb的内存就可以卖到1.6万美元，所以操作系统只能使用汇编语言来写，系统之间也互不兼容，直到70年代基于半导体和集成电路的新内存技术普及，才拉低了内存的制造成本，促使C语言这种高级语言的应用成为了可能 ，第6版本的unix内核就是由9000行的C语言和700行的汇编语言写成的，C语言让系统的维护和修改变的容易，也让其更方便的移植到不同的计算机上，打破了不同架构计算机操作系统互不兼容的局面，到了90年代几乎所有的CPU系统都是围绕C语言和unix来设计的。

1975年肯·汤普森带着unix第六版在加州大学教授操作系统课程，一位叫比尔乔伊的研究生修改了unix的本地版本，添加了一些自己的程序，包括vi编辑器，csh以及TCP/IP协议，以及至今仍在使用的TCP/IP网络接口，后来它修改的版本演化成了unix最重要的分支bsd，当时unix向高校提供免费的版权，但对于商用版本需要收取2万美元的授权费。从第七版开始，unix有了两条发展线，官方商业版本和BSD版本，BSD英文全称是Berkeley Software Distribution，即伯克利软件发布。1984年AT&T即贝尔实验室的母公司，看到unix有利可图，申请了unix的商标以及发布了第一个商业版本，并指定了unix的使用标准，而bsd进行了大洗稿，对unix进行了重构，用新的代码重写了相同的功能， 还在1991年发布了不包含AT&T专利材料的unix版本，从而打赢了与AT&T的官司，并建立起了庞大的bsd家族，Unix的发展树，如下图所示：

<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401081327753.jpeg" alt="img" style="zoom:200%;" />

而bsd的创作者比尔乔伊，也凭借着BSD一举创建了sun公司。

后来年仅21岁的芬兰大学生（linus Torvalds）因为不满足于unix的限制性许可，同样决定动手开发一个“类unix系统”，就这样Linux出现了。

Linux免费、开源，相较于windows更安全

unix是要收费的，所以Linux的应用十分广泛

### 1.2 GUN运动

在20世纪70年代末，AT&T（美国电话电报公司）对UNIX操作系统的源代码使用做出了限制，禁止将其提供给学生群体使用。AT&T收回了UNIX的版权，并不再将其开源。

由于这一限制，广大用户和学校面临着没有可用操作系统的困境。而GNU项目始于1983年，由理查德·斯托曼（Richard Stallman）发起。斯托曼是一位计算机科学家和软件自由活动家，他对当时UNIX操作系统的私有化和限制使用感到担忧。为了提供一个自由、开放的操作系统，他决定创建一个完全由免费软件组成的类Unix计算机操作系统，这就是GNU操作系统。

GNU是一个递归缩写，意味着"GNU's Not UNIX"（GNU不是UNIX），强调了GNU操作系统与UNIX的区别。斯托曼的目标是创建一个功能完备的操作系统，与UNIX兼容，并保证用户的自由和权益。

GNU项目的核心是开发一系列自由软件工具，如GNU编译器套件（GCC）、GNU调试器（GDB）、GNU Bash（命令行解释器）等。这些工具赋予开发者和用户自由地运行、复制、学习、修改和分发软件的权利。

然而，GNU项目的发展遇到了一个重要的挑战：缺少一个核心组件，即操作系统内核。为了解决这个问题，自由软件基金会与芬兰学生林纳斯·托瓦兹（Linus Torvalds）合作，将Linux内核与GNU工具链结合，形成了一个完整的自由操作系统，即Linux操作系统。这个组合被广泛称为Linux，但准确来说应该是GNU/Linux。

Linux内核由林纳斯·托瓦兹（Linus Torvalds）在1991年发布，并成为一个免费公开的代码项目。Linux内核的开放性吸引了全球各地的开发者参与其中，共同贡献代码和改进。这使Linux成为影响最广泛的开源软件项目之一。

Linux内核作为操作系统的核心，为不同的开发团体（包括开源社区、企业、个人等）提供了一个基础平台。这些团体在Linux内核的基础上进行一定的修改和补充，加入图形界面（GUI）和应用等部分，形成了各种不同的Linux操作系统发行版。

不同的Linux发行版之间存在衍生关系，形成了几大家族，如Red Hat、Debian等。每个家族内部又衍生出一些著名的版本，如Ubuntu、openSUSE、CentOS、Red Hat Enterprise Linux、Fedora等。

这些Linux发行版在功能和特性上可能有所差异，但它们都共享Linux内核的基本功能和特性。它们提供了各种工具和应用程序，用于满足不同用户的需求，例如桌面操作系统、服务器操作系统、嵌入式系统等。

Linux发展时间线：

https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg

### Linux应用领域

Linux操作系统主要有三大应用领域：企业级服务器、嵌入式和个人桌面。

1. 服务器领域：Linux在企业级服务器领域的应用非常广泛。许多大型硬件厂商都支持Linux操作系统，并且大型和超大型互联网企业都在使用Linux作为服务器端的程序运行平台。Linux具有免费、稳定和高效等特点，在服务器领域得到了广泛应用。
2. 嵌入式领域：近年来，Linux在嵌入式领域的应用也得到了大幅提升。它被广泛应用于机顶盒、数字电视、网络电视、手机等嵌入式设备中。Linux在嵌入式领域的优势包括稳定性、对网络的良好支持性和低成本等。
3. 个人桌面领域：在个人桌面领域，Linux在过去一直面临着传统Linux界面简单、操作复杂、应用软件较少的挑战，一直被Windows所压制。然而，近年来随着Ubuntu、Fedora等优秀桌面环境的兴起以及各大硬件厂商对Linux的支持增加，Linux在个人桌面领域的市场份额逐渐增加。根据StatCounter的数据，Linux在全球桌面端的市场份额从2012年的0.85%上升至2019年的1.68%。

## 问题2 Linux的硬件限制

MMU，感觉MMU的概念还比较遥远，这里就先按下不表。

但是上面的Linux发展历史确实可以好好的整理一下，我要如何讲解才对的，将一些重要的地方留下，而一些无关紧要的地方看情况删掉，毕竟侧重点是不一样的。关于Linux的介绍这个地方，目前看来是必须要讲解的，但是具体要怎样讲解这是一个问题，讲故事的方式，要如何才能生动呢？





































# 1.6 工作记录

​	先来找自己的一个原因，这些天晚上都睡不着了，目前猜测的原因是早上起的太晚了，就导致晚上也不是很困，失去了之前的那种感觉了，所以问题还是出在早起这个地方，所以早起的闹钟不能没有，这个是必须的，以后提前到早上六点，一切等搬家吧。

搬家这个东西，我还在考虑是怎么个搬家的方法，可以明天先把一些书搬一下，但我又感觉太早了，怎么办呢，还是算了吧，今天回家规划一下最终要如何搬，搞一个详细的搬家计划，两个行李箱怎么说也能把书搬完，而至于其他的东西，慢慢的搬吧，挺好的，或者今天晚上就看着搬一下，这倒也挺好的，这样自己一点一点的搬，最省心，但目前看着货拉拉的钱，倒也很便宜，也才二百呀，我心动了，还是货拉拉吧，目前定的时间是1月21号，但前提是我需要将这些都打包好，倒也还可以把。而至于需要有多少的箱子啥的，这个待定，今天回家就先开始收拾着，不是很着急，但说的21号就21号搬完，遵守规则，买了三个箱子，感觉倒也差不多够了，没啥东西，就先这样吧，从今天回家就开始收拾，有些不需要的东西，该扔就扔吧。行了，目前就先这样吧，今天的任务是继续写基础知识的手册，新的一天加油。

___

___

___

- 海之蓝说的很正确，说的很对，对于一个初学者来说真正应该懂的是什么？是一些懵懵懂懂的概念，而并不是巴拉巴拉的讲几节课，其实还是没能做到与看视频的人做到共情，我列的第一节内容是为什么使用虚拟机，但客户真的能理解吗？我将这个放第一节真的合适吗？答案是显而易见的，那肯定是不合适的，海之蓝说的是对的，应该要从Linux开始介绍：

![image-20240106162424562](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061624608.png)

虽然海之蓝说的并不全对，但至少让我认识到，当前的框架是不对的，重新理解一下，就跟为什么用虚拟机一样，虚拟机充当的角色又是什么？所以这个概念需要懂呀。目前就先解决这个问题。

- 引言很重要，其实也就是下面提到的那个大象，先让客户将大象看一遍，随后再来介绍四肢或者，你把人蒙着眼睛，摸到的大象，和先让他看看大象再去摸，完全不一样

  ![image-20240106170802079](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061708123.png)

- 进度条，这个东西很重要，我认为在我的视频里必须要加上这个，https://www.bilibili.com/read/cv27533632/

- shell编程、系统编程、makefile番外

- https://github.com/jaywcjlove/linux-command  github学习命令的一个推荐

___

___

___

问题的根本来了，也是最应该解决的一个问题，为什么要讲解Linux呢？我们为什么要学习Linux？Linux的作用是啥？究竟什么样的配置才能跑起来Linux？

# 1.5 工作记录

​	昨天将3588和3588邮票孔的编译手册进行了更新，看到有客户对我做的东西做出了肯定，我就会感觉到莫名的高兴：

![image-20240105140054624](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401051400695.png)

![image-20240105140220997](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401051402044.png)

明天又要OKR了，其实这些任务倒也还好，继续整理RK3588S的手册，其实归根结底也没有啥，尤其是我将名称修改了之后，这样三个系统的截图就可以通用了，倒是可以省去很多的事情，我很喜欢，最后是那个打包脚本，极大的提高了我的镜像更新速度，感觉还好。

行了，闲杂事情终于是干完了，然后回归主线任务，不能一直的向后拖呀，我是怎么想的呢，一切都要循序渐进，做完一件事情之后再去做另一件事情，然后呢，也还行，今天和明天也不用技术支持，先将写好的markdown打磨一下，然后继续向后学习。

# 1.4 工作记录

​	行了，上午技术支持又搞了好久，这一周又马上过去了，可真的太快了，我的测试手册还有很多要写的,先把测试手册写完再说。

# 1.3 工作记录

一天的技术支持呀，目前感觉还行，边技术支持边学习，或者将3588的那个源码也推进一下，也不是不行，算了吧，3588的以后再说了，目前还是继续写昨天没有完成规划吧，虽然技术支持的问题有些多，昨天推完源码，今天就技术支持，整理一下问题也挺好的。

首先在写之前，我必须自己先掌握了对应的知识，自己都没掌握的知识，更别说给别人讲解了

在自己学习完成之后，首先要写根据要讲解的内容写一个第一版本的手册，用来进行学习的巩固和完善，也为后面的给用户看的手册创造一个还可以的蓝本，

1. 学习要讲解的内容
2. 根据学习到的内容写第一遍的markdown手册
3. 根据第一遍的markdown手册写给用户看的手册
4. 录制视频

上面就是一个整体的步骤，想到了一个很好的办法，我可以有两个屏幕，一个屏幕用来存放已经写好的markdown，而另一个屏幕用来存放空白的markdown，这样的话我讲解的过程中就可以直接复制相应的内容，从而对一个空白的markdown进行完善，这个想法很不错，如果我仅仅知识凭借稿子来进行推进，那可真的太弱了，我认为不应该局限于此，这里是必须要推进的一个点，总是要有进步的，你说是吗。

 为什么使用Linux操作系统进行编译？

我好像一直都没明白这个问题，好像自然而然就将这个问题给遗忘了，忘记了这个才是最根本的那一个问题，无论是安装虚拟机软件vmware，还是安装ubuntu22，虚拟机的目的我知道了，为了一个电脑上搞两个系统嘛，这个Linux系统的最终目的是什么，那我平常都在Linux系统中做什么呢？

源码的编译  这个是大头，其他的一些操作好像也仅仅是为了源码的编译而进行打工的，更深层次的原因等等再深究。

应用程序的编写，其实这个也应该算是编译的另一方面的应用。

其他是不是就没了，好像归根结底就上面这两个实际用处，除了编译还是编译，而透过现象看本质，编译需要的是编译环境，也需要源码的支持，但这里我就不是很理解了，到底是谁依赖的谁呢？环境其实就在那个地方，源码其实是根据编译环境而进行编写出来的，编译凭借的有是什么呢？是一些编译工具、是交叉编译工具链，其他是不是也就没了，那到底是谁成就了谁呢？

首先来看这个问题：不能再windows下进行内核的编译吗？

在一般情况下，Windows 操作系统本身并不支持编译 Linux 内核。这是因为 Linux 内核的编译通常需要使用 Linux 环境中的工具链和库文件，而这些工具和库在 Windows 环境中并不直接可用。

但是，有几种方法可以在 Windows 下进行 Linux 内核的编译：

1. 使用虚拟机：你可以在 Windows 上安装虚拟机软件（如 VirtualBox、VMware）并创建一个运行 Linux 操作系统的虚拟机。在虚拟机中，你可以设置 Linux 开发环境并进行 Linux 内核的编译。
2. 使用 Windows Subsystem for Linux（WSL）：WSL 是 Windows 10 中的一个功能，它允许在 Windows 上运行 Linux 子系统。通过启用 WSL 并安装适当的 Linux 发行版（如 Ubuntu），你可以在 Windows 上使用类似于 Linux 的环境进行内核编译。
3. 使用 Docker：Docker 是一种容器化技术，它可以在 Windows 上运行包含 Linux 环境的容器。你可以使用 Docker 在 Windows 上创建一个包含 Linux 环境的容器，并在容器中进行 Linux 内核的编译。
   其实这些解决方法可以不看，重要的是上面那个解释为什么要使用Linxu开发环境了：==编译通常需要使用 Linux 环境中的工具链和库文件==

在 Windows 环境下编译安卓或其他开发板的源码存在一些挑战和限制，主要有以下几个原因：

1. 编译工具链和依赖项：编译安卓或其他开发板的源码通常需要使用特定的编译工具链和依赖项，这些工具链和依赖项在 Windows 上可能不直接可用。例如，安卓源码编译需要使用 GNU 工具链（如 GCC、Make）、特定版本的 Java Development Kit（JDK）等，这些工具在 Windows 上需要额外配置和设置。
2. 平台差异：源码编译通常依赖于底层操作系统的特性和接口。安卓源码和其他开发板的源码通常是为 Linux 或类 Unix 环境设计的，因此在 Windows 上进行编译可能会遇到平台差异的问题。例如，文件路径分隔符、环境变量、系统调用等在 Windows 和 Linux 之间有所不同，需要进行相应的适配和调整。
3. 软件包管理：源码编译通常需要安装和管理各种依赖的软件包和库。在 Linux 环境中，通常使用包管理器（如 apt、yum）来管理软件包，而在 Windows 上没有类似的集中式包管理系统。这可能导致在 Windows 环境下手动安装和配置依赖项变得更加复杂和困难。



我们使用Linux操作系统主要是用来进行编译的，由于开发板上使用的就是Linux操作系统，所以

# 1.2 工作记录

==新的一年，天天开心==

**==假如你某一天失去了生命的意义，那就去码头整点薯条吧==**

![image-20240102110028735](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401021100799.png)



这是现在整理完成的，但是还是没想明白要怎样讲解出来，目前的想法是跟狂神一样，使用markdown来进行讲解，但是会遇到一些问题，现在将这些问题进行陈述，狂神的课程是以markdown为基础的，而王老师或者其他的人，也并不是完全从0开始，而是写了一个大纲，我要从零开始写markdown呢，还是写好markdown跟着markdown来讲解呢，这是一个很大很大的问题。亦或者我写一个markdown，然后讲解的时候再来一个markdown，好像这个才是最合理的。最终有没有文档其实无所谓，只要有这个markdown文件就足够了，有一个可以直接用来做对照的markdown，用于后期客户的复习，除此之外还能给我讲课提供一个很好的步骤，贯穿讲解的逻辑，当然讲课的时候不需要完全跟写好的手册一样，随心而已。

所以在讲课之前一定是要整理好一个能给客户看的markdown，这样就相当于文档了，也挺好的。

_______________

____

____

____

____

搞了一天的3568编译脚本，哈哈还挺有成就感的，我很高兴，但是人们呢怎么可以一直在舒适区呆着呢？就像温水里的青蛙，逐渐的死去，但事实真的就是如此吗，其实相对于之前来看，现在算是舒适区吗，当然不算，所以位置是相对的呀，你说对吗，就跟中午看的那个短片动画里讲的，生活的重复，带来的并不仅仅是坏处，观点不同罢了。

所以接下来的日子依然要继续呀，看上面的第一段话，也写出来了未来一段路程的规划。

首先在写之前，我必须自己先掌握了对应的知识，自己都没掌握的知识，更别说给别人讲解了

在自己学习完成之后

1. 学习要讲解的内容



# 12.29 工作记录

## 1.继续写要讲解的内容

终于算是将前面一小部分的内容搞定了，其实也不能说是搞定，最少是相关的内容算是搞完了，然后便是要怎样讲述出来的问题了

## 2.思考

其实现在还差的很远呢，无论是内容、方向亦或者是框架都是要完善的，甚至你连最基本的核心理念都没有搞明白，不管要做什么，最基本的那个中心点是不能变的，所以现在的目标是找到这个中心点，==这次的问题不是为什么要录制这个视频了，而是要录制的内容应该达到什么样的程度？==

对，这一次总结的很对，你要先确定上面的问题，这两天一直在确定前几个小节的内容，只有在有了一定的内容之后，才能有一个认识，否则你连想到这个问题的资格都没有，所以前面做的所有的东西都是有用的，前面的努力并没有白费，而当今要做的是为了看清前面的路。

其实我疑惑的点就在于，我要讲解到怎样的程度，还有我要以怎样的方式讲出来？其实后面这个可以等等再谈，现在的重点是要讲解到怎样的程度，如果仅仅是讲解这些最基础的东西，那么之前的那个类型的视频为什么又要替换呢？现在我已经忘记了为什么要录制这个视频的初衷，我来回忆一下把？

1. 之前的视频是以imx6ull为中心，去讲解的，而现在中心已经变了，也不能仅仅只是以3568为核心，更重要的是讲究通用性，如果不考虑通用性的话，现在的视频完全没有重新录制一遍的必要，但是通用性要到怎样的程度呢，还有相应的深度又该如何呢？

   好难呀，找不到做这个东西的意义了，那是不是我的出发点就是错的呢，是不是这个视频不需要被替代，而仅仅只是需要一个新的视频ne



# 12.28 工作记录

## 1.ssh学习

虽然不学习这些基础知识，我也能用，或者也能根据网上的教程配置免密登录啥的，但是我认为学习不应该仅仅止于此，还应该有自己的思考，自己的想法以及一些更深层次的学习。

### 1.1 初识SSH

SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。

SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。

### 1.2 SSH 工作原理

首先为什么要有SSH呢，无外乎是想要通过一种安全的方式进行安全的数据传输，当前对于数据加密的方式有两种，分别为对称加密和非对称加密.

所谓[对称加密](https://so.csdn.net/so/search?q=对称加密&spm=1001.2101.3001.7020)，指加密解密使用同一套秘钥。如下图所示：

![image-20231228112322496](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281123576.png)

 对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：如何安全的保存[密钥](https://so.csdn.net/so/search?q=密钥&spm=1001.2101.3001.7020)呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。

两个密钥的特性：[公钥](https://so.csdn.net/so/search?q=公钥&spm=1001.2101.3001.7020)加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。

![在这里插入图片描述](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281124987.png)

- 1.远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。
- 2.Client使用这个公钥，将密码进行加密。
- 3.Client将加密的密码发送给Server端。
- 4.远程Server用自己的私钥，解密登录密码，然后验证其合法性。
- 5.若验证结果，给Client相应的响应。

[私钥](https://so.csdn.net/so/search?q=私钥&spm=1001.2101.3001.7020)是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。

## 3. 基于口令的认证

SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息：

```html
The authenticity of host 'ssh-server.example.com (12.18.429.21)' can't be established.

RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.

Are you sure you want to continue connecting (yes/no)?
```

上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？

> 之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。

如果输入yes后，会出现下面信息：

```html
Warning: Permanently added 'ssh-server.example.com,12.18.429.21' (RSA) to the list of known hosts. 

Password: (enter password) 
```

该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码，之后的流程就按照图1-3进行。

## 4.基于公钥认证

在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下：

![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281129257.png)

- 1.Client将自己的公钥存放在Server上，追加在文件authorized_keys中。
- 2.Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R)
  ，然后将加密后信息发送给Client。
- 3.Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。
- 4.Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。
- 5.Server端会最后比较Digest1和Digest2是否相同，完成认证过程。

>  在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH
> keys设置视图：
>
> ![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281129188.png)
>
>  

## 5.SSH实践

生成密钥操作

经过上面的原理分析，下面三行命令的含义应该很容易理解了：

```shell
$ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa

$ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys

$ chmod 0600 ~/.ssh/authorized_keys
```

ssh-keygen是用于生产密钥的工具。

- -t：指定生成密钥类型（rsa、dsa、ecdsa等）
- -P：指定passphrase，用于确保私钥的安全
- -f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）
  首先看下面~/.ssh中的四个文件：

![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281129198.png)

- 1.id_rsa：保存私钥
- 2.id_rsa.pub：保存公钥
- 3.authorized_keys：保存已授权的客户端公钥
- 4.known_hosts：保存已认证的远程主机ID（关于known_hosts详情，见文末更新内容）

 四个角色的关系如下图所示：

![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281129206.png)

> 需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。

登录操作

```shell
# 以用户名user，登录远程主机host

$ ssh user@host

# 本地用户和远程用户相同，则用户名可省去

$ ssh host

# SSH默认端口22，可以用参数p修改端口

$ ssh -p 2017 user@host
```

## 6. 总结

本文以图文方式对SSH原理进行解析（主要指[远程登录](https://so.csdn.net/so/search?q=远程登录&spm=1001.2101.3001.7020)，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。

**下面是新增的更新：**

1. known_hosts中存储的内容是什么？
   known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个secret, unique ID, called a host key。
2. host key何时加入known_hosts的？
   当我们第一次通过SSH登录远程主机的时候，Client端会有如下提示：

```shell
Host key not found from the list of known hosts.

Are you sure you want to continue connecting (yes/no)?
```

此时，如果我们选择yes，那么该host key就会被加入到Client的known_hosts中，格式如下：

```shell
# domain name+encryption algorithm+host key

example.hostname.com ssh-rsa AAAAB4NzaC1yc2EAAAABIwAAAQEA。。。
```

​    3.为什么需要known_hosts？

最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（man-in-the-middle attack）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。

> 这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到中间人攻击吗？这可能只是安全性和可操作性之间的折中吧。

## 2.typora学习



### 简介

Typora 是一款轻量级 Markdown 编辑器。它与其他 Markdown 编辑器的主要区别在于采用了即时渲染技术，将写作与预览窗口相结合，为用户提供所见即所得的编辑模式。Typora 支持 Markdown 的各种基础语法，快捷键操作，是一款非常易用的 Markdown 编辑器。

此外，Typora 删除了预览窗口、模式切换程序、标记源代码的语法符号以及所有其他不必要的干扰，将它们替换为真正的实时预览功能，专注于内容本身。它拥有 Windows、macOS 客户端，界面简洁优美，可算作一款 Windows 下难得的好看、优美的客户端。

总的来说，Typora 是一款功能强大、轻便简洁的 Markdown 编辑器，适合需要写作和编辑 Markdown 文档的用户使用。

### 块元素

段落和换行符
段落只是一行或多行连续的文本。在 markdown 源代码中，段落由多个空行分隔。在Typora中，您只需按下 Return 即可创建新段落。

按 Shift + Return 可创建单个换行符。但是，大多数 markdown 解析器将忽略单行中断，要使其他 markdown 解析器识别您的换行符，可以在行尾留下两个空格，或者插入 

### 标题

标题在行的开头使用1-6个＃字符，对应于标题级别1-6。例如：

```
# 这是一级标题

## 这是二级标题

###### 这是六级标题
```

在typora中，输入’＃’后跟标题内容，按下 `Return` 键将创建标题。

### 引用文字

Markdown 使用电子邮件样式>字符进行块引用。它们表示为：

> 这是一个有两段的块引用。这是第一段。
>
> 这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

> 这是另一个只有一个段落的块引用。有三个空行分隔两个块引用。

~~~

> 这是一个有两段的块引用。这是第一段。
>
> 这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.


> 这是另一个只有一个段落的块引用。有三个空行分隔两个块引用。
~~~

在typora中，只需输入’>’后跟引用内容即可生成块引用。Typora将为您插入正确的“>”或换行符。通过添加额外级别的“>”允许在块引用内嵌入另一个块引用。

### 列表

输入 `* list item 1` 将创建一个无序列表，该 `*` 符号可以替换为 `+` 或 `-`.

输入 `1. list item 1` 将创建一个有序列表，其 markdown 源代码如下：

~~~
## 无序列表
*   红色
*   绿色
*   蓝色

## 有序列表
1.  红色
2. 	绿色
3.	蓝色
~~~

*   红色
*   绿色
*   蓝色

1.  红色
2. 	绿色
3.	蓝色

### 任务列表

任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：

~~~
- [ ] 这是一个任务列表项
- [ ] 需要在前面使用列表的语法
- [ ] normal **formatting**, @mentions, #1234 refs
- [ ] 未完成
- [x] 完成
~~~

- [ ] 这是一个任务列表项
- [ ] 需要在前面使用列表的语法
- [ ] normal **formatting**, @mentions, #1234 refs
- [ ] 未完成
- [x] 完成

### （栅栏式）代码块

Typora仅支持 Github Flavored Markdown 中的栅栏式代码块。不支持 markdown 中的原始代码块。

使用栅栏式代码块很简单：输入```之后输入一个可选的语言标识符，然后按`return`键后输入代码，我们将通过语法高亮显示它：

~~~
这是一个例子：

```
function test() {
  console.log("notice the blank line before this function?");
}
```

语法高亮：
```ruby
require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
```
~~~

这是一个例子：

```
function test() {
  console.log("notice the blank line before this function?");
}
```

语法高亮：
```ruby
require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
```

### 水平线

输入 `***` 或 `---` 在空行上按 `return` 键将绘制一条水平线。

### 目录 (TOC)

输入 `[toc]` 然后按 `Return` 键将创建一个“目录”部分，自动从文档内容中提取所有标题，其内容会自动更新。

### 强调（斜体）

Markdown 将星号 (`*`) 和下划线(`_`) 视为强调的指示。用一个 `*` or `_` 包裹文本将使用HTML `<em>` 标签包裹文本。例如：

*11111*

_11111_

### 粗体

用两个 * 或 _ 包裹的文本将使用HTML `<strong>` 标签包裹，例如：

**1111**  

__1111__

### 删除线

GFM通过添加语法来创建删除线文本，标准的Markdown中缺少该文本。

`~~错误的文字~~` 变成 错误的文字。

~~11111~~

### 下划线

下划线由原始HTML提供支持。

`<u>下划线</u>` 变成 下划线

<u>下划线</u>



<blockquote alt="info"><p>信息引用块</p></blockquote>

<blockquote alt="warn"><p>警告引用块</p></blockquote>

<blockquote alt="danger"><p>危险引用块</p></blockquote>

<blockquote alt="success"><p>成功引用块</p></blockquote>

上面这个主题的这些还是不行，我还是没有实际用到的心。等后面再熟练的时候吧

# 12.27 工作记录

## 1.在ubuntu22上测试3568的Linux编译

https://zhuanlan.zhihu.com/p/664801947

不行，3568的4.19buildroot还是报错了，就这样吧，但是使用docker就非常不错。

## 2.学习vim

最近的两天晚上一直都有事情，所以也就没有学习，vim是非常非常重要的，求索之心不能停止，今天仍旧是用vimtutor来进行学习。

### 第0讲 vim的四种模式

---

vim总共有四种模式，分别为命令模式、编辑模式、末行模式以及可视化模式。

当我们使用vim打开文件之后，默认就是命令模式，可以在命令模式下通过一系列的命令来完成复制、粘贴、删除、替换等复杂操作，具体的命令后面会讲解，这里

输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑，左下角显示 “插入”字符就表示在编辑模式。

按下ESC退出按键可以从编辑模式回退到命令模式

在命令模式下输入**冒号**(shift按键加L右边的按键，我记得我第一次学习的时候就找不到，怎么也进入不了末行模式)可以进入末行模式，末行模式可以通过输入命令进行查找、替换、保存、退出等操作。

在命令行模式下通过输入v可以进入可视化模式，可以做一些列选操作，等后面用到了再进行详细说明。

___

vim总共有四种模式，分别为命令模式、编辑模式、末行模式以及可视化模式。

☆ 命令模式
使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。

☆ 编辑模式
在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑

☆ 末行模式
在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作

☆ 可视化模式
在命令模式下输入冒号:即可进入末行模式可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）

### 1.1：移动光标

```
             ** 要移动光标，请依照说明分别按下 h、j、k、l 键。 **                                            
                                                                                                             
             ^                                                                                               
             k              提示： h 的键位于左边，每次按下就会向左移动。                                    
       < h       l >               l 的键位于右边，每次按下就会向右移动。                                    
             j                     j 键看起来很象一支尖端方向朝下的箭头。                                    
             v                                                                                               
                                                                                
```

==我用vim这么久都感觉这个很怪异，不是很习惯，我个人更倾向于小键盘的上下左右。==

### 1.2 VIM的进入和退出

第零节已经讲解过了，进入vim之后默认就是命令模式，命令模式下输入冒号，可以进入末行模式，在末行输入q就可以退出vim。

```
  1. 按键(这是为了确保您处在正常模式)。                                                                 
                                                                                                             
  2. 然后输入：                 :q! <回车>                   
```

### 1.3 文本编辑之删除

​	在命令模式下输入x即可删除文本。

### 1.4文本编辑之插入

在命令模式下输入i即可进入编辑模式，从而开始内容的编辑。

### 1.5文本编辑之添加

在命令模式下输入a同样可以进入编辑模式，从而开始内容的编辑。

### 1.6编辑文件

如果在末行模式下直接使用q!退出并不会保存修改之后的内容，在末行模式下w可以保存编辑之后的内容

### 2.1：删除类命令

dw可以删除单个单词

### 2.2 更多删除类命令

d$表示从当前删除到末行

### 2.3  使用计数指定动作

数字+w表示向后跳两个单词

数字+e表示跳到后三个单词的末尾

数字0表示到行首

### 2.4 使用计数以删除更多

d + 数字 + w 删除多个单词

### 2.5 删除整行

数字+ dd可以删除 数字的行数

### 2.6 撤消类命令

u可以撤销之前的操作，单个操作、单个操作撤销

而大写的U可以撤销全部的操作

ctrl+r可以撤销掉撤销命令~

### 3.1 置入类命令

使用dd命令删除之后，里面的内容其实被保留在了一个寄存器当中，这时候使用p命令可以将该内容粘贴置入

### 3.2 替换类命令

如果想要替换某一个字母，可以使用 r + 要替换的字母即可

### 3.3 更改类命令

cw和ce都可以删除到从当前位置到单词末尾，并进入编辑模式

### 3.4 使用c更改更多

c + 数字 + 操作

例如c2w，表示删除俩单词，然后进入编辑模式

c$表示删除到末尾，然后进入编辑模式

### 4.1 定位及文件状态

输入 CTRL-G 显示当前编辑文件中当前光标所在行位置以及文件状态信息

![image-20231227141310437](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312271413526.png)

输入大写的G会跳转到最后一行

输入gg会跳转到第一行

数字 + G 会跳转到数字指定的行

### 4.2搜索类命令

/ 加上一个字符串可以用以在当前文件中查找该字符串（也不用非要进入末行模式，之前的认知是错的）

要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字符串，请输入大写 N 即可

/是正向查找，而？是反向查找

要回到您之前的位置按 CTRL-O (按住 Ctrl 键不放同时按下字母 o)。重复按可以回退更多步。CTRL-I 会跳转到较新的位置

### 4.3 配对括号的查找

输入 % 可以查找配对的括号 )、]、}

这个命令好呀，我靠，设备树或者一个函数很长了，都找不到开始和结束，这个命令很牛

### 4.4 替换命令

输入 :s/old/new/g 可以替换 old 为 new

这里的冒号指的是在末行模式下输入，后面才是要输入的内容。

s/old/new 表示只替换一行第一个匹配的字符串

s/old/new/g 表示替换一行全部的匹配字符串

s/old/new/gc 表示替换之前要一一询问

如果在s前加上%则表示替换全文匹配的，不在局限于一行

%s/old/new 表示替换全文第一个匹配的字符串

%s/old/new/g  表示替换全文匹配的字符串

%s/old/new/gc 表示替换全文匹配的字符串,但是替换前需要一一询问

### 5.1 在 VIM 内执行外部命令的方法

输入 :! 然后紧接着输入一个外部命令可以执行该外部命令。

这里以ls命令为例进行演示，具体如下所示：
![image-20231227143600007](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312271436078.png)

### 5.2 关于保存文件的更多信息

之前学习的w只是用来保存当前文件，而w + 文件名称，可以将当前文本保存到新的文件

### 5.3 一个具有选择性的保存命令

输入v可以进入可视模式，然后移动光标，移动之间的内容就被选中了，这时如果再用5.2中的命令进行保存，保存的就仅仅是选中的内容，也使用d删除选中的内容，

### 5.4 提取和合并文件

使用 r + 文件可以提取外部文件的内容并将其插入光标处，除此之外还可以插入外部命令

r !ls 可以读取 ls 命令的输出，并把它放置在光标下面

### 6.1 打开类命令

输入 o 将在光标的下方打开新的一行并进入插入模式

输入 O 将在光标的上方打开新的一行并进入插入模式

### 6.3 附加类命令

输入 a 将可在光标之后插入文本

a、i 和 A 都会带您进入插入模式，惟一的区别在于字符插入的位置

### 6.4 另外一个置换类命令的版本

输入大写的 R 可连续替换多个字符

### 6.5 复制粘贴文本

使用操作符 y 复制文本，使用 p 粘贴文本

### 6.6 设置类命令的选项

设置可使查找或者替换可忽略大小写的选项

set ic  **Ignore Case，忽略大小写**

要禁用忽略大小写，请输入： :set noic

set hlsearch可以让搜索到的内容高亮

## 3.讲解内容框架整理

首先一个问题我都要讲哪些内容？讲到什么程度才算合格？或者这个视频的定位是什么?找准自己的位置我认为是最重要的一点。

### 	第一个问题，为什么要录制这个视频？

其实我是一个很自私的一个人，但是范围感很低，所以基本上做任何事情都乐于接受，就算不接受，很快也就转变思想了，也不知道为啥会成为这个样子，不能说好也不能说坏，但也就那个样子，有些东西也不是一朝一夕就能改变的，而且总要迈出第一步，就像书中写的那样，并不是做一个完全的计划，而是开始做一件事情，在做这件事情的同时，一步一步的弥补自己所欠缺的问题，反过来讲，你认为将一切都做好之后再开始，这样一定就算是对的吗，很多时候你以为的只是你以为的，跟实际差别其实挺大的。所以目前最正确的方法其实就是，写好一个大纲，写好一个手册，然后开始根据这个大纲适当的补充内容，最后录制出来对应的视频。

上午学习了一下vim，你之前自以为vim用的还可以，现在呢，你还敢这么说吗，没有见识过那些牛人，就开始飘，可实际上呢，差的真的不是一点半点，所以那句话说的对，==弱小和无知并不是生存的障碍，傲慢才是==

下面回归正题，录制这个视频的最根本原因还是因为我喜欢，我其实挺喜欢讲课的，将一个东西从我嘴上讲出去，我会很高兴的，有一种成就感和自豪感。并且在这个过程中我还能学习到之前忽略的一些知识，从而提高了自己。上面是从我自己的角度上出发，进行考虑的，然而呢，公司为什么要录制这个视频呢。

简单的说一句，是为了形成闭环的教程，如今有哪些教程了呢，其实说到底只有驱动一个，其他的东西都不行，就连驱动都还在继续搞呢，那这个Linux基础要搞成什么样呢？总不会还跟之前一样，寥寥草草的就过去了，什么都讲一遍，什么都讲不精，我是不可能这样的，那时候讲解的认知也不到位、自身的水平也不行，用我现在的眼光看四年前的视频，我会有一种成就感，可实际上呢，也仅仅是站在巨人的肩膀上作威作福罢了，终有一天你也会成为别人所踩的那个巨人，时候未到罢了。所以仍旧是把上面那句话送给你，==弱小和无知并不是生存的障碍，傲慢才是==

既然要做，肯定就应该做到极致，或者尽可能的做到当前的最好，就跟上次一样，现在看来，上次录制的RKNPU视频并不好，里面的一些甚至还有些问题，但是确实是当时能做到的最好了，历史的局限性，就导致了当时根本做不到，还有当时的技术水平不太行，等等，但我在进步呀，从那之后我学会了搭建网站，学会了markdown语言，后面就一直在写博客了，而且有了chatgpt，这些都是当时所没有的，所以现在也算是站在了巨人的肩膀上，所以，加油。

### 第二个问题，都要录制哪些内容？

最重要的一定是要有逻辑，每一节课跟每一节课之间都应该是有联系的，不能平白无故的产生，这些都应该有他们自己的联系，所以第一节课要讲解的是课程都要讲解哪些东西，或者这个东西不讲也可以，从法师的驱动视频来看第一节的内容必然要是一个整体的规划，其实也算是我最近两年学习到内容的一个整理和回顾吧，就也还行。

0.课程内容的框架、学习Linux基础的意义

1.环境的搭建

___

vmware软件的安装

ubuntu22虚拟机的构建(中文环境、安装ssh)

---

==既然要讲肯定是要最新的,环境搭建好之后换成中文，然后安装ssh，这里root允许登录开不开的吧，我发现并没有什么用==

==甚至就连那个wayland取消也可以不改，目前还没到那个步骤，确保文字的复制粘贴能生效就行了，关于图像化界面相关的复制，这里后面再说。==

___

___

tabby的安装和使用介绍（以后就通过ssh来连接，从而进行命令的讲解了）

vim 编辑器的讲解

___

基础命令的讲解(==不急==)

shell编程讲解（==不急==）

___

一点点来，先确定大方向是对的，从而一点点的努力就行了，中午读书的时候就读到了很有意义的一段话，如果当有钱之后才去修铁路，那么至今为止，世界上都不会有任何一条铁路，所以这句话就很引人思考，做任何一件事情都不能打算的很好才去做，一件事情在做之前不可能面面俱到，一切都是要开始之后才能判定，所以不可能等你做好准备，所以争取元旦来了就开始录制。

一个手册一个手册的写吧，先来写vmware软件的安装。





# 12.26 工作记录

## 1.编译Linux镜像

## 2.完善buildroot镜像

### 1.设置终端颜色

~~~shell
alias ls='ls --color'
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
export LS_COLORS
~~~

### 2.修改终端名称和密码

将终端名称设置为了topeet，密码设置为了topeet。

### 3.修改NPU驱动版本

将NPU驱动从0.8.2升级到了0.9.2

### 4.添加对应的五个测试应用

# 12.25 工作记录

## 1.整理构建脚本

~~~shell
# 如果输入的参数为空，则进入图形界面，否则为命令行编译
if [ -z "$1" ]; then
        titlestr="Choose an option"
        backtitle="iTOP-RK3588s building script, http://www.topeet.com"
        menustr="Compile image | uboot | kernel | rootfs | recovery | all | firmware |updateimg | cleanall"
        TTY_X=$(($(stty size | awk '{print $2}')-6))                    # determine terminal width
        TTY_Y=$(($(stty size | awk '{print $1}')-6))                    # determine terminal height
        
        # 第1页选项数组，包含选项和对应的函数名
        choose_page1+=("uboot" "uboot")
        choose_page1+=("kernel" "kernel")
        choose_page1+=("rootfs" "rootfs")
        choose_page1+=("recovery" "recovery")
        choose_page1+=("all" "all")
        choose_page1+=("firmware" "firmware")
        choose_page1+=("updateimg" "updateimg")
        choose_page1+=("cleanall" "cleanall")
        
        # 第2页选项数组，包含选项和对应的函数名
        choose_page2+=("buildroot" "buildroot")
        choose_page2+=("debian11" "debian11")
        choose_page2+=("debian12" "debian12")
        choose_page2+=("ubuntu20" "ubuntu20")
        choose_page2+=("ubuntu22" "ubuntu22")
        
        # 第3页选项数组，包含选项和对应的函数名
        choose_page3+=("buildroot_update" "buildroot")
        choose_page3+=("debian11_update" "debian11")
        choose_page3+=("debian12_update" "debian12")
        choose_page3+=("ubuntu20_update" "ubuntu20")
        choose_page3+=("ubuntu22_update" "ubuntu22")
        
        OPTIONS=$(whiptail --title "${titlestr}" --backtitle "${backtitle}" --notags \
                                                        --menu "${menustr}" "${TTY_Y}" "${TTY_X}" $((TTY_Y - 8))  \
                                                        --cancel-button Exit --ok-button Select "${choose_page1[@]}" \
                                                        3>&1 1>&2 2>&3)
else
        OPTIONS="${1}"
fi

# 根据用户选择的选项，判断是否需要显示第2页菜单
if [[ $OPTIONS == "rootfs" ]]; then
    # 使用whiptail创建第二页菜单，保存用户选择的选项到变量OPTIONS中
    OPTIONS=$(whiptail --title "${titlestr}" --backtitle "${backtitle}" --notags \
                        --menu "${menustr}" "${TTY_Y}" "${TTY_X}" $((TTY_Y - 8))  \
                        --cancel-button Exit --ok-button Select "${choose_page2[@]}" \
                        3>&1 1>&2 2>&3)
fi

echo $OPTIONS

# 根据用户选择的选项，判断是否需要显示第3页菜单
if [[ $OPTIONS == "all" ]]; then
    # 使用whiptail创建第二页菜单，保存用户选择的选项到变量OPTIONS中
    OPTIONS=$(whiptail --title "${titlestr}" --backtitle "${backtitle}" --notags \
                        --menu "${menustr}" "${TTY_Y}" "${TTY_X}" $((TTY_Y - 8))  \
                        --cancel-button Exit --ok-button Select "${choose_page3[@]}" \
                        3>&1 1>&2 2>&3)
fi

# 根据输入的参数，设置POST_OPTIONS变量
unset POST_OPTIONS
POST_OPTIONS="$POST_OPTIONS $OPTIONS"

# 导入板级配置文件
[ -r "$BOARD_CONFIG" ] || choose_board
source $BOARD_CONFIG

# 根据输入的参数进行选择编译
for option in $POST_OPTIONS; do
        echo "processing option: $option"
        case $option in
                all) build_all ;;
                save) build_save ;;
                allsave) build_allsave ;;
                cleanall) build_cleanall ;;
                updateimg) build_updateimg ;;
                uboot) build_uboot ;;
                kernel) build_kernel ;;
                modules) build_modules ;;
                rootfs) build_rootfs ;;
                buildroot|debian11|debian12|ubuntu20|ubuntu22|yocto) build_rootfs $option ;;
                recovery) build_recovery ;;
                buildroot_update) build_buildroot_all ;;
                debian11_update) build_debian11_all ;;
                debian12_update) build_debian12_all ;;
                ubuntu20_update) build_ubuntu20_all ;;
                ubuntu22_update) build_ubuntu22_all ;;
                info) build_info ;;
                *) usage ;;
        esac
done
~~~



~~~shell
# build_buildroot_all() 编译buildroot所有的镜像
# build_debian11_all() 编译debian11所有的镜像
# build_debian12_all() 编译debian12所有的镜像
# build_ubuntu20_all() 编译ubuntu20所有的镜像
# build_ubuntu22_all() 编译ubuntu22所有的镜像

~~~



## 2.ubuntu22 环境搭建

默认没有vim，所以首先安装了vim

~~~shell
sudo apt-get install vim
~~~

然后看网上说wayland有问题，所以禁止掉wayland

~~~shell
sudo vim /etc/gdm3/custom.conf
~~~

打开WaylandEnable=false的注释，然后重启系统，果然修改了之后，可以直接拖动了，不错。然后修改一下虚拟机配置：
![image-20231225105730434](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312251057515.png)

​	上面的这三个没啥用，直接关掉，启动时连接也取消掉。然后备份一下系统，中文输入法也不用安装，反正一般都是用ssh来连接的。

​	重启之后先来设置ssh，我还是喜欢用ssh，设置的步骤如下所示：

~~~shell
# 安装ssh 服务
apt install -y openssh-server  

# 开启sshd
systemctl start sshd  

# 使能root用户登录
vim /etc/ssh/sshd_config
PermitRootLogin yes
~~~

到这里该安装的就差不多了，剩下的就让tabby来，为了确保传输速度，先加一个nat的网卡：
![image-20231225112113607](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312251121657.png)

默认连网络的ifconfig命令都没有，还要安装一下网络工具：
~~~shell
sudo apt install net-tools
~~~

顺手删掉这些没用的目录：
~~~shell
sudo rm -rf Documents  Downloads  Music  Pictures  Public  snap  Templates  Videos
~~~

突然感觉还得再打包一个。。

![image-20231225125409231](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312251254299.png)

nat的网段为198.具体ip为192.168.198.130，先来测试Linux，当然在测试之前要安装一些工具包：
~~~shell
sudo apt-get install -y uuid uuid-dev zlib1g-dev liblz-dev liblzo2-2 liblzo2-dev lzop \
git curl u-boot-tools mtd-utils openjdk-8-jdk device-tree-compiler \
gdisk m4 git gnupg flex bison gperf libsdl1.2-dev libesd-java \
squashfs-tools build-essential zip libncurses5-dev pngcrush schedtool \
libxml2 libxml2-utils xsltproc lzop libc6-dev g++-multilib lib32z1-dev \
lib32ncurses-dev lib32readline-dev libswitch-perl libssl-dev unzip \
liblz4-tool ssh make gcc libssl-dev vim expect \
patchelf chrpath gawk texinfo diffstat binfmt-support \
qemu-user-static live-build fakeroot cmake rsync subversion \
sed binutils wget bzr cvs git mercurial \
patch gzip bzip2 perl tar cpio file bc python3-pip \
rsync android-sdk-libsparse-utils python2
~~~

在编译内核的时候遇到了的第一个问题：
![image-20231225134018868](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312251340418.png)

​	需要将python3链接到python，具体命令如下所示：
~~~shell
sudo ln -s /usr/bin/python3 /usr/bin/python
~~~

修改之后内核编译成功。编译recovery成功。编译文件系统成功、打包完整的update镜像成功，皆大欢喜，莫得问题，编译整体时间大约为两个小时，13：30开始编译，15：30编译结束时间.

随后又测试了安卓，同样可以编译成功。









































# 12.24 工作记录

==愿山河无恙，愿岁月静好，愿海阔天晴==

## 1.继续整理设备树

问题1：经过转接板的lvds屏幕都是不亮的？

​	问题整理，首先MIPI0和MIPI1都能正常的工作，而且对应的丝印也都是匹配的，而LVDS使用的都是MIPI0,无论是3588上还是3588S上用的都是MIPI0,而且相应的参数也都是对的，所以其实就可以不用考虑软件的问题了，目前将问题定位到了，**LCD_RESET_L**这个引脚上，首先来看一下3588上的修改，修改的地方如下所示：
![image-20231224141919132](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312241419208.png)

==行了问题解决了。。。==也不对。目前还是有一些问题，不知道问题在哪里，但肯定还是硬件的问题，同样的参数，同样的镜像，在3588上都能很正常的运行，现在换了一个转接板，新的10.1屏幕没啥问题了，但是其他的或多或少都有问题，这个先等等吧。

继续搞摄像头：
![image-20231224150846720](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312241508751.png)



![image-20231224150830441](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312241508650.png)



~~~C
#define CAMERA_J1  //U19
#define CAMERA_J2  //U16
#define CAMERA_J3  //U7008

#if defined(CAMERA_J1)
&csi2_dphy0_hw {
    status = "okay";
};

&csi2_dphy0 {
    status = "okay";
    ports {
        #address-cells = <1>;
        #size-cells = <0>;
        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipidphy0_in_ucam0: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&ov5695_out_1>;
                data-lanes = <1 2>;
            }; 
            mipidphy0_in_ucam0_ov13850: endpoint@2 {
                reg = <2>;
                remote-endpoint = <&ov13850_out_1>;
                data-lanes = <1 2 3 4>;
            };
        };
        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            csidphy0_out: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&mipi2_csi2_input>;
            };
        };
    };
};

&i2c3 {
    status = "okay";
    pinctrl-names = "default";
    pinctrl-0 = <&i2c3m1_xfer>;

    ov5695_1: ov5695@36 {
        status = "okay";
        compatible = "ovti,ov5695";
        reg = <0x36>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera3_clk>;
        reset-gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_LOW>;
        pwdn-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <0>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "default";
        rockchip,camera-module-lens-name = "default";
        port {
            ov5695_out_1: endpoint {
                remote-endpoint = <&mipidphy0_in_ucam0>;
                data-lanes = <1 2>;
            };
        };
    };
    ov13850_1: ov13850@10 {
        status = "okay";
        compatible = "otvi,ov13850";
        reg = <0x10>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera3_clk>;
        reset-gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
        pwdn-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <0>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "CMK-CT0116"; //"ZC-OV13850R2A-V1";
        rockchip,camera-module-lens-name = "Largan-50013A1"; //"Largan-50064B31";
        port {
            ov13850_out_1: endpoint {
                remote-endpoint = <&mipidphy0_in_ucam0_ov13850>;
                data-lanes = <1 2 3 4>;
            };
        };
    };
};

&mipi2_csi2 {
    status = "okay";
    ports {
        #address-cells = <1>;
        #size-cells = <0>;
        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;
            mipi2_csi2_input: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&csidphy0_out>;
            };
        };
        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            mipi2_csi2_output: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&cif_mipi_in2>;
            };
        };
    };
};

&rkcif_mipi_lvds2 {
    status = "okay";
    port {
        cif_mipi_in2: endpoint {
            remote-endpoint = <&mipi2_csi2_output>;
        };
    };
};

&rkcif_mipi_lvds2_sditf {
    status = "okay";
    port {
        mipi2_lvds_sditf: endpoint {
            remote-endpoint = <&isp0_vir1>;
        };
    };
};

&rkisp0_vir1 {
    status = "okay";
    port {
        #address-cells = <1>;
        #size-cells = <0>;
        isp0_vir1: endpoint@0 {
            reg = <0>;
            remote-endpoint = <&mipi2_lvds_sditf>;
        };
    };
};

#endif

#if defined(CAMERA_J2)
&csi2_dcphy0 {
    status = "okay";

    ports {
        #address-cells = <1>;
        #size-cells = <0>;
        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipidphy1_in_ucam0: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&ov5695_out_2>;
                data-lanes = <1 2>;
            }; 
            mipidphy1_in_ucam0_ov13850: endpoint@2 {
                reg = <2>;
                remote-endpoint = <&ov13850_out_2>;
                data-lanes = <1 2>;
            };
        };

        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;

            csidcphy0_out: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&mipi0_csi2_input>;
            };
        };
    };
};

&i2c4 {
    status = "okay";
    pinctrl-names = "default";
    pinctrl-0 = <&i2c4m3_xfer>;

    ov5695_2: ov5695@36 {
        status = "okay";
        compatible = "ovti,ov5695";
        reg = <0x36>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M1>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera1_clk>;
        reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_LOW>;
        pwdn-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <1>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "default";
        rockchip,camera-module-lens-name = "default";
        port {
            ov5695_out_2: endpoint {
                remote-endpoint = <&mipidphy1_in_ucam0>;
                data-lanes = <1 2>;
            };
        };

    };
    ov13850_2: ov13850@10 {
        status = "okay";
        compatible = "otvi,ov13850";
        reg = <0x10>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M1>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera1_clk>;
        reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
        pwdn-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <1>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "CMK-CT0116"; //"ZC-OV13850R2A-V1";
        rockchip,camera-module-lens-name = "Largan-50013A1"; //"Largan-50064B31";
        port {
            ov13850_out_2: endpoint {
                remote-endpoint = <&mipidphy1_in_ucam0_ov13850>;
                data-lanes = <1 2>;
            };
        };
    };
};

&mipi0_csi2 {
    status = "okay";

    ports {
        #address-cells = <1>;
        #size-cells = <0>;

        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipi0_csi2_input: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&csidcphy0_out>;
            };
        };

        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipi0_csi2_output: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&cif_mipi_in0>;
            };
        };
    };
};

&rkcif_mipi_lvds {
    status = "okay";

    port {
        cif_mipi_in0: endpoint {
            remote-endpoint = <&mipi0_csi2_output>;
        };
    };
};

&rkcif_mipi_lvds_sditf {
    status = "okay";

    port {
        mipi_lvds_sditf: endpoint {
            remote-endpoint = <&isp1_in1>;
        };
    };
};

&rkisp0_vir0 {
    status = "okay";

    port {
        #address-cells = <1>;
        #size-cells = <0>;

        isp1_in1: endpoint@0 {
            reg = <0>;
            remote-endpoint = <&mipi_lvds_sditf>;
        };
    };
};
#endif

#if defined(CAMERA_J3)
&csi2_dcphy1 {
    status = "okay";

    ports {
        #address-cells = <1>;
        #size-cells = <0>;

        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipidphy2_in_ucam0: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&ov5695_out_3>;
                data-lanes = <1 2>;
            }; 
            mipidphy2_in_ucam0_ov13850: endpoint@2 {
                reg = <2>;
                remote-endpoint = <&ov13850_out_3>;
                data-lanes = <1 2>;
            };
        };

        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;

            csidcphy1_out: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&mipi1_csi2_input>;
            };
        };
    };
};

&i2c1 {
    status = "okay";
    pinctrl-names = "default";
    pinctrl-0 = <&i2c1m2_xfer>;
    ov5695_3: ov5695@36 {
        status = "okay";
        compatible = "ovti,ov5695";
        reg = <0x36>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera4_clk>;
        reset-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_LOW>;
        pwdn-gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <2>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "default";
        rockchip,camera-module-lens-name = "default";
        port {
            ov5695_out_3: endpoint {
                remote-endpoint = <&mipidphy2_in_ucam0>;
                data-lanes = <1 2>;
            };
        };

    };
    ov13850_3: ov13850@10 {
        status = "okay";
        compatible = "otvi,ov13850";
        reg = <0x10>;
        clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
        clock-names = "xvclk";
        power-domains = <&power RK3588_PD_VI>;
        pinctrl-names = "default";
        pinctrl-0 = <&mipim0_camera4_clk>;
        reset-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
        pwdn-gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
        rockchip,camera-module-index = <2>;
        rockchip,camera-module-facing = "back";
        rockchip,camera-module-name = "CMK-CT0116"; //"ZC-OV13850R2A-V1";
        rockchip,camera-module-lens-name = "Largan-50013A1"; //"Largan-50064B31";
        port {
            ov13850_out_3: endpoint {
                remote-endpoint = <&mipidphy2_in_ucam0_ov13850>;
                data-lanes = <1 2>;
            };
        };
    };
};

&mipi1_csi2 {
    status = "okay";

    ports {
        #address-cells = <1>;
        #size-cells = <0>;

        port@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipi1_csi2_input: endpoint@1 {
                reg = <1>;
                remote-endpoint = <&csidcphy1_out>;
            };
        };

        port@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;

            mipi1_csi2_output: endpoint@0 {
                reg = <0>;
                remote-endpoint = <&cif_mipi_in1>;
            };
        };
    };
};

&rkcif_mipi_lvds1 {
    status = "okay";

    port {
        cif_mipi_in1: endpoint {
            remote-endpoint = <&mipi1_csi2_output>;
        };
    };
};

&rkcif_mipi_lvds1_sditf {
    status = "okay";

    port {
        mipi1_lvds_sditf: endpoint {
            remote-endpoint = <&isp1_in0>;
        };
    };
};

&rkisp1_vir0 {
    status = "okay";

    port {
        #address-cells = <1>;
        #size-cells = <0>;

        isp1_in0: endpoint@0 {
            reg = <0>;
            remote-endpoint = <&mipi1_lvds_sditf>;
        };
    };
};
#endif

~~~



![image-20231224165105229](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312241651510.png)

三个摄像头倒是可以了，但是这个显示确实不太好~~，中间的那个清楚，其他的不清楚，可是他们的配置都是一样的呀，不理解呀、不理解

~~~
gst-launch-1.0 v4l2src device=/dev/video31 ! video/x-raw,format=NV12,width=1920,height=1080, framerate=30/1 ! xvimagesink
gst-launch-1.0 v4l2src device=/dev/video22 ! video/x-raw,format=NV12,width=1920,height=1080, framerate=30/1 ! xvimagesink
gst-launch-1.0 v4l2src device=/dev/video11 ! video/x-raw,format=NV12,width=1920,height=1080, framerate=30/1 ! xvimagesink

gst-launch-1.0 v4l2src device=/dev/video33 ! video/x-raw,format=NV12,width=640,height=480, framerate=30/1 ! xvimagesink &
gst-launch-1.0 v4l2src device=/dev/video42 ! video/x-raw,format=NV12,width=640,height=480, framerate=30/1 ! xvimagesink &
gst-launch-1.0 v4l2src device=/dev/video51 ! video/x-raw,format=NV12,width=640,height=480, framerate=30/1 ! xvimagesink &

~~~



~~~
 
#function build_debian11() debian11编译函数
#function build_debian11() debian12编译函数
#function build_debian20() ubuntu20编译函数 
#function build_ubuntu22() ubuntu22编译函数

~~~



~~~
 



# build_rootfs_buildroot() 更新buildroot
# build_rootfs_debian11() 更新debian11
# build_rootfs_debian12() 更新debian12
# build_rootfs_ubuntu20()  更新ubuntu20
# build_rootfs_ubuntu22_xfce 更新ubuntu22_xfce
# build_rootfs_ubuntu22_gnome() 更新ubuntu22_gnome
# build_rootfs_all() 更新全部镜像
# clean_all() 清理
~~~



~~~
buildroot) build_rootfs_buildroot ;;
debian11) build_rootfs_debian11 ;;
debian12) build_rootfs_debian12 ;;
ubuntu20) build_rootfs_ubuntu20 ;;
ubuntu22_xfce) build_rootfs_ubuntu22_xfce ;;
ubuntu22_gnome) build_rootfs_ubuntu22_gnome ;;
all) build_rootfs_all ;;
cleanall) clean_all ;;
~~~



~~~
/%s/3588-linux/3588s-linux/g


%s/04_LVDS_10_1_1280x800_GT9271屏幕镜像/03_LVDS_10_1_1280x800_GT9271屏幕镜像/g
%s/05_LVDS_7_0屏幕镜像/04_LVDS_7_0屏幕镜像/g
%s/06_MIPI0屏幕镜像/05_MIPI0屏幕镜像/g
%s/07_MIPI1屏幕镜像/06_MIPI1屏幕镜像/g

%s/topeet_screen_lcds.dts/topeet-screen-lcds.dts/g


~~~





















# 12.23 工作记录

## 1.整理设备树

​	重新确定一下设备树的形状图：
最上级设备树：             topeet-rk3588-linux.dts

~~~
#include "topeet-rk3588.dtsi"
#include "rk3588-linux.dtsi"
#include "topeet-rk3588-config.dtsi"
~~~

第一级设备树  topeet-rk3588.dtsi

~~~
#include "rk3588s.dtsi"
#include "rk3588s-evb.dtsi"
#include "rk3588s-rk806-dual.dtsi"
~~~

第一级设备树"rk3588-linux.dtsi"

第一级设备树topeet-rk3588-config.dtsi

~~~
#include "topeet-screen-lcds.dts"
~~~

第二级设备树 rk3588s.dtsi

第二级设备树 rk3588s-evb.dtsi

第二级设备树 rk3588s-rk806-dual.dtsi

|            |                           |                           |
| :--------- | :------------------------ | :------------------------ |
| 设备树级别 | 设备树文件                | 包含的设备树文件          |
| 最上级     | topeet-rk3588-linux.dts   | topeet-rk3588.dtsi        |
|            |                           | rk3588-linux.dtsi         |
|            |                           | topeet-rk3588-config.dtsi |
| 第一级     | topeet-rk3588.dtsi        | rk3588s.dtsi              |
|            |                           | rk3588s-evb.dtsi          |
|            |                           | rk3588s-rk806-dual.dtsi   |
| 第一级     | rk3588-linux.dtsi         |                           |
| 第一级     | topeet-rk3588-config.dtsi | topeet-screen-lcds.dts    |
| 第二级     | rk3588s.dtsi              |                           |
| 第二级     | rk3588s-evb.dtsi          |                           |
| 第二级     | rk3588s-rk806-dual.dtsi   |                           |

![绘图1](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312230944311.jpg)

现在来分析其中都有哪些内容：

1.topeet-rk3588-linux.dts

topeet-rk3588-linux.dts最上级设备树内容如下所示：
```c
/dts-v1/;                                                                                                    
                                                                                                             
#include "topeet-rk3588.dtsi"                                                                                
#include "rk3588-linux.dtsi"                                                                                 
#include "topeet-rk3588-config.dtsi"                                                                         
                                                                                                             
/ {                                                                                                          
        model = "TOPEET RK3588S LP4X V10 Board";                                                             
        compatible = "rockchip,rk3588";                                                                      
};
```

这个是设备树的最上级，只是用来进行标明包含关系的，或者增加了model，在其下有着三个设备树，分别为

~~~c
#include "topeet-rk3588.dtsi"                                                                                
#include "rk3588-linux.dtsi"                                                                                 
#include "topeet-rk3588-config.dtsi"    
~~~

topeet-rk3588.dtsi 是最主要的一个设备树、等一下将无用的设备数节点删掉，然后我再重新配置，rk3588-linux.dtsi是关于Linux的一些相关配置的，就不如调试串口等，再然后是我们底板上的一些配置文件。

这里先来讲解rk3588-linux.dtsi设备树

### 2.rk3588-linux.dtsi

~~~c
// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
 *
 */

/ {
	aliases {
		mmc0 = &sdhci;
		mmc1 = &sdmmc;
		mmc2 = &sdio;
	};

	chosen: chosen {
		bootargs = "earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 irqchip.gicv3_pseudo_nmi=0 rw rootwait";
	};

	cspmu: cspmu@fd10c000 {
		compatible = "rockchip,cspmu";
		reg = <0x0 0xfd10c000 0x0 0x1000>,
		      <0x0 0xfd10d000 0x0 0x1000>,
		      <0x0 0xfd10e000 0x0 0x1000>,
		      <0x0 0xfd10f000 0x0 0x1000>,
		      <0x0 0xfd12c000 0x0 0x1000>,
		      <0x0 0xfd12d000 0x0 0x1000>,
		      <0x0 0xfd12e000 0x0 0x1000>,
		      <0x0 0xfd12f000 0x0 0x1000>;
	};

	debug: debug@fd104000 {
		compatible = "rockchip,debug";
		reg = <0x0 0xfd104000 0x0 0x1000>,
		      <0x0 0xfd105000 0x0 0x1000>,
		      <0x0 0xfd106000 0x0 0x1000>,
		      <0x0 0xfd107000 0x0 0x1000>,
		      <0x0 0xfd124000 0x0 0x1000>,
		      <0x0 0xfd125000 0x0 0x1000>,
		      <0x0 0xfd126000 0x0 0x1000>,
		      <0x0 0xfd127000 0x0 0x1000>;
	};

	fiq_debugger: fiq-debugger {
		compatible = "rockchip,fiq-debugger";
		rockchip,serial-id = <2>;
		rockchip,wake-irq = <0>;
		/* If enable uart uses irq instead of fiq */
		rockchip,irq-mode-enable = <1>;
		rockchip,baudrate = <115200>;  /* Only 115200 and 1500000 */
		interrupts = <GIC_SPI 423 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&uart2m0_xfer>;
		status = "okay";
	};

	firmware {
		optee: optee {
			compatible = "linaro,optee-tz";
			method = "smc";
			//status = "disabled";
		};
	};

	reserved-memory {
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		cma {
			compatible = "shared-dma-pool";
			reusable;
			size = <0x0 (8 * 0x100000)>;
			linux,cma-default;
		};

		drm_logo: drm-logo@00000000 {
			compatible = "rockchip,drm-logo";
			reg = <0x0 0x0 0x0 0x0>;
		};

		drm_cubic_lut: drm-cubic-lut@00000000 {
			compatible = "rockchip,drm-cubic-lut";
			reg = <0x0 0x0 0x0 0x0>;
		};

		ramoops: ramoops@110000 {
			compatible = "ramoops";
			reg = <0x0 0x110000 0x0 0xf0000>;
			record-size = <0x20000>;
			console-size = <0x80000>;
			ftrace-size = <0x00000>;
			pmsg-size = <0x50000>;
		};
	};
};

&display_subsystem {
	memory-region = <&drm_logo>;
	memory-region-names = "drm-logo";
};

&dfi {
	status = "okay";
};

&dmc {
	status = "okay";
	center-supply = <&vdd_ddr_s0>;
	mem-supply = <&vdd_log_s0>;
};

&rng {
	status = "okay";
};

&rockchip_suspend {

	rockchip,sleep-mode-config = <
	       (0
	       | RKPM_SLP_ARMOFF_DDRPD
	       | RKPM_SLP_PMU_PMUALIVE_32K
	       | RKPM_SLP_PMU_DIS_OSC
	       | RKPM_SLP_32K_EXT
	       | RKPM_SLP_PMU_DBG
	       )
	>;
};

&vdd_log_s0 {
	regulator-state-mem {
		regulator-on-in-suspend;
		regulator-suspend-microvolt = <750000>;
	};
};
~~~

​	上面绝大部分都不需要我们关注，需要注意的是chosen和fiq-debugger这两个节点

~~~c
	chosen: chosen {
		bootargs = "earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 irqchip.gicv3_pseudo_nmi=0 rw rootwait";
	};
~~~

chosen是内核挂载时候的一些参数，这里让我简单的改了一下，之前是凭借的uuid，现在让我写死了，在uboot里面

~~~c
	fiq_debugger: fiq-debugger {
		compatible = "rockchip,fiq-debugger";
		rockchip,serial-id = <2>;
		rockchip,wake-irq = <0>;
		/* If enable uart uses irq instead of fiq */
		rockchip,irq-mode-enable = <1>;
		rockchip,baudrate = <115200>;  /* Only 115200 and 1500000 */
		interrupts = <GIC_SPI 423 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&uart2m0_xfer>;
		status = "okay";
	};
~~~

上面的是打印调试串口，没啥要说的，只是最后将调试串口改为普通串口的时候有点作用，默认将1500000改为了115200。这个设备树也就没啥了。

### 3.topeet-rk3588-config.dtsi

这个是根据我们底板进行外设适配的一些内容。具体如下所示：
~~~C
#include "topeet-screen-lcds.dts"

//蜂鸣器
&pwm15 {
    status = "okay";
    pinctrl-0 = <&pwm15m2_pins>;
};

//有线网卡配置
&gmac1 {
        /* Use rgmii-rxid mode to disable rx delay inside Soc */
        phy-mode = "rgmii-rxid";
        clock_in_out = "output";

        snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
        snps,reset-active-low;
        /* Reset time is 20ms, 100ms for rtl8211f */
        snps,reset-delays-us = <0 20000 100000>;

        pinctrl-names = "default";
        pinctrl-0 = <&gmac1_miim
                &gmac1_tx_bus2
                &gmac1_rx_bus2
                &gmac1_rgmii_clk
                &gmac1_rgmii_bus
                &gmac1_clkinout>;

        tx_delay = <0x44>;
        /* rx_delay = <0x3f>; */

        phy-handle = <&rgmii_phy1>;
        status = "okay";
};

&mdio1 {
        rgmii_phy1: phy@1 {
                compatible = "ethernet-phy-ieee802.3-c22";
                reg = <0x1>;
        };
};


//声卡配置

&i2c7 {
	status = "okay";
	es8388: es8388@11 {
		status = "okay";
		#sound-dai-cells = <0>;
		compatible = "everest,es8388", "everest,es8323";
		reg = <0x11>;
		clocks = <&cru I2S0_8CH_MCLKOUT>;
		clock-names = "mclk";
		assigned-clocks = <&cru I2S0_8CH_MCLKOUT>;
		assigned-clock-rates = <12288000>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2s0_mclk>;
	};
};


//can
&can1 {
	status = "okay";
	compatible = "rockchip,canfd-1.0"; //使用canfd
	pinctrl-0 = <&can1m1_pins>;
	assigned-clocks = <&cru CLK_CAN1>;
	assigned-clock-rates = <100000000>;
};

//485
&uart9 {
	status = "okay";
//	dma-names = "tx", "rx"; //使用dma传输模式
	pinctrl-names = "default";
	pinctrl-0 = <&uart9m2_xfer>;
};

// rtc实时时钟
&i2c6 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c6m0_xfer>;

	hym8563: hym8563@51 {
		compatible = "haoyu,hym8563";
		reg = <0x51>;
		#clock-cells = <0>;
		clock-frequency = <32768>;
		clock-output-names = "hym8563";
		pinctrl-names = "default";
		pinctrl-0 = <&hym8563_int>;
		interrupt-parent = <&gpio0>;
		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
		wakeup-source;
	};
};

// M.2 固态硬盘
&combphy0_ps {
        status = "okay";
};

&pcie2x1l2 {
        status = "okay";
};
~~~

这里目前还存在很大的问题，我打算将那些用到的外设都改过来。这里不大对，甚至连那些pinctrl的引脚等等。



### 4.topeet-rk3588.dtsi

这个文件才是真正的大头，由于我这里是直接拷贝的设备树，所以一系列的之前人家板子的配置也随之过来了，这肯定是不对的，我先看看具体内容

~~~c
// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
 *
 */

#include "dt-bindings/usb/pd.h"
#include "rk3588s.dtsi"
#include "rk3588s-evb.dtsi"
#include "rk3588s-rk806-dual.dtsi"

/ {
	combophy_avdd0v85: combophy-avdd0v85 {
		compatible = "regulator-fixed";
		regulator-name = "combophy_avdd0v85";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <850000>;
		regulator-max-microvolt = <850000>;
		vin-supply = <&vdd_0v85_s0>;
	};

	combophy_avdd1v8: combophy-avdd1v8 {
		compatible = "regulator-fixed";
		regulator-name = "combophy_avdd1v8";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		vin-supply = <&avcc_1v8_s0>;
	};

	es8388_sound: es8388-sound {
		status = "okay";
		compatible = "rockchip,multicodecs-card";
		rockchip,card-name = "rockchip-es8388";
		hp-det-gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_LOW>;
		io-channels = <&saradc 3>;
		io-channel-names = "adc-detect";
		keyup-threshold-microvolt = <1800000>;
		poll-interval = <100>;
		spk-con-gpio = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
		hp-con-gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
		rockchip,format = "i2s";
		rockchip,mclk-fs = <256>;
		rockchip,cpu = <&i2s0_8ch>;
		rockchip,codec = <&es8388>;
		rockchip,audio-routing =
			"Headphone", "LOUT1",
			"Headphone", "ROUT1",
			"Speaker", "LOUT2",
			"Speaker", "ROUT2",
			"Headphone", "Headphone Power",
			"Headphone", "Headphone Power",
			"Speaker", "Speaker Power",
			"Speaker", "Speaker Power",
			"LINPUT1", "Main Mic",
			"LINPUT2", "Main Mic",
			"RINPUT1", "Headset Mic",
			"RINPUT2", "Headset Mic";
		pinctrl-names = "default";
		pinctrl-0 = <&hp_det>;
		play-pause-key {
			label = "playpause";
			linux,code = <KEY_PLAYPAUSE>;
			press-threshold-microvolt = <2000>;
		};
	};

	fan: pwm-fan {
		compatible = "pwm-fan";
		#cooling-cells = <2>;
		pwms = <&pwm11 0 50000 0>;
		cooling-levels = <0 50 100 150 200 255>;
		rockchip,temp-trips = <
			50000	1
			55000	2
			60000	3
			65000	4
			70000	5
		>;
	};

	vbus5v0_typec: vbus5v0-typec {
		compatible = "regulator-fixed";
		regulator-name = "vbus5v0_typec";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
		vin-supply = <&vcc5v0_usb>;
		pinctrl-names = "default";
		pinctrl-0 = <&typec5v_pwren>;
	};

    vcc3v3_lcd_n: vcc3v3-lcd0-n {
        compatible = "regulator-fixed";
        regulator-name = "vcc3v3_lcd0_n";
        regulator-always-on;
        regulator-boot-on;
        enable-active-high;
        gpio = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>;
        vin-supply = <&vcc_1v8_s0>;
    };

	vcc3v3_lcd_edp: vcc3v3-lcd-edp {
		compatible = "regulator-fixed";
		regulator-name = "vcc3v3_lcd_edp";
		gpio = <&gpio1 RK_PA5 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-boot-on;
		vin-supply = <&vcc_3v3_s3>;
	};

	vcc3v3_pcie20: vcc3v3-pcie20 {
		compatible = "regulator-fixed";
		regulator-name = "vcc3v3_pcie20";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		enable-active-high;
		gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
		startup-delay-us = <5000>;
		vin-supply = <&vcc12v_dcin>;
	};

	vcc5v0_host: vcc5v0-host {
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_host";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
		vin-supply = <&vcc5v0_usb>;
		pinctrl-names = "default";
		pinctrl-0 = <&vcc5v0_host_en>;
	};

};

&backlight {
	pwms = <&pwm12 0 25000 0>;
	power-supply = <&vcc3v3_lcd_edp>;
	status = "okay";
};

&combphy0_ps {
	status = "okay";
};

&dp0 {
	status = "okay";
};

&dp0_in_vp1 {
	status = "okay";
};

&dp0_sound{
	status = "okay";
};


&hdptxphy0 {
	/* Single Vdiff Training Table for power reduction (optional) */
	training-table = /bits/ 8 <
		/* voltage swing 0, pre-emphasis 0->3 */
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		/* voltage swing 1, pre-emphasis 0->2 */
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		/* voltage swing 2, pre-emphasis 0->1 */
		0x0d 0x00 0x00 0x00 0x00 0x00
		0x0d 0x00 0x00 0x00 0x00 0x00
		/* voltage swing 3, pre-emphasis 0 */
		0x0d 0x00 0x00 0x00 0x00 0x00
	>;
	status = "okay";
};


&i2c8 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c8m2_xfer>;

	usbc0: fusb302@22 {
		compatible = "fcs,fusb302";
		reg = <0x22>;
		interrupt-parent = <&gpio0>;
		interrupts = <RK_PD3 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbc0_int>;
		vbus-supply = <&vbus5v0_typec>;
		status = "okay";

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;
				usbc0_role_sw: endpoint@0 {
					remote-endpoint = <&dwc3_0_role_switch>;
				};
			};
		};

		usb_con: connector {
			compatible = "usb-c-connector";
			label = "USB-C";
			data-role = "dual";
			power-role = "dual";
			try-power-role = "sink";
			op-sink-microwatt = <1000000>;
			sink-pdos =
				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
			source-pdos =
				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;

			altmodes {
				#address-cells = <1>;
				#size-cells = <0>;

				altmode@0 {
					reg = <0>;
					svid = <0xff01>;
					vdo = <0xffffffff>;
				};
			};

			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;
					usbc0_orien_sw: endpoint {
						remote-endpoint = <&usbdp_phy0_orientation_switch>;
					};
				};

				port@1 {
					reg = <1>;
					dp_altmode_mux: endpoint {
						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
					};
				};
			};
		};
	};

};

&pdm0 {
	status = "okay";
};

&pinctrl {
	headphone {
		hp_det: hp-det {
			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

	usb {
		vcc5v0_host_en: vcc5v0-host-en {
			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

	usb-typec {
		usbc0_int: usbc0-int {
			rockchip,pins = <0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
		};

		typec5v_pwren: typec5v-pwren {
			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};
};


&sdmmc {
	status = "okay";
};

&spdif_tx1 {
	status = "disabled";
	pinctrl-names = "default";
	pinctrl-0 = <&spdif1m1_tx>;
};

&spdif_tx1_dc {
	status = "okay";
};

&spdif_tx1_sound {
	status = "okay";
};

&spdif_tx2 {
	status = "okay";
};

&u2phy0_otg {
	rockchip,typec-vbus-det;
};

&u2phy2_host {
	phy-supply = <&vcc5v0_host>;
};

&u2phy3_host {
	phy-supply = <&vcc5v0_host>;
};


&usbdp_phy0 {
	orientation-switch;
	svid = <0xff01>;
	sbu1-dc-gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_HIGH>;
	sbu2-dc-gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_HIGH>;

	port {
		#address-cells = <1>;
		#size-cells = <0>;
		usbdp_phy0_orientation_switch: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&usbc0_orien_sw>;
		};

		usbdp_phy0_dp_altmode_mux: endpoint@1 {
			reg = <1>;
			remote-endpoint = <&dp_altmode_mux>;
		};
	};
};

&usbdrd_dwc3_0 {
	usb-role-switch;
	port {
		#address-cells = <1>;
		#size-cells = <0>;
		dwc3_0_role_switch: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&usbc0_role_sw>;
		};
	};
};

&usbhost3_0 {
	status = "disabled";
};

&usbhost_dwc3_0 {
	status = "disabled";
};
~~~

## 2.重新整理设备树

### 2.1 最上级设备树

   topeet-rk3588-linux.dts

~~~c
// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
 *
 */

/dts-v1/;

#include "dt-bindings/usb/pd.h"
#include "rk3588s.dtsi"
#include "rk3588s-evb.dtsi"
#include "rk3588-rk806-single.dtsi"
#include "rk3588-linux.dtsi"
#include "topeet-rk3588-config.dtsi"

//#include "iTop-3588s-mipi0.dts"
//#include "iTop-3588s-mipi1.dts"
//#include "iTop-3588s-dcphy0.dts"
//#include "iTop-3588s-dcphy1.dts"
//#include "iTop-3588s-dphy0.dts"
/ {
	model = "TOPEET RK3588S LP4X V10 Board";
	compatible = "rockchip,rk3588";

	aliases {
		hdptxhdmi0 = &hdptxphy_hdmi0;
		hdmi0 = &hdmi0;
	};


	combophy_avdd0v85: combophy-avdd0v85 {
		compatible = "regulator-fixed";
		regulator-name = "combophy_avdd0v85";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <850000>;
		regulator-max-microvolt = <850000>;
		vin-supply = <&vdd_0v85_s0>;
	};

	combophy_avdd1v8: combophy-avdd1v8 {
		compatible = "regulator-fixed";
		regulator-name = "combophy_avdd1v8";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		vin-supply = <&avcc_1v8_s0>;
	};

	es8388_sound: es8388-sound {
		status = "okay";
		compatible = "rockchip,multicodecs-card";
		rockchip,card-name = "rockchip-es8388";
		hp-det-gpio = <&gpio1 RK_PC0 GPIO_ACTIVE_LOW>;
		//io-channels = <&saradc 3>;
		//io-channel-names = "adc-detect";
		//keyup-threshold-microvolt = <1800000>;
		poll-interval = <100>;
		spk-con-gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
		rockchip,format = "i2s";
		rockchip,mclk-fs = <256>;
		rockchip,cpu = <&i2s0_8ch>;
		rockchip,codec = <&es8388>;
		rockchip,audio-routing =
			"Headphone", "LOUT1",
			"Headphone", "ROUT1",
			"Speaker", "LOUT2",
			"Speaker", "ROUT2",
			"Headphone", "Headphone Power",
			"Headphone", "Headphone Power",
			"Speaker", "Speaker Power",
			"Speaker", "Speaker Power",
			"LINPUT1", "Main Mic",
			"LINPUT2", "Main Mic",
			"RINPUT1", "Headset Mic",
			"RINPUT2", "Headset Mic";
		pinctrl-names = "default";
		pinctrl-0 = <&hp_det>;
		play-pause-key {
			label = "playpause";
			linux,code = <KEY_PLAYPAUSE>;
			press-threshold-microvolt = <2000>;
		};
	};

	fan: pwm-fan {
		compatible = "pwm-fan";
		#cooling-cells = <2>;
		pwms = <&pwm11 0 50000 0>;
	};

	vbus5v0_typec: vbus5v0-typec {
		compatible = "regulator-fixed";
		regulator-name = "vbus5v0_typec";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
		vin-supply = <&vcc5v0_usb>;
		pinctrl-names = "default";
		pinctrl-0 = <&typec5v_pwren>;
	};

	vcc3v3_lcd_n: vcc3v3-lcd0-n {
		compatible = "regulator-fixed";
		regulator-name = "vcc3v3_lcd0_n";
		regulator-boot-on;
		enable-active-high;
		gpio = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
		vin-supply = <&vcc_3v3_s0>;
	};

	vcc3v3_pcie20: vcc3v3-pcie20 {
		compatible = "regulator-fixed";
		regulator-name = "vcc3v3_pcie20";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		enable-active-high;
		gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
		startup-delay-us = <5000>;
		vin-supply = <&vcc12v_dcin>;
	};

	vcc5v0_host: vcc5v0-host {
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_host";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;
		vin-supply = <&vcc5v0_usb>;
		pinctrl-names = "default";
		pinctrl-0 = <&vcc5v0_host_en>;
	};

	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_1v1_nldo_s3";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <1100000>;
		regulator-max-microvolt = <1100000>;
		vin-supply = <&vcc5v0_sys>;
	};

	vcc_1v8_cam_s0: vcc-1v8-cam-s0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_1v8_cam_s0";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		vin-supply = <&vcc_3v3_s3>;
	};

	vcc_2v8_cam_s0: vcc-2v8-cam-s0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_2v8_cam_s0";
		regulator-min-microvolt = <2800000>;
		regulator-max-microvolt = <2800000>;
		vin-supply = <&vcc_3v3_s3>;
	};

	vcc_3v3_sd_s0: vcc-3v3-sd-s0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_3v3_sd_s0";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		gpios = <&gpio0 RK_PD4 GPIO_ACTIVE_LOW>;
		enable-active-low;
		vin-supply = <&vcc_3v3_s3>;
			regulator-state-mem {
				regulator-off-in-suspend;
		};
	};
};

&i2c0 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c0m2_xfer>;

	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
		compatible = "rockchip,rk8602";
		reg = <0x42>;
		vin-supply = <&vcc5v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_cpu_big0_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <1050000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};

	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
		compatible = "rockchip,rk8603";
		reg = <0x43>;
		vin-supply = <&vcc5v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_cpu_big1_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <1050000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};
};

&i2c2 {
	status = "okay";

	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
		compatible = "rockchip,rk8602";
		reg = <0x42>;
		vin-supply = <&vcc5v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_npu_s0";
		regulator-min-microvolt = <550000>;
		regulator-max-microvolt = <950000>;
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};
};

&i2c7 {
	status = "okay";
	pinctrl-0 = <&i2c7m0_xfer>;

	es8388: es8388@11 {
		status = "okay";
		#sound-dai-cells = <0>;
		compatible = "everest,es8388", "everest,es8323";
		reg = <0x11>;
		clocks = <&cru I2S0_8CH_MCLKOUT>;
		clock-names = "mclk";
		pinctrl-names = "default";
		pinctrl-0 = <&i2s0_mclk>;
	};
};

&i2s0_8ch {
	status = "okay";
};

&i2c6 {
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c6m3_xfer>;

	hym8563: hym8563@51 {
		compatible = "haoyu,hym8563";
		reg = <0x51>;
		#clock-cells = <0>;
		clock-frequency = <32768>;
		clock-output-names = "hym8563";
		pinctrl-names = "default";
		pinctrl-0 = <&hym8563_int>;
		interrupt-parent = <&gpio0>;
		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
		wakeup-source;
		status = "okay";
	};

	usbc0: fusb302@22 {
		compatible = "fcs,fusb302";
		reg = <0x22>;
		interrupt-parent = <&gpio0>;
		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&usbc0_int>;
		vbus-supply = <&vbus5v0_typec>;
		status = "okay";

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;
				usbc0_role_sw: endpoint@0 {
					remote-endpoint = <&dwc3_0_role_switch>;
				};
			};
		};

		usb_con: connector {
			compatible = "usb-c-connector";
			label = "USB-C";
			data-role = "dual";
			power-role = "dual";
			try-power-role = "sink";
			op-sink-microwatt = <1000000>;
			sink-pdos = <PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;

			altmodes{
				#address-cells = <1>;
				#size-cells = <0>;

				altmode@0 {
					reg = <0>;
					svid = <0xff01>;
					vdo = <0xffffffff>;
				};
			};

			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;

					usbc0_orien_sw: endpoint {
						remote-endpoint = <&usbdp_phy0_orientation_switch>;
					};
				};

				port@1 {
					reg = <1>;

					dp_altmode_mux: endpoint {
						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
					};
				};
			};
		};
	};
};

/* PCIE 2.0 */
&combphy0_ps {
	status = "okay";
};

&pcie2x1l2 {
	//reset-gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_HIGH>;
	//rockchip,skip-scan-in-resume;
	status = "okay";
};
/* end of PCIE 2.0 */

&pinctrl {
	headphone {
		hp_det: hp-det {
			rockchip,pins = <1 RK_PC0 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

	hym8563 {
		hym8563_int: hym8563-int {
			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};


	usb {
		vcc5v0_host_en: vcc5v0-host-en {
			rockchip,pins = <4 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

	usb-typec {
		usbc0_int: usbc0-int {
			rockchip,pins = <0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
		};

		typec5v_pwren: typec5v-pwren {
			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

};

/* BEEP */
&pwm1 {
	pinctrl-0 = <&pwm1m1_pins>;
	status = "okay";
};
/* end of BEEP */
/* gmac */
&gmac1 {
	/* Use rgmii-rxid mode to disable rx delay inside Soc */
	phy-mode = "rgmii-rxid";
	clock_in_out = "output";

	snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
	snps,reset-active-low;
	/* Reset time is 20ms, 100ms for rtl8211f */
	snps,reset-delays-us = <0 20000 100000>;

	pinctrl-names = "default";
	pinctrl-0 = <&gmac1_miim
		&gmac1_tx_bus2
		&gmac1_rx_bus2
		&gmac1_rgmii_clk
		&gmac1_rgmii_bus
		//&eth1_pins
		&gmac1_clkinout>;

	tx_delay = <0x44>;
	/* rx_delay = <0x3f>; */

	phy-handle = <&rgmii_phy1>;
	status = "okay";
};

&mdio1 {
	rgmii_phy1: phy@1 {
		compatible = "ethernet-phy-ieee802.3-c22";
		reg = <0x1>;
	};
};
/* end of gmac */

/* sd card */
&sdmmc {
	status = "okay";
	vmmc-supply = <&vcc_3v3_sd_s0>;
};
/* end of sd card */

/* type-C */
&u2phy0_otg {
	status = "okay";
	rockchip,typec-vbus-det;
};

&usbdp_phy0 {
	orientation-switch;
	svid = <0xff01>;
	sbu1-dc-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_HIGH>;
	sbu2-dc-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;

	port {
		#address-cells = <1>;
		#size-cells = <0>;

		usbdp_phy0_orientation_switch: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&usbc0_orien_sw>;
		};

		usbdp_phy0_dp_altmode_mux: endpoint@1 {
			reg = <1>;
			remote-endpoint = <&dp_altmode_mux>;
		};
	};
};

&usbdrd_dwc3_0 {
	dr_mode = "otg";
	usb-role-switch;

	port {
		#address-cells = <1>;
		#size-cells = <0>;

		dwc3_0_role_switch: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&usbc0_role_sw>;
		};
	};
};
/* end of type-C */
/* USB 2.0 HOST */
&u2phy2_host {
	status = "okay";
	phy-supply = <&vcc5v0_host>;
};

&u2phy3_host {
	status = "okay";
	phy-supply = <&vcc5v0_host>;
};

&usb_host0_ehci {
	status = "okay";
};

&usb_host0_ohci {
	status = "okay";
};

&usb_host1_ehci {
	status = "okay";
};

&usb_host1_ohci {
	status = "okay";
};
/* end of usb 2.0 */

&usbdrd_dwc3_0 {
	usb-role-switch;
	port {
		#address-cells = <1>;
		#size-cells = <0>;
		dwc3_0_role_switch: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&usbc0_role_sw>;
		};
	};
};

/* USB 3.0 */
&combphy2_psu {
	status = "okay";
};

&usbhost3_0 {
	status = "okay";
};

&usbhost_dwc3_0 {
	status = "okay";
	dr_mode = "host";
};
/* end of USB 3.0 */

/* hdmi0 */
&hdmi0 {
	enable-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
	status = "okay";
};

&route_hdmi0 {
	status = "okay";
	connect = <&vp0_out_hdmi0>;
};

&hdmi0_in_vp0 {
	status = "okay";
};

&hdmi0_sound {
	status = "okay";
};

&hdptxphy_hdmi0 {
	status = "okay";
};

&i2s5_8ch {
	status = "oksy";
};
/* end */

/* RS485 */
&uart9 {
	status = "okay";
	pinctrl-0 = <&uart9m2_xfer>;
};
/* end of RS485 */
~~~

目前认为这里的有点单薄，不应该这样。

### 2.2 一级设备树

#### 2.2.1 topeet-rk3588.dtsi

#### 2.2.2 rk3588-linux.dtsi

#### 2.2.3 topeet-rk3588.dtsi

## 3 稳压相关的原理图

### 3.1 12V 

![image-20231223134504054](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231345124.png)



### 3.2 4V

![image-20231223134521195](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231345260.png)

### 3.3 3.3 V

![image-20231223134534079](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231345119.png)

### 3.4 5V

![image-20231223134553899](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231345948.png)

### 3.5 1.8V

![image-20231223134606097](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231346143.png)

### 3.6 LCD屏幕电源使能3.3V

![image-20231223134635776](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231346823.png)

### 3.7 USB 2.0供电使能 5V

![image-20231223134813425](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231348469.png)

### 3.8 usb3.0 供电使能 5V

![image-20231223134838302](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231348349.png)

### 3.8 usb-c供电使能 5V

![image-20231223134926789](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231349827.png)

### 3.9 tf卡供电使能 3.3V

![image-20231223134956257](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231349299.png)

### 3.10 摄像头供电使能 2.8V

~~~

	vcc_1v8_cam_s0: vcc-1v8-cam-s0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_1v8_cam_s0";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		vin-supply = <&vcc_3v3_s3>;
	};

	vcc_2v8_cam_s0: vcc-2v8-cam-s0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc_2v8_cam_s0";
		regulator-min-microvolt = <2800000>;
		regulator-max-microvolt = <2800000>;
		vin-supply = <&vcc_3v3_s3>;
	};
~~~



![image-20231223135035944](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231350981.png)

### 3.11 M.2固态供电 3.3

![image-20231223135235732](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312231352781.png)

~~~
        combophy_avdd0v85: combophy-avdd0v85 {
                compatible = "regulator-fixed";
                regulator-name = "combophy_avdd0v85";
                regulator-boot-on;
                regulator-always-on;
                regulator-min-microvolt = <850000>;
                regulator-max-microvolt = <850000>;
                vin-supply = <&vdd_0v85_s0>;
        };

        combophy_avdd1v8: combophy-avdd1v8 {
                compatible = "regulator-fixed";
                regulator-name = "combophy_avdd1v8";
                regulator-boot-on;
                regulator-always-on;
                regulator-min-microvolt = <1800000>;
                regulator-max-microvolt = <1800000>;
                vin-supply = <&avcc_1v8_s0>;
        };
~~~

删掉电源管理的这两个。

## 4.设备树优化规则

1. 电源相关的内容都放在设备树的最前面







# 12.22 工作记录

## 1.3588S适配

### 1.1 完善脚本注释

将脚本搞好了，删除掉了一些没有必要的内容，瑞芯微提供的原版编译脚本太乱了，真的不忍直视，删掉了那些跟安全相关的内容还有那些与安全相关的内容，目前看起来就挺干净的，只是那些函数的具体意义还没理解的很清楚，有机会再去搞，目前也就先这样了。

### 1.2整理硬件手册

目前有疑问的地方在于是不是3588和3588S的TRM手册是不是一个呢。

|                            | RK3588                                        | RK3588S                                       |
| :------------------------- | :-------------------------------------------- | --------------------------------------------- |
| 封装                       | 23x23 mm，0.65间距                            | 17x17 mm，0.4间距                             |
| DDR                        | 支持LPDDR4/4X和LPDDR5 2x32Bit                 | 支持LPDDR4/4X和LPDDR5 2x32Bit                 |
| 存储                       | 支持eMMC 5.1                                  | 支持eMMC 5.1                                  |
|                            | 支持FSPI Flash (FSPI，路由到3个IOMUX)         | 支持FSPI Flash (FSPI，路由到2个IOMUX)         |
|                            | Micro SD卡 3.0                                | Micro SD卡 3.0                                |
| USB                        | 1个USB3.0（与PCIE20/SATA30共享）              | 1个USB3.0（与PCIE20/SATA30共享）              |
|                            | 2个USB2.0 HOST                                | 2个USB2.0 HOST                                |
|                            | 2个USB3.1 + 2个USB2.0 OTG（两个全功能Type C） | 1个USB3.1 + 1个USB2.0 OTG（一个全功能Type C） |
| 显示                       | TYPEC/DP1.4共用，2个4通道DP1.4                | TYPEC/DP1.4共用，1个4通道DP1.4                |
|                            | 2个HDMI2.1 TX/eDP1.4                          | 1个HDMI2.1 TX /eDP1.4                         |
|                            | 2个4通道MIPI DPHY TX/CPHY TX                  | 2个4通道MIPI DPHY TX/CPHY TX                  |
| 相机/视频输入              | 2个4通道MIPI CSI或4个2通道MIPI CSI            | 1个4通道MIPI CSI或2个2通道MIPI CSI            |
|                            | 2个MIPI CPHY RX/MIPI DPHY RX                  | 2个MIPI CPHY RX/MIPI DPHY RX                  |
| HDMI RX                    | 1个4通道HDMI RX                               | N/A                                           |
| PCIE3.0                    | 2个2通道PCIe3.0                               | N/A                                           |
| PCIe2.0/SATA3.0/USB3.0 MUX | 3个1通道PCIe2.0                               | 2个1通道PCIe2.0                               |
|                            | 3个SATA 3.0                                   | 2个SATA 3.0                                   |
|                            | 1个USB3.0（参考USB部分）                      | 1个USB3.0（参考USB部分）                      |
| SARADC                     | x8                                            | x6                                            |
| SDIO                       | 1个SDIO，路由到2个IOMUX                       | 1个SDIO，路由到1个IOMUX                       |
| GMAC                       | 2个(GMAC0+GMAC1)                              | 1个(GMAC1)                                    |
| I2C                        | x9                                            | x9                                            |
| PWM                        | x16                                           | x16                                           |
| UART                       | x10                                           | x10                                           |
| SPI                        | x5                                            | x5                                            |
| I2S                        | x4                                            | x4                                            |
| PDM                        | x2（Data0～Data3）                            | x2（Data0～Data3）                            |
| CIF                        | x1（CIF0～Data15）                            | x1（CIF0～Data15）                            |
| BT1120                     | x1（Data0～Data15）                           | x1（Data0～Data15）                           |
| CAN                        | x2                                            | x2                                            |
| SPDIF                      | x2                                            | x2                                            |

### 1.3 适配源码

修改了默认的设备树，修改为了topeet-rk3588-linux.dts以及添加了对应的板级支持文件。首先列一下设备树的包含目录：
		第一级         topeet-rk3588-linux.dts                                                                                     

~~~
#include "rk3588-evb7-lp4.dtsi"                                                                              
#include "rk3588-linux.dtsi" 
#include "topeet_rk3588_config.dtsi"    
~~~


第二级 rk3588-evb7-lp4.dtsi

```
#include "rk3588.dtsi"
#include "rk3588-evb.dtsi"
#include "rk3588-rk806-single.dtsi"

#include "topeet_screen_lcds.dts"
#include "topeet_camera_config.dtsi"
```

第二级  rk3588-linux.dtsi

第二级 topeet_rk3588_config.dtsi



现如今进行修改

​	第一级         topeet-rk3588-linux.dts

```
#include "topeet-rk3588.dtsi"
#include "rk3588-linux.dtsi"
#include "topeet_rk3588_config.dtsi"
```

第二级  topeet-rk3588.dtsi

~~~
#include "dt-bindings/usb/pd.h"
#include "rk3588.dtsi"
#include "rk3588-evb.dtsi"
#include "rk3588-rk806-single.dtsi"
~~~

第三级 rk3588.dtsi

```
#include "rk3588s.dtsi"                                                                                      
#include "rk3588-vccio3-pinctrl.dtsi"  
```

~~~
&hdmi0 {
        enable-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
        status = "okay";
};

&route_hdmi0 {
        status = "okay";
        connect = <&vp0_out_hdmi0>;
};

&hdmi0_in_vp0 {
        status = "okay";
};

&hdmi0_sound {
        status = "okay";
};

&hdptxphy_hdmi0 {
        status = "okay";
};

&i2s5_8ch {
        status = "oksy";
};
~~~

出现了问题，具体的打印如下所示：
~~~shell
LPDDR4X, 2112MHz
channel[0] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[1] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[2] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[3] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
Manufacturer ID:0xff
CH0 RX Vref:29.7%, TX Vref:22.8%,22.8%
CH1 RX Vref:30.7%, TX Vref:22.8%,21.8%
CH2 RX Vref:29.7%, TX Vref:21.8%,22.8%
CH3 RX Vref:29.7%, TX Vref:23.8%,21.8%
change to F1: 528MHz
change to F2: 1068MHz
change to F3: 1560MHz
change to F0: 2112MHz
out
U-Boot SPL board init
U-Boot SPL 2017.09-gc060f28d70-220414 #zyf (Apr 18 2022 - 18:13:34)
Failed to set cpub01
Failed to set cpub23
unknown raw ID phN
unrecognized JEDEC id bytes: 00, 00, 00
Trying to boot from MMC2
MMC: no card present
mmc_init: -123, time 2
spl: mmc init failed with error: -123
Trying to boot from MMC1
Trying fit image at 0x4000 sector
## Verified-boot: 0
## Checking atf-1 0x00040000 ... sha256(045b2cef29...) + OK
## Checking uboot 0x00200000 ... sha256(91161ac802...) + OK
## Checking fdt 0x0033d2d8 ... sha256(a4d6ae0a3e...) + OK
## Checking atf-2 0x000f0000 ... sha256(30812190d0...) + OK
## Checking atf-3 0xff100000 ... sha256(cb7bdbec2b...) + OK
## Checking optee 0x08400000 ... sha256(fde0860845...) + OK
Jumping to U-Boot(0x00200000) via ARM Trusted Firmware(0x00040000)
Total: 174.568 ms

INFO:    Preloader serial: 2
NOTICE:  BL31: v2.3():v2.3-481-g17b41886e:derrick.huang
NOTICE:  BL31: Built : 16:20:07, Dec  7 2022
INFO:    spec: 0x13
INFO:    ext 32k is valid
INFO:    ddr: stride-en 4CH
INFO:    GICv3 without legacy support detected.
INFO:    ARM GICv3 driver initialized in EL3
INFO:    valid_cpu_msk=0xff bcore0_rst = 0x0, bcore1_rst = 0x0
INFO:    system boots from cpu-hwid-0
INFO:    idle_st=0x21fff, pd_st=0x11fff9, repair_st=0xfff70001
INFO:    dfs DDR fsp_params[0].freq_mhz= 2112MHz
INFO:    dfs DDR fsp_params[1].freq_mhz= 528MHz
INFO:    dfs DDR fsp_params[2].freq_mhz= 1068MHz
INFO:    dfs DDR fsp_params[3].freq_mhz= 1560MHz
INFO:    BL31: Initialising Exception Handling Framework
INFO:    BL31: Initializing runtime services
INFO:    BL31: Initializing BL32
INFO:    hdmirx_handler: dma not on, ret
I/TC: 
I/TC: OP-TEE version: 3.13.0-652-g4542e1efd #derrick.huang (gcc version 10.2.1 20201103 (GNU Toolchain for the A-profile Architecture 10.2-2020.11 (arm-10.16))) #5 2022年 09月 20日 星期二 09:41:09 CST aarch64
I/TC: Primary CPU initializing
I/TC: Primary CPU switching to normal world boot
INFO:    BL31: Preparing for EL3 exit to normal world
INFO:    Entry point address = 0x200000
INFO:    SPSR = 0x3c9


U-Boot 2017.09 (Nov 07 2023 - 01:52:43 -0800)

Model: TOPEET iTOP-RK3588 Board 
PreSerial: 2, raw, 0xfeb50000
DRAM:  8 GiB
Sysmem: init
Relocation Offset: eda3a000
Relocation fdt: eb9f9f98 - eb9fecc0
CR: M/C/I
Hotkey: ctrl+`
mmc@fe2c0000: 1, mmc@fe2e0000: 0
Bootdev(atags): mmc 0
MMC0: HS200, 200Mhz
PartType: EFI
DM: v2
boot mode: recovery (misc)
FIT: no signed, no conf required
DTB: rk-kernel.dtb
HASH(c): OK
I2c0 speed: 100000Hz
vsel-gpios- not found!
en-gpios- not found!
vdd_cpu_big0_s0 800000 uV
vsel-gpios- not found!
en-gpios- not found!
vdd_cpu_big1_s0 800000 uV
I2c1 speed: 100000Hz
vsel-gpios- not found!
en-gpios- not found!
read reg[0x03] failed, ret=-121
Failed to get chip ID!
spi2: RK806: 2
ON=0x00, OFF=0x00
vdd_gpu_s0 750000 uV
vdd_cpu_lit_s0 750000 uV
vdd_log_s0 750000 uV
vdd_vdenc_s0 init 750000 uV
vdd_ddr_s0 850000 uV
*** Warning - bad CRC, using default environment

get vp0 plane mask:0x5, primary id:2, cursor_plane:-1, from dts
get vp1 plane mask:0xa, primary id:3, cursor_plane:-1, from dts
get vp2 plane mask:0x140, primary id:8, cursor_plane:-1, from dts
get vp3 plane mask:0x280, primary id:9, cursor_plane:-1, from dts
Could not find baseparameter partition
Model: Rockchip RK3588 EVB7 LP4 V10 Board
Rockchip UBOOT DRM driver version: v1.0.1
vp0 have layer nr:2[0 2 ], primary plane: 2
vp1 have layer nr:2[1 3 ], primary plane: 3
vp2 have layer nr:2[6 8 ], primary plane: 8
vp3 have layer nr:2[7 9 ], primary plane: 9
Using display timing dts
dsi@fde20000:  detailed mode clock 90000 kHz, flags[a]
    H: 1280 2550 2560 2880
    V: 0800 0820 0840 0855
bus_format: 100e
VOP update mode to: 1280x800p37, type: MIPI0 for VP2
VP2 set crtc_clock to 90000KHz
VOP VP2 enable Esmart2[654x270->654x270@313x265] fmt[2] addr[0xedf04000]
final DSI-Link bandwidth: 600000 Kbps x 4
CLK: (uboot. arm: enter 1008000 KHz, init 1008000 KHz, kernel 0N/A)
  b0pll 24000 KHz
  b1pll 24000 KHz
  lpll 24000 KHz
  v0pll 630000 KHz
  aupll 786431 KHz
  cpll 1500000 KHz
  gpll 1188000 KHz
  npll 850000 KHz
  ppll 1100000 KHz
  aclk_center_root 702000 KHz
  pclk_center_root 100000 KHz
  hclk_center_root 396000 KHz
  aclk_center_low_root 500000 KHz
  aclk_top_root 594000 KHz
  pclk_top_root 100000 KHz
  aclk_low_top_root 396000 KHz
Net:   eth1: ethernet@fe1c0000, eth0: ethernet@fe1b0000
Hit key to stop autoboot('CTRL+C'):  0 
ANDROID: reboot reason: "recovery"
optee api revision: 2.0
TEEC: Waring: Could not find security partition
Not AVB images, AVB skip
No valid android hdr
Android image load failed
Android boot failed, error -1.
## Booting FIT Image at 0xe8c66580 with size 0x02b92a00
Fdt Ramdisk skip relocation
## Loading kernel from FIT Image at e8c66580 ...
   Using 'conf' configuration
## Verified-boot: 0
   Trying 'kernel' kernel subimage
     Description:  unavailable
     Type:         Kernel Image
     Compression:  uncompressed
     Data Start:   0xe8c8fd80
     Data Size:    34595328 Bytes = 33 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00400000
     Entry Point:  0x00400000
     Hash algo:    sha256
     Hash value:   caa128d4ee7581a89af7d4b6077a9b84ddaf8e6ae0f780782a9999f736ed2ba5
   Verifying Hash Integrity ... sha256+ OK
## Loading ramdisk from FIT Image at e8c66580 ...
   Using 'conf' configuration
   Trying 'ramdisk' ramdisk subimage
     Description:  unavailable
     Type:         RAMDisk Image
     Compression:  uncompressed
     Data Start:   0xead8df80
     Data Size:    10924032 Bytes = 10.4 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x0a200000
     Entry Point:  unavailable
     Hash algo:    sha256
     Hash value:   10cee262701f35253cfa30fd26b3b20a9e534624655c4acf084fb3369702ada0
   Verifying Hash Integrity ... sha256+ OK
   Loading ramdisk from 0xead8df80 to 0x0a200000
## Loading fdt from FIT Image at e8c66580 ...
   Using 'conf' configuration
   Trying 'fdt' fdt subimage
     Description:  unavailable
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0xe8c66d80
     Data Size:    167908 Bytes = 164 KiB
     Architecture: AArch64
     Load Address: 0x08300000
     Hash algo:    sha256
     Hash value:   1b28623c1b1f929584f14e4a89c37a43ec27cb6bbc6ea02df934bcee90e9a7e3
   Verifying Hash Integrity ... sha256+ OK
   Loading fdt from 0x08300000 to 0x08300000
   Booting using the fdt blob at 0x08300000
   Loading Kernel Image from 0xe8c8fd80 to 0x00400000 ... OK
   kernel loaded at 0x00400000, end = 0x024fe200
  'reserved-memory' cma: addr=10000000 size=8000000
  'reserved-memory' ramoops@110000: addr=110000 size=f0000
   Using Device Tree in place at 0000000008300000, end 000000000832bfe3
Adding bank: 0x00200000 - 0x08400000 (size: 0x08200000)
Adding bank: 0x09400000 - 0xf0000000 (size: 0xe6c00000)
Adding bank: 0x100000000 - 0x200000000 (size: 0x100000000)
Adding bank: 0x2f0000000 - 0x300000000 (size: 0x10000000)
Total: 1222.887 ms

Starting kernel ...

[    1.447477] 
[    1.447477]   _______                    _   
[    1.447477]  |__   __|                  | |  
[    1.447477]     | | ___  _ __   ___  ___| |_ 
[    1.447477]     | |/ _ \| '_ \ / _ \/ _ \ __|
[    1.447477]     | | (_) | |_) |  __/  __/ |_ 
[    1.447477]     |_|\___/| .__/ \___|\___|\__|
[    1.447477]             | |                  
[    1.447477]             |_|                  
[    1.447477] TOPEET BOARD:iTOP-RK3588
[    1.447477] http://www.topeetboard.com
[    1.447477] 
[    1.447501] Linux version 5.10.110 (topeet@ubuntu) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 10.3.1 20210621, GNU ld (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 2.36.1.20210621) #33 SMP Tue Jun 13 01:01:48 PDT 2023
[    1.459317] Machine model: Rockchip RK3588 EVB7 LP4 V10 Board
[    1.459396] earlycon: uart8250 at MMIO32 0x00000000feb50000 (options '')
[    1.550464] printk: bootconsole [uart8250] enabled
[    1.558372] efi: UEFI not found.
[    1.568127] OF: fdt: Reserved memory: failed to reserve memory for node 'drm-cubic-lut@00000000': base 0x0000000000000000, size 0 MiB
[    1.581122] Reserved memory: created CMA memory pool at 0x0000000010000000, size 128 MiB
[    1.589840] OF: reserved mem: initialized node cma, compatible id shared-dma-pool
[    1.742721] Zone ranges:
[    1.745463]   DMA      [mem 0x0000000000200000-0x00000000ffffffff]
[    1.752079]   DMA32    empty
[    1.755164]   Normal   [mem 0x0000000100000000-0x00000002ffffffff]
[    1.761751] Movable zone start for each node
[    1.766324] Early memory node ranges
[    1.770153]   node   0: [mem 0x0000000000200000-0x00000000083fffff]
[    1.776843]   node   0: [mem 0x0000000009400000-0x00000000efffffff]
[    1.783586]   node   0: [mem 0x0000000100000000-0x00000001ffffffff]
[    1.790328]   node   0: [mem 0x00000002f0000000-0x00000002ffffffff]
[    1.797009] Initmem setup node 0 [mem 0x0000000000200000-0x00000002ffffffff]
[    1.852644] psci: probing for conduit method from DT.
[    1.858084] psci: PSCIv1.1 detected in firmware.
[    1.863031] psci: Using standard PSCI v0.2 function IDs
[    1.868664] psci: Trusted OS migration not required
[    1.873898] psci: SMC Calling Convention v1.2
[    1.878985] percpu: Embedded 31 pages/cpu s88424 r8192 d30360 u126976
[    1.886109] Detected VIPT I-cache on CPU0
[    1.890468] CPU features: detected: GIC system register CPU interface
[    1.897358] CPU features: detected: Virtualization Host Extensions
[    1.904000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923
[    1.911478] alternatives: patching kernel code
[    1.916561] Built 1 zonelists, mobility grouping on.  Total pages: 2059848
[    1.923948] Kernel command line: storagemedia=emmc androidboot.storagemedia=emmc androidboot.mode=normal  root=PARTUUID=614e0000-0000 androidboot.verifiedbootstate=orange rw rootwait earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 irqchip.gicv3_pseudo_nmi=0
[    1.949819] Dentry cache hash table entries: 1048576 (order: 11, 8388608 bytes, linear)
[    1.958855] Inode-cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    1.967254] mem auto-init: stack:off, heap alloc:off, heap free:off
[    1.980169] software IO TLB: mapped [mem 0x00000000e9f00000-0x00000000edf00000] (64MB)
[    2.065382] Memory: 7965624K/8370176K available (17088K kernel code, 3448K rwdata, 6212K rodata, 6912K init, 571K bss, 273480K reserved, 131072K cma-reserved)
[    2.080731] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=8, Nodes=1
[    2.087834] ftrace: allocating 63833 entries in 250 pages
[    2.200072] ftrace: allocated 250 pages with 6 groups
[    2.205770] rcu: Hierarchical RCU implementation.
[    2.210815] rcu:     RCU event tracing is enabled.
[    2.215684]  Rude variant of Tasks RCU enabled.
[    2.220509]  Tracing variant of Tasks RCU enabled.
[    2.225708] rcu: RCU calculated value of scheduler-enlistment delay is 30 jiffies.
[    2.239831] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    2.248149] GICv3: GIC: Using split EOI/Deactivate mode
[    2.253784] GICv3: 480 SPIs implemented
[    2.257898] GICv3: 0 Extended SPIs implemented
[    2.262697] GICv3: Distributor has no Range Selector support
[    2.268794] GICv3: 16 PPIs implemented
[    2.272819] GICv3: CPU0: found redistributor 0 region 0:0x00000000fe680000
[    2.280311] ITS [mem 0xfe640000-0xfe65ffff]
[    2.284849] ITS@0x00000000fe640000: allocated 8192 Devices @100200000 (indirect, esz 8, psz 64K, shr 0)
[    2.294941] ITS@0x00000000fe640000: allocated 32768 Interrupt Collections @100210000 (flat, esz 2, psz 64K, shr 0)
[    2.306090] ITS: using cache flushing for cmd queue
[    2.311349] ITS [mem 0xfe660000-0xfe67ffff]
[    2.315889] ITS@0x00000000fe660000: allocated 8192 Devices @100230000 (indirect, esz 8, psz 64K, shr 0)
[    2.326058] ITS@0x00000000fe660000: allocated 32768 Interrupt Collections @100240000 (flat, esz 2, psz 64K, shr 0)
[    2.337207] ITS: using cache flushing for cmd queue
[    2.342621] GICv3: using LPI property table @0x0000000100250000
[    2.349032] GIC: using cache flushing for LPI property table
[    2.355095] GICv3: CPU0: using allocated LPI pending table @0x0000000100260000
[    2.363022] random: get_random_bytes called from start_kernel+0x3dc/0x5c8 with crng_init=0
[    2.484727] arch_timer: cp15 timer(s) running at 24.00MHz (phys).
[    2.500160] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns
[    2.511674] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns
[    2.521408] Console: colour dummy device 80x25
[    2.526215] Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj=80000)
[    2.537150] pid_max: default: 32768 minimum: 301
[    2.542216] Mount-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[    2.550423] Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[    2.560795] rcu: Hierarchical SRCU implementation.
[    2.566758] Platform MSI: msi-controller@fe640000 domain created
[    2.573245] Platform MSI: msi-controller@fe660000 domain created
[    2.579929] PCI/MSI: /interrupt-controller@fe600000/msi-controller@fe640000 domain created
[    2.588750] PCI/MSI: /interrupt-controller@fe600000/msi-controller@fe660000 domain created
[    2.597649] EFI services will not be available.
[    2.602869] smp: Bringing up secondary CPUs ...
I/TC: Secondary CPU 1 initializing
I/TC: Secondary CPU 1 switching to normal world boot
I/TC: Secondary CPU 2 initializing
I/TC: Secondary CPU 2 switching to normal world boot
I/TC: Secondary CPU 3 initializing
I/TC: Secondary CPU 3 switching to normal world boot
I/TC: Secondary CPU 4 initializing
I/TC: Secondary CPU 4 switching to normal world boot
I/TC: Secondary CPU 5 initializing
I/TC: Secondary CPU 5 switching to normal world boot
I/TC: Secondary CPU 6 initializing
I/TC: Secondary CPU 6 switching to normal world boot
I/TC: Secondary CPU 7 initializing
I/TC: Secondary CPU 7 switching to normal world boot
[    2.615960] Detected VIPT I-cache on CPU1
[    2.615996] GICv3: CPU1: found redistributor 100 region 0:0x00000000fe6a0000
[    2.616015] GICv3: CPU1: using allocated LPI pending table @0x0000000100270000
[    2.616059] CPU1: Booted secondary processor 0x0000000100 [0x412fd050]
[    2.624415] Detected VIPT I-cache on CPU2
[    2.624446] GICv3: CPU2: found redistributor 200 region 0:0x00000000fe6c0000
[    2.624463] GICv3: CPU2: using allocated LPI pending table @0x0000000100280000
[    2.624503] CPU2: Booted secondary processor 0x0000000200 [0x412fd050]
[    2.632834] Detected VIPT I-cache on CPU3
[    2.632862] GICv3: CPU3: found redistributor 300 region 0:0x00000000fe6e0000
[    2.632879] GICv3: CPU3: using allocated LPI pending table @0x0000000100290000
[    2.632917] CPU3: Booted secondary processor 0x0000000300 [0x412fd050]
[    2.641246] CPU features: detected: Spectre-v4
[    2.641249] CPU features: detected: Spectre-BHB
[    2.641252] Detected PIPT I-cache on CPU4
[    2.641266] GICv3: CPU4: found redistributor 400 region 0:0x00000000fe700000
[    2.641276] GICv3: CPU4: using allocated LPI pending table @0x00000001002a0000
[    2.641300] CPU4: Booted secondary processor 0x0000000400 [0x414fd0b0]
[    2.649586] Detected PIPT I-cache on CPU5
[    2.649601] GICv3: CPU5: found redistributor 500 region 0:0x00000000fe720000
[    2.649612] GICv3: CPU5: using allocated LPI pending table @0x00000001002b0000
[    2.649637] CPU5: Booted secondary processor 0x0000000500 [0x414fd0b0]
[    2.657933] Detected PIPT I-cache on CPU6
[    2.657948] GICv3: CPU6: found redistributor 600 region 0:0x00000000fe740000
[    2.657958] GICv3: CPU6: using allocated LPI pending table @0x00000001002c0000
[    2.657983] CPU6: Booted secondary processor 0x0000000600 [0x414fd0b0]
[    2.666263] Detected PIPT I-cache on CPU7
[    2.666278] GICv3: CPU7: found redistributor 700 region 0:0x00000000fe760000
[    2.666288] GICv3: CPU7: using allocated LPI pending table @0x00000001002d0000
[    2.666313] CPU7: Booted secondary processor 0x0000000700 [0x414fd0b0]
[    2.666383] smp: Brought up 1 node, 8 CPUs
[    2.866404] SMP: Total of 8 processors activated.
[    2.871437] CPU features: detected: Privileged Access Never
[    2.877407] CPU features: detected: User Access Override
[    2.883021] CPU features: detected: 32-bit EL0 Support
[    2.888479] CPU features: detected: Common not Private translations
[    2.895202] CPU features: detected: RAS Extension Support
[    2.900937] CPU features: detected: Data cache clean to the PoU not required for I/D coherence
[    2.910226] CPU features: detected: CRC32 instructions
[    2.915692] CPU features: detected: Speculative Store Bypassing Safe (SSBS)
[    2.923162] CPU features: detected: RCpc load-acquire (LDAPR)
[    2.929344] CPU: All CPU(s) started at EL2
[    2.935237] devtmpfs: initialized
[    2.949618] Registered cp15_barrier emulation handler
[    2.955024] Registered setend emulation handler
[    2.959943] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 6370867519511994 ns
[    2.970331] futex hash table entries: 2048 (order: 5, 131072 bytes, linear)
[    2.979091] pinctrl core: initialized pinctrl subsystem
[    2.984928] DMI not present or invalid.
[    2.989170] NET: Registered protocol family 16
[    2.994998] DMA: preallocated 1024 KiB GFP_KERNEL pool for atomic allocations
[    3.002646] DMA: preallocated 1024 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations
[    3.011657] thermal_sys: Registered thermal governor 'fair_share'
[    3.011660] thermal_sys: Registered thermal governor 'step_wise'
[    3.018187] thermal_sys: Registered thermal governor 'user_space'
[    3.024528] thermal_sys: Registered thermal governor 'power_allocator'
[    3.031099] thermal thermal_zone1: power_allocator: sustainable_power will be estimated
[    3.046574] thermal thermal_zone2: power_allocator: sustainable_power will be estimated
[    3.055085] thermal thermal_zone3: power_allocator: sustainable_power will be estimated
[    3.063634] thermal thermal_zone4: power_allocator: sustainable_power will be estimated
[    3.072162] thermal thermal_zone5: power_allocator: sustainable_power will be estimated
[    3.080681] thermal thermal_zone6: power_allocator: sustainable_power will be estimated
[    3.089187] cpuidle: using governor menu
[    3.093340] Registered FIQ tty driver
[    3.097415] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    3.104800] ASID allocator initialised with 65536 entries
[    3.111763] ramoops: dmesg-0 0x20000@0x0000000000110000
[    3.117377] ramoops: console 0x80000@0x0000000000130000
[    3.122911] ramoops: pmsg    0x50000@0x00000000001b0000
[    3.128445] printk: console [ramoops-1] enabled
[    3.133288] pstore: Registered ramoops as persistent store backend
[    3.139872] ramoops: using 0xf0000@0x110000, ecc: 0
[    3.190249] rockchip-gpio fd8a0000.gpio: probed /pinctrl/gpio@fd8a0000
[    3.197483] rockchip-gpio fec20000.gpio: probed /pinctrl/gpio@fec20000
[    3.204800] rockchip-gpio fec30000.gpio: probed /pinctrl/gpio@fec30000
[    3.212052] rockchip-gpio fec40000.gpio: probed /pinctrl/gpio@fec40000
[    3.219227] rockchip-gpio fec50000.gpio: probed /pinctrl/gpio@fec50000
[    3.226098] rockchip-pinctrl pinctrl: probed pinctrl
[    3.301010] raid6: neonx8   gen()  5572 MB/s
[    3.361105] raid6: neonx8   xor()  4326 MB/s
[    3.421203] raid6: neonx4   gen()  5713 MB/s
[    3.481303] raid6: neonx4   xor()  4345 MB/s
[    3.541401] raid6: neonx2   gen()  5249 MB/s
[    3.601500] raid6: neonx2   xor()  3999 MB/s
[    3.661596] raid6: neonx1   gen()  4429 MB/s
[    3.721696] raid6: neonx1   xor()  3549 MB/s
[    3.781809] raid6: int64x8  gen()  1382 MB/s
[    3.841896] raid6: int64x8  xor()   899 MB/s
[    3.902003] raid6: int64x4  gen()  1782 MB/s
[    3.962098] raid6: int64x4  xor()   990 MB/s
[    4.022188] raid6: int64x2  gen()  2487 MB/s
[    4.082280] raid6: int64x2  xor()  1351 MB/s
[    4.142383] raid6: int64x1  gen()  2037 MB/s
[    4.202475] raid6: int64x1  xor()  1109 MB/s
[    4.207031] raid6: using algorithm neonx4 gen() 5713 MB/s
[    4.212766] raid6: .... xor() 4345 MB/s, rmw enabled
[    4.218033] raid6: using neon recovery algorithm
[    4.223532] fiq_debugger fiq_debugger.0: IRQ fiq not found
[    4.229377] fiq_debugger fiq_debugger.0: IRQ wakeup not found
[    4.235478] fiq_debugger_probe: could not install nmi irq handler
[[    4.241983] printk: console [ttyFIQ0] enabled
    4.241983] printk: console [ttyFIQ0] enabled
[    4.250938] printk: bootconsole [uart8250] disabled
[    4.250938] printk: bootconsole [uart8250] disabled
[    4.256216] Registered fiq debugger ttyFIQ0
[    4.256570] vcc5v0_sys: supplied by vcc12v_dcin
[    4.256703] vcc5v0_usbdcin: supplied by vcc12v_dcin
[    4.256828] vcc5v0_usb: supplied by vcc5v0_usbdcin
[    4.257003] vcc_1v1_nldo_s3: supplied by vcc5v0_sys
[    4.257193] vcc3v3_pcie30: supplied by vcc12v_dcin
[    4.257346] vcc5v0_host: supplied by vcc5v0_usb
[    4.257684] vbus5v0_typec: supplied by vcc5v0_usb
[    4.258023] iommu: Default domain type: Translated 
[    4.258108] rk_iommu fdab9000.iommu: version = 2
[    4.258487] rk_iommu fdb50800.iommu: version = 2
[    4.258728] rk_iommu fdb60f00.iommu: version = 2
[    4.258915] rk_iommu fdb70f00.iommu: version = 2
[    4.259080] rk_iommu fdb90480.iommu: version = 2
[    4.259266] rk_iommu fdba0800.iommu: version = 2
[    4.259450] rk_iommu fdba4800.iommu: version = 2
[    4.259655] rk_iommu fdba8800.iommu: version = 2
[    4.259842] rk_iommu fdbac800.iommu: version = 2
[    4.260028] rk_iommu fdbb0800.iommu: version = 2
[    4.260221] rk_iommu fdbdf000.iommu: version = 2
[    4.260495] rk_iommu fdbef000.iommu: version = 2
[    4.260779] rk_iommu fdc38700.iommu: version = 2
[    4.261063] rk_iommu fdc48700.iommu: version = 2
[    4.261280] rk_iommu fdcb7f00.iommu: version = 2
[    4.261455] rk_iommu fdce0800.iommu: version = 2
[    4.261570] rk_iommu fdd97e00.iommu: version = 2
[    4.261912] SCSI subsystem initialized
[    4.261993] usbcore: registered new interface driver usbfs
[    4.262009] usbcore: registered new interface driver hub
[    4.262025] usbcore: registered new device driver usb
[    4.262061] mc: Linux media interface: v0.10
[    4.262073] videodev: Linux video capture interface: v2.00
[    4.262099] pps_core: LinuxPPS API ver. 1 registered
[    4.262103] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    4.262110] PTP clock support registered
[    4.262373] arm-scmi firmware:scmi: SCMI Notifications - Core Enabled.
[    4.262406] arm-scmi firmware:scmi: SCMI Protocol v2.0 'rockchip:' Firmware version 0x0
[    4.263673] Advanced Linux Sound Architecture Driver Initialized.
[    4.263867] Bluetooth: Core ver 2.22
[    4.263881] NET: Registered protocol family 31
[    4.263885] Bluetooth: HCI device and connection manager initialized
[    4.263891] Bluetooth: HCI socket layer initialized
[    4.263896] Bluetooth: L2CAP socket layer initialized
[    4.263904] Bluetooth: SCO socket layer initialized
[    4.265190] rockchip-cpuinfo cpuinfo: SoC            : 35881000
[    4.265196] rockchip-cpuinfo cpuinfo: Serial         : 394e7c3efbc10849
[    4.265578] clocksource: Switched to clocksource arch_sys_counter
[    4.583217] NET: Registered protocol family 2
[    4.583326] IP idents hash table entries: 131072 (order: 8, 1048576 bytes, linear)
[    4.585318] tcp_listen_portaddr_hash hash table entries: 4096 (order: 5, 163840 bytes, linear)
[    4.585411] TCP established hash table entries: 65536 (order: 7, 524288 bytes, linear)
[    4.585759] TCP bind hash table entries: 65536 (order: 9, 2097152 bytes, linear)
[    4.586493] TCP: Hash tables configured (established 65536 bind 65536)
[    4.586550] UDP hash table entries: 4096 (order: 6, 393216 bytes, linear)
[    4.586698] UDP-Lite hash table entries: 4096 (order: 6, 393216 bytes, linear)
[    4.586904] NET: Registered protocol family 1
[    4.587211] RPC: Registered named UNIX socket transport module.
[    4.587217] RPC: Registered udp transport module.
[    4.587220] RPC: Registered tcp transport module.
[    4.587224] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    4.587602] PCI: CLS 0 bytes, default 64
[    4.587876] Trying to unpack rootfs image as initramfs...
[    4.876529] Freeing initrd memory: 10668K
[    4.877308] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    4.880351] Initialise system trusted keyrings
[    4.880444] workingset: timestamp_bits=46 max_order=21 bucket_order=0
[    4.882756] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    4.883059] NFS: Registering the id_resolver key type
[    4.883069] Key type id_resolver registered
[    4.883073] Key type id_legacy registered
[    4.883090] ntfs: driver 2.1.32 [Flags: R/O].
[    4.883177] jffs2: version 2.
~~~







正常的打印

~~~shell
DDR V1.09 a930779e06 typ 22/11/21-17:50:56
LPDDR4X, 2112MHz
channel[0] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[1] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[2] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
channel[3] BW=16 Col=10 Bk=8 CS0 Row=16 CS1 Row=16 CS=2 Die BW=16 Size=2048MB
Manufacturer ID:0x6
CH0 RX Vref:31.7%, TX Vref:23.8%,22.8%
CH1 RX Vref:33.7%, TX Vref:22.8%,23.8%
CH2 RX Vref:32.7%, TX Vref:21.8%,20.8%
CH3 RX Vref:31.7%, TX Vref:21.8%,21.8%
change to F1: 528MHz
change to F2: 1068MHz
change to F3: 1560MHz
change to F0: 2112MHz
out
U-Boot SPL board init
U-Boot SPL 2017.09-gc060f28d70-220414 #zyf (Apr 18 2022 - 18:13:34)
Failed to set cpub01
Failed to set cpub23
unknown raw ID phN
unrecognized JEDEC id bytes: 00, 00, 00
Trying to boot from MMC2
MMC: no card present
mmc_init: -123, time 2
spl: mmc init failed with error: -123
Trying to boot from MMC1
Trying fit image at 0x4000 sector
## Verified-boot: 0
## Checking atf-1 0x00040000 ... sha256(045b2cef29...) + OK
## Checking uboot 0x00200000 ... sha256(91161ac802...) + OK
## Checking fdt 0x0033d2d8 ... sha256(a4d6ae0a3e...) + OK
## Checking atf-2 0x000f0000 ... sha256(30812190d0...) + OK
## Checking atf-3 0xff100000 ... sha256(cb7bdbec2b...) + OK
## Checking optee 0x08400000 ... sha256(fde0860845...) + OK
Jumping to U-Boot(0x00200000) via ARM Trusted Firmware(0x00040000)
Total: 177.167 ms

INFO:    Preloader serial: 2
NOTICE:  BL31: v2.3():v2.3-481-g17b41886e:derrick.huang
NOTICE:  BL31: Built : 16:20:07, Dec  7 2022
INFO:    spec: 0x1
INFO:    ext 32k is not valid
INFO:    ddr: stride-en 4CH
INFO:    GICv3 without legacy support detected.
INFO:    ARM GICv3 driver initialized in EL3
INFO:    valid_cpu_msk=0xff bcore0_rst = 0x0, bcore1_rst = 0x0
INFO:    system boots from cpu-hwid-0
INFO:    idle_st=0x21fff, pd_st=0x11fff9, repair_st=0xfff70001
INFO:    dfs DDR fsp_params[0].freq_mhz= 2112MHz
INFO:    dfs DDR fsp_params[1].freq_mhz= 528MHz
INFO:    dfs DDR fsp_params[2].freq_mhz= 1068MHz
INFO:    dfs DDR fsp_params[3].freq_mhz= 1560MHz
INFO:    BL31: Initialising Exception Handling Framework
INFO:    BL31: Initializing runtime services
INFO:    BL31: Initializing BL32
INFO:    hdmirx_handler: dma not on, ret
I/TC: 
I/TC: OP-TEE version: 3.13.0-652-g4542e1efd #derrick.huang (gcc version 10.2.1 20201103 (GNU Toolchain for the A-profile Architecture 10.2-2020.11 (arm-10.16))) #5 2022年 09月 20日 星期二 09:41:09 CST aarch64
I/TC: Primary CPU initializing
I/TC: Primary CPU switching to normal world boot
INFO:    BL31: Preparing for EL3 exit to normal world
INFO:    Entry point address = 0x200000
INFO:    SPSR = 0x3c9


U-Boot 2017.09 (Nov 07 2023 - 01:52:43 -0800)

Model: TOPEET iTOP-RK3588 Board 
PreSerial: 2, raw, 0xfeb50000
DRAM:  8 GiB
Sysmem: init
Relocation Offset: eda3a000
Relocation fdt: eb9f9f98 - eb9fecc0
CR: M/C/I
mmc@fe2c0000: 1, mmc@fe2e0000: 0
Bootdev(atags): mmc 0
MMC0: HS200, 200Mhz
PartType: EFI
DM: v2
boot mode: None
FIT: no signed, no conf required
DTB: rk-kernel.dtb
HASH(c): OK
I2c0 speed: 100000Hz
vsel-gpios- not found!
en-gpios- not found!
vdd_cpu_big0_s0 800000 uV
vsel-gpios- not found!
en-gpios- not found!
vdd_cpu_big1_s0 800000 uV
I2c1 speed: 100000Hz
vsel-gpios- not found!
en-gpios- not found!
vdd_npu_s0 800000 uV
spi2: RK806: 2
ON=0x00, OFF=0x00
vdd_gpu_s0 750000 uV
vdd_cpu_lit_s0 750000 uV
vdd_log_s0 750000 uV
vdd_vdenc_s0 init 750000 uV
vdd_ddr_s0 850000 uV
*** Warning - bad CRC, using default environment

Model: TOPEET RK3588S LP4X V10 Board
CLK: (uboot. arm: enter 1008000 KHz, init 1008000 KHz, kernel 0N/A)
  b0pll 24000 KHz
  b1pll 24000 KHz
  lpll 24000 KHz
  v0pll 24000 KHz
  aupll 786431 KHz
  cpll 1500000 KHz
  gpll 1188000 KHz
  npll 850000 KHz
  ppll 1100000 KHz
  aclk_center_root 702000 KHz
  pclk_center_root 100000 KHz
  hclk_center_root 396000 KHz
  aclk_center_low_root 500000 KHz
  aclk_top_root 594000 KHz
  pclk_top_root 100000 KHz
  aclk_low_top_root 396000 KHz
Net:   eth1: ethernet@fe1c0000
Hit key to stop autoboot('CTRL+C'):  0 
ANDROID: reboot reason: "(none)"
optee api revision: 2.0
TEEC: Waring: Could not find security partition
Not AVB images, AVB skip
No valid android hdr
Android image load failed
Android boot failed, error -1.
## Booting FIT Image at 0xe96c9980 with size 0x0212f600
Fdt Ramdisk skip relocation
## Loading kernel from FIT Image at e96c9980 ...
   Using 'conf' configuration
## Verified-boot: 0
   Trying 'kernel' kernel subimage
     Description:  unavailable
     Type:         Kernel Image
     Compression:  uncompressed
     Data Start:   0xe96f1580
     Data Size:    34634240 Bytes = 33 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00400000
     Entry Point:  0x00400000
     Hash algo:    sha256
     Hash value:   e5aaf8b1b5aebef2eaecc747ad18f1b3107b680f318fbd5c8f0f5b4ffca10eae
   Verifying Hash Integrity ... sha256+ OK
## Loading fdt from FIT Image at e96c9980 ...
   Using 'conf' configuration
   Trying 'fdt' fdt subimage
     Description:  unavailable
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0xe96ca180
     Data Size:    160617 Bytes = 156.9 KiB
     Architecture: AArch64
     Load Address: 0x08300000
     Hash algo:    sha256
     Hash value:   9e2d4613e19b19fa536a484b769e147007e30ac6c291b1e2c78d22c3254378a4
   Verifying Hash Integrity ... sha256+ OK
   Loading fdt from 0x08300000 to 0x08300000
   Booting using the fdt blob at 0x08300000
   Loading Kernel Image from 0xe96f1580 to 0x00400000 ... OK
   kernel loaded at 0x00400000, end = 0x02507a00
  'reserved-memory' cma: addr=10000000 size=8000000
  'reserved-memory' ramoops@110000: addr=110000 size=f0000
   Using Device Tree in place at 0000000008300000, end 000000000832a368
Adding bank: 0x00200000 - 0x08400000 (size: 0x08200000)
Adding bank: 0x09400000 - 0xf0000000 (size: 0xe6c00000)
Adding bank: 0x100000000 - 0x200000000 (size: 0x100000000)
Adding bank: 0x2f0000000 - 0x300000000 (size: 0x10000000)
Total: 835.285 ms

Starting kernel ...

[    1.061605] 
[    1.061605]   _______                    _   
[    1.061605]  |__   __|                  | |  
[    1.061605]     | | ___  _ __   ___  ___| |_ 
[    1.061605]     | |/ _ \| '_ \ / _ \/ _ \ __|
[    1.061605]     | | (_) | |_) |  __/  __/ |_ 
[    1.061605]     |_|\___/| .__/ \___|\___|\__|
[    1.061605]             | |                  
[    1.061605]             |_|                  
[    1.061605] TOPEET BOARD:iTOP-RK3588
[    1.061605] http://www.topeetboard.com
[    1.061605] 
[    1.061627] Linux version 5.10.110 (topeet@ubuntu) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 10.3.1 20210621, GNU ld (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 2.36.1.20210621) #1 SMP Fri Dec 22 00:39:46 PST 2023
[    1.072188] Machine model: TOPEET RK3588S LP4X V10 Board
[    1.072262] earlycon: uart8250 at MMIO32 0x00000000feb50000 (options '')
[    1.163382] printk: bootconsole [uart8250] enabled
[    1.170992] efi: UEFI not found.
[    1.180094] OF: fdt: Reserved memory: failed to reserve memory for node 'drm-logo@00000000': base 0x0000000000000000, size 0 MiB
[    1.192585] OF: fdt: Reserved memory: failed to reserve memory for node 'drm-cubic-lut@00000000': base 0x0000000000000000, size 0 MiB
[    1.205599] Reserved memory: created CMA memory pool at 0x0000000010000000, size 128 MiB
[    1.214290] OF: reserved mem: initialized node cma, compatible id shared-dma-pool
[    1.357359] Zone ranges:
[    1.360089]   DMA      [mem 0x0000000000200000-0x00000000ffffffff]
[    1.366809]   DMA32    empty
[    1.369902]   Normal   [mem 0x0000000100000000-0x00000002ffffffff]
[    1.376619] Movable zone start for each node
[    1.381217] Early memory node ranges
[    1.385081]   node   0: [mem 0x0000000000200000-0x00000000083fffff]
[    1.391865]   node   0: [mem 0x0000000009400000-0x00000000efffffff]
[    1.398633]   node   0: [mem 0x0000000100000000-0x00000001ffffffff]
[    1.405435]   node   0: [mem 0x00000002f0000000-0x00000002ffffffff]
[    1.412211] Initmem setup node 0 [mem 0x0000000000200000-0x00000002ffffffff]
[    1.465067] psci: probing for conduit method from DT.
[    1.470531] psci: PSCIv1.1 detected in firmware.
[    1.475512] psci: Using standard PSCI v0.2 function IDs
[    1.481171] psci: Trusted OS migration not required
[    1.486422] psci: SMC Calling Convention v1.2
[    1.491483] percpu: Embedded 31 pages/cpu s88424 r8192 d30360 u126976
[    1.498663] Detected VIPT I-cache on CPU0
[    1.503017] CPU features: detected: GIC system register CPU interface
[    1.509983] CPU features: detected: Virtualization Host Extensions
[    1.516712] CPU features: detected: ARM errata 1165522, 1319367, or 1530923
[    1.524293] alternatives: patching kernel code
[    1.529387] Built 1 zonelists, mobility grouping on.  Total pages: 2059848
[    1.536757] Kernel command line: storagemedia=emmc androidboot.storagemedia=emmc androidboot.mode=normal  root=/dev/mmcblk0p6 androidboot.verifiedbootstate=orange rw rootwait earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 irqchip.gicv3_pseudo_nmi=0
[    1.562075] Dentry cache hash table entries: 1048576 (order: 11, 8388608 bytes, linear)
[    1.571126] Inode-cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    1.579541] mem auto-init: stack:off, heap alloc:off, heap free:off
[    1.592244] software IO TLB: mapped [mem 0x00000000ec000000-0x00000000f0000000] (64MB)
[    1.674878] Memory: 7977020K/8370176K available (17088K kernel code, 3486K rwdata, 6224K rodata, 6912K init, 571K bss, 262084K reserved, 131072K cma-reserved)
[    1.690314] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=8, Nodes=1
[    1.697451] ftrace: allocating 63902 entries in 250 pages
[    1.803887] ftrace: allocated 250 pages with 6 groups
[    1.809636] rcu: Hierarchical RCU implementation.
[    1.814690] rcu:     RCU event tracing is enabled.
[    1.819576]  Rude variant of Tasks RCU enabled.
[    1.824452]  Tracing variant of Tasks RCU enabled.
[    1.829589] rcu: RCU calculated value of scheduler-enlistment delay is 30 jiffies.
[    1.843441] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    1.851449] GICv3: GIC: Using split EOI/Deactivate mode
[    1.857084] GICv3: 480 SPIs implemented
[    1.861215] GICv3: 0 Extended SPIs implemented
[    1.866066] GICv3: Distributor has no Range Selector support
[    1.872214] GICv3: 16 PPIs implemented
[    1.876315] GICv3: CPU0: found redistributor 0 region 0:0x00000000fe680000
[    1.883849] ITS [mem 0xfe640000-0xfe65ffff]
[    1.888424] ITS@0x00000000fe640000: allocated 8192 Devices @100200000 (indirect, esz 8, psz 64K, shr 0)
[    1.898616] ITS@0x00000000fe640000: allocated 32768 Interrupt Collections @100210000 (flat, esz 2, psz 64K, shr 0)
[    1.909798] ITS: using cache flushing for cmd queue
[    1.915106] ITS [mem 0xfe660000-0xfe67ffff]
[    1.919673] ITS@0x00000000fe660000: allocated 8192 Devices @100230000 (indirect, esz 8, psz 64K, shr 0)
[    1.929821] ITS@0x00000000fe660000: allocated 32768 Interrupt Collections @100240000 (flat, esz 2, psz 64K, shr 0)
[    1.941028] ITS: using cache flushing for cmd queue
[    1.946434] GICv3: using LPI property table @0x0000000100250000
[    1.952927] GIC: using cache flushing for LPI property table
[    1.959082] GICv3: CPU0: using allocated LPI pending table @0x0000000100260000
[    1.967033] random: get_random_bytes called from start_kernel+0x3dc/0x5c8 with crng_init=0
[    2.090146] arch_timer: cp15 timer(s) running at 24.00MHz (phys).
[    2.105085] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns
[    2.116319] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns
[    2.125681] Console: colour dummy device 80x25
[    2.130358] Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj=80000)
[    2.141118] pid_max: default: 32768 minimum: 301
[    2.146124] Mount-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[    2.154034] Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)
[    2.164090] rcu: Hierarchical SRCU implementation.
[    2.169951] Platform MSI: msi-controller@fe640000 domain created
[    2.176298] Platform MSI: msi-controller@fe660000 domain created
[    2.182922] PCI/MSI: /interrupt-controller@fe600000/msi-controller@fe640000 domain created
[    2.191567] PCI/MSI: /interrupt-controller@fe600000/msi-controller@fe660000 domain created
[    2.200317] EFI services will not be available.
[    2.205421] smp: Bringing up secondary CPUs ...
I/TC: Secondary CPU 1 initializing
I/TC: Secondary CPU 1 switching to normal world boot
I/TC: Secondary CPU 2 initializing
I/TC: Secondary CPU 2 switching to normal world boot
I/TC: Secondary CPU 3 initializing
I/TC: Secondary CPU 3 switching to normal world boot
I/TC: Secondary CPU 4 initializing
I/TC: Secondary CPU 4 switching to normal world boot
I/TC: Secondary CPU 5 initializing
I/TC: Secondary CPU 5 switching to normal world boot
I/TC: Secondary CPU 6 initializing
I/TC: Secondary CPU 6 switching to normal world boot
I/TC: Secondary CPU 7 initializing
I/TC: Secondary CPU 7 switching to normal world boot
[    2.218390] Detected VIPT I-cache on CPU1
[    2.218423] GICv3: CPU1: found redistributor 100 region 0:0x00000000fe6a0000
[    2.218440] GICv3: CPU1: using allocated LPI pending table @0x0000000100270000
[    2.218485] CPU1: Booted secondary processor 0x0000000100 [0x412fd050]
[    2.226808] Detected VIPT I-cache on CPU2
[    2.226835] GICv3: CPU2: found redistributor 200 region 0:0x00000000fe6c0000
[    2.226850] GICv3: CPU2: using allocated LPI pending table @0x0000000100280000
[    2.226888] CPU2: Booted secondary processor 0x0000000200 [0x412fd050]
[    2.235182] Detected VIPT I-cache on CPU3
[    2.235207] GICv3: CPU3: found redistributor 300 region 0:0x00000000fe6e0000
[    2.235222] GICv3: CPU3: using allocated LPI pending table @0x0000000100290000
[    2.235258] CPU3: Booted secondary processor 0x0000000300 [0x412fd050]
[    2.243552] CPU features: detected: Spectre-v4
[    2.243555] CPU features: detected: Spectre-BHB
[    2.243558] Detected PIPT I-cache on CPU4
[    2.243572] GICv3: CPU4: found redistributor 400 region 0:0x00000000fe700000
[    2.243580] GICv3: CPU4: using allocated LPI pending table @0x00000001002a0000
[    2.243604] CPU4: Booted secondary processor 0x0000000400 [0x414fd0b0]
[    2.251857] Detected PIPT I-cache on CPU5
[    2.251872] GICv3: CPU5: found redistributor 500 region 0:0x00000000fe720000
[    2.251881] GICv3: CPU5: using allocated LPI pending table @0x00000001002b0000
[    2.251905] CPU5: Booted secondary processor 0x0000000500 [0x414fd0b0]
[    2.260171] Detected PIPT I-cache on CPU6
[    2.260186] GICv3: CPU6: found redistributor 600 region 0:0x00000000fe740000
[    2.260194] GICv3: CPU6: using allocated LPI pending table @0x00000001002c0000
[    2.260218] CPU6: Booted secondary processor 0x0000000600 [0x414fd0b0]
[    2.268472] Detected PIPT I-cache on CPU7
[    2.268487] GICv3: CPU7: found redistributor 700 region 0:0x00000000fe760000
[    2.268495] GICv3: CPU7: using allocated LPI pending table @0x00000001002d0000
[    2.268519] CPU7: Booted secondary processor 0x0000000700 [0x414fd0b0]
[    2.268586] smp: Brought up 1 node, 8 CPUs
[    2.464144] SMP: Total of 8 processors activated.
[    2.469073] CPU features: detected: Privileged Access Never
[    2.474824] CPU features: detected: User Access Override
[    2.480385] CPU features: detected: 32-bit EL0 Support
[    2.485816] CPU features: detected: Common not Private translations
[    2.492382] CPU features: detected: RAS Extension Support
[    2.498046] CPU features: detected: Data cache clean to the PoU not required for I/D coherence
[    2.507118] CPU features: detected: CRC32 instructions
[    2.512426] CPU features: detected: Speculative Store Bypassing Safe (SSBS)
[    2.519696] CPU features: detected: RCpc load-acquire (LDAPR)
[    2.525783] CPU: All CPU(s) started at EL2
[    2.531407] devtmpfs: initialized
[    2.544782] Registered cp15_barrier emulation handler
[    2.550171] Registered setend emulation handler
[    2.555044] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 6370867519511994 ns
[    2.565476] futex hash table entries: 2048 (order: 5, 131072 bytes, linear)
[    2.574153] pinctrl core: initialized pinctrl subsystem
[    2.579915] DMI not present or invalid.
[    2.584082] NET: Registered protocol family 16
[    2.589843] DMA: preallocated 1024 KiB GFP_KERNEL pool for atomic allocations
[    2.597540] DMA: preallocated 1024 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations
[    2.606405] thermal_sys: Registered thermal governor 'fair_share'
[    2.606407] thermal_sys: Registered thermal governor 'step_wise'
[    2.612855] thermal_sys: Registered thermal governor 'user_space'
[    2.619273] thermal_sys: Registered thermal governor 'power_allocator'
[    2.625860] thermal thermal_zone1: power_allocator: sustainable_power will be estimated
[    2.641190] thermal thermal_zone2: power_allocator: sustainable_power will be estimated
[    2.649734] thermal thermal_zone3: power_allocator: sustainable_power will be estimated
[    2.658262] thermal thermal_zone4: power_allocator: sustainable_power will be estimated
[    2.666875] thermal thermal_zone5: power_allocator: sustainable_power will be estimated
[    2.675383] thermal thermal_zone6: power_allocator: sustainable_power will be estimated
[    2.683837] cpuidle: using governor menu
[    2.688007] Registered FIQ tty driver
[    2.692087] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    2.699410] ASID allocator initialised with 65536 entries
[    2.706264] ramoops: dmesg-0 0x20000@0x0000000000110000
[    2.711824] ramoops: console 0x80000@0x0000000000130000
[    2.717435] ramoops: pmsg    0x50000@0x00000000001b0000
[    2.722986] printk: console [ramoops-1] enabled
[    2.727794] pstore: Registered ramoops as persistent store backend
[    2.734378] ramoops: using 0xf0000@0x110000, ecc: 0
[    2.781997] rockchip-gpio fd8a0000.gpio: probed /pinctrl/gpio@fd8a0000
[    2.789138] rockchip-gpio fec20000.gpio: probed /pinctrl/gpio@fec20000
[    2.796326] rockchip-gpio fec30000.gpio: probed /pinctrl/gpio@fec30000
[    2.803510] rockchip-gpio fec40000.gpio: probed /pinctrl/gpio@fec40000
[    2.810689] rockchip-gpio fec50000.gpio: probed /pinctrl/gpio@fec50000
[    2.817684] rockchip-pinctrl pinctrl: probed pinctrl
[    2.890564] raid6: neonx8   gen()  5852 MB/s
[    2.950655] raid6: neonx8   xor()  4544 MB/s
[    3.010751] raid6: neonx4   gen()  6003 MB/s
[    3.070841] raid6: neonx4   xor()  4566 MB/s
[    3.130936] raid6: neonx2   gen()  5514 MB/s
[    3.191028] raid6: neonx2   xor()  4315 MB/s
[    3.251120] raid6: neonx1   gen()  4656 MB/s
[    3.311213] raid6: neonx1   xor()  3735 MB/s
[    3.371315] raid6: int64x8  gen()  1461 MB/s
[    3.431410] raid6: int64x8  xor()   935 MB/s
[    3.491492] raid6: int64x4  gen()  1873 MB/s
[    3.551584] raid6: int64x4  xor()  1033 MB/s
[    3.611678] raid6: int64x2  gen()  2610 MB/s
[    3.671768] raid6: int64x2  xor()  1418 MB/s
[    3.731856] raid6: int64x1  gen()  2139 MB/s
[    3.791949] raid6: int64x1  xor()  1164 MB/s
[    3.796470] raid6: using algorithm neonx4 gen() 6003 MB/s
[    3.802196] raid6: .... xor() 4566 MB/s, rmw enabled
[    3.807446] raid6: using neon recovery algorithm
[    3.812886] fiq_debugger fiq_debugger.0: IRQ fiq not found
[    3.818727] fiq_debugger fiq_debugger.0: IRQ wakeup not found
[    3.824837] fiq_debugger_probe: could not install nmi irq handler
[[    3.831280] printk: console [ttyFIQ0] enabled
    3.831280] printk: console [ttyFIQ0] enabled
[    3.840252] printk: bootconsole [uart8250] disabled
[    3.840252] printk: bootconsole [uart8250] disabled
[    3.845551] Registered fiq debugger ttyFIQ0
[    3.845876] vcc5v0_sys: supplied by vcc12v_dcin
[    3.846001] vcc5v0_usbdcin: supplied by vcc12v_dcin
[    3.846119] vcc5v0_usb: supplied by vcc5v0_usbdcin
[    3.846243] vcc_1v1_nldo_s3: supplied by vcc5v0_sys
[    3.846407] vcc5v0_host: supplied by vcc5v0_usb
[    3.846713] vbus5v0_typec: supplied by vcc5v0_usb
[    3.847005] iommu: Default domain type: Translated 
[    3.847084] rk_iommu fdab9000.iommu: version = 2
[    3.847436] rk_iommu fdb50800.iommu: version = 2
[    3.847675] rk_iommu fdb60f00.iommu: version = 2
[    3.847854] rk_iommu fdb70f00.iommu: version = 2
[    3.848014] rk_iommu fdb90480.iommu: version = 2
[    3.848193] rk_iommu fdba0800.iommu: version = 2
[    3.848370] rk_iommu fdba4800.iommu: version = 2
[    3.848550] rk_iommu fdba8800.iommu: version = 2
[    3.848732] rk_iommu fdbac800.iommu: version = 2
[    3.848922] rk_iommu fdbb0800.iommu: version = 2
[    3.849113] rk_iommu fdbdf000.iommu: version = 2
[    3.849381] rk_iommu fdbef000.iommu: version = 2
[    3.849654] rk_iommu fdc38700.iommu: version = 2
[    3.849930] rk_iommu fdc48700.iommu: version = 2
[    3.850071] rk_iommu fdd97e00.iommu: version = 2
[    3.850379] SCSI subsystem initialized
[    3.850456] usbcore: registered new interface driver usbfs
[    3.850472] usbcore: registered new interface driver hub
[    3.850487] usbcore: registered new device driver usb
[    3.850524] mc: Linux media interface: v0.10
[    3.850536] videodev: Linux video capture interface: v2.00
[    3.850561] pps_core: LinuxPPS API ver. 1 registered
[    3.850565] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    3.850572] PTP clock support registered
[    3.850820] arm-scmi firmware:scmi: SCMI Notifications - Core Enabled.
[    3.850852] arm-scmi firmware:scmi: SCMI Protocol v2.0 'rockchip:' Firmware version 0x0
[    3.851918] Advanced Linux Sound Architecture Driver Initialized.
[    3.852109] Bluetooth: Core ver 2.22
[    3.852123] NET: Registered protocol family 31
[    3.852126] Bluetooth: HCI device and connection manager initialized
[    3.852144] Bluetooth: HCI socket layer initialized
[    3.852149] Bluetooth: L2CAP socket layer initialized
[    3.852157] Bluetooth: SCO socket layer initialized
[    3.853425] rockchip-cpuinfo cpuinfo: SoC            : 35880000
[    3.853431] rockchip-cpuinfo cpuinfo: Serial         : bbc04aeed2e2ceec
[    3.853778] clocksource: Switched to clocksource arch_sys_counter
[    4.157980] NET: Registered protocol family 2
[    4.158088] IP idents hash table entries: 131072 (order: 8, 1048576 bytes, linear)
[    4.159987] tcp_listen_portaddr_hash hash table entries: 4096 (order: 5, 163840 bytes, linear)
[    4.160078] TCP established hash table entries: 65536 (order: 7, 524288 bytes, linear)
[    4.160399] TCP bind hash table entries: 65536 (order: 9, 2097152 bytes, linear)
[    4.161133] TCP: Hash tables configured (established 65536 bind 65536)
[    4.161191] UDP hash table entries: 4096 (order: 6, 393216 bytes, linear)
[    4.161332] UDP-Lite hash table entries: 4096 (order: 6, 393216 bytes, linear)
[    4.161529] NET: Registered protocol family 1
[    4.161834] RPC: Registered named UNIX socket transport module.
[    4.161839] RPC: Registered udp transport module.
[    4.161842] RPC: Registered tcp transport module.
[    4.161845] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    4.162250] PCI: CLS 0 bytes, default 64
[    4.163185] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    4.165789] Initialise system trusted keyrings
[    4.165874] workingset: timestamp_bits=46 max_order=21 bucket_order=0
[    4.168091] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    4.168367] NFS: Registering the id_resolver key type
[    4.168378] Key type id_resolver registered
[    4.168382] Key type id_legacy registered
[    4.168397] ntfs: driver 2.1.32 [Flags: R/O].
[    4.168479] jffs2: version 2.2. (NAND) © 2001-2006 Red Hat, Inc.
[    4.168565] fuse: init (API version 7.32)
[    4.168707] SGI XFS with security attributes, no debug enabled
[    4.188540] NET: Registered protocol family 38
[    4.188547] xor: measuring software checksum speed
[    4.190018]    8regs           :  6715 MB/sec
[    4.191130]    32regs          :  8930 MB/sec
[    4.192065]    arm64_neon      : 10865 MB/sec
[    4.192068] xor: using function: arm64_neon (10865 MB/sec)
[    4.192074] Key type asymmetric registered
[    4.192078] Asymmetric key parser 'x509' registered
[    4.192094] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 242)
[    4.192188] io scheduler mq-deadline registered
[    4.192194] io scheduler kyber registered
[    4.200614] rockchip-usbdp-phy: probe of fed80000.phy failed with error -16
[    4.202013] rk-pcie fe190000.pcie: invalid prsnt-gpios property in node
[    4.202057] rk-pcie fe190000.pcie: no vpcie3v3 regulator found
[    4.202189] pwm-backlight backlight: supply power not found, using dummy regulator
[    4.202240] of_pwm_get(): can't parse "pwms" property
[    4.202245] pwm-backlight backlight: unable to request PWM
[    4.202306] pwm-backlight: probe of backlight failed with error -2
[    4.202332] rk-pcie fe190000.pcie: missing legacy IRQ resource
[    4.202353] rk-pcie fe190000.pcie: IRQ msi not found
[    4.202359] mpp_service mpp-srv: unknown mpp version for missing VCS info
[    4.202363] mpp_service mpp-srv: probe start
[    4.202368] rk-pcie fe190000.pcie: use outband MSI support
[    4.202373] rk-pcie fe190000.pcie: Missing *config* reg space
[    4.202391] rk-pcie fe190000.pcie: host bridge /pcie@fe190000 ranges:
[    4.202417] rk-pcie fe190000.pcie:      err 0x00f4000000..0x00f40fffff -> 0x00f4000000
[    4.202437] rk-pcie fe190000.pcie:       IO 0x00f4100000..0x00f41fffff -> 0x00f4100000
[    4.202457] rk-pcie fe190000.pcie:      MEM 0x00f4200000..0x00f4ffffff -> 0x00f4200000
[    4.202473] rk-pcie fe190000.pcie:      MEM 0x0a00000000..0x0a3fffffff -> 0x0a00000000
[    4.202505] rk-pcie fe190000.pcie: Missing *config* reg space
[    4.202542] rk-pcie fe190000.pcie: invalid resource
[    4.203374] mpp_vdpu1 fdb51000.avsd-plus: Adding to iommu group 1
[    4.203532] mpp_vdpu1 fdb51000.avsd-plus: probe device
[    4.203642] mpp_vdpu1 fdb51000.avsd-plus: reset_group->rw_sem_on=0
[    4.203650] mpp_vdpu1 fdb51000.avsd-plus: reset_group->rw_sem_on=0
[    4.203759] mpp_vdpu1 fdb51000.avsd-plus: probing finish
[    4.204089] mpp_vdpu2 fdb50400.vdpu: Adding to iommu group 1
[    4.204180] mpp_vdpu2 fdb50400.vdpu: probe device
[    4.204267] mpp_vdpu2 fdb50400.vdpu: reset_group->rw_sem_on=0
[    4.204272] mpp_vdpu2 fdb50400.vdpu: reset_group->rw_sem_on=0
[    4.204350] mpp_vdpu2 fdb50400.vdpu: probing finish
[    4.204507] mpp_vepu2 jpege-ccu: probing start
[    4.204513] mpp_vepu2 jpege-ccu: probing finish
[    4.204622] mpp_vepu2 fdb50000.vepu: Adding to iommu group 1
[    4.204661] mpp_vepu2 fdb50000.vepu: probing start
[    4.204742] mpp_vepu2 fdb50000.vepu: reset_group->rw_sem_on=0
[    4.204748] mpp_vepu2 fdb50000.vepu: reset_group->rw_sem_on=0
[    4.204824] mpp_vepu2 fdb50000.vepu: probing finish
[    4.204890] mpp_vepu2 fdba0000.jpege-core: Adding to iommu group 5
[    4.204972] mpp_vepu2 fdba0000.jpege-core: probing start
[    4.205065] mpp_vepu2 fdba0000.jpege-core: attach ccu success
[    4.205143] mpp_vepu2 fdba0000.jpege-core: probing finish
[    4.205212] mpp_vepu2 fdba4000.jpege-core: Adding to iommu group 6
[    4.205291] mpp_vepu2 fdba4000.jpege-core: probing start
[    4.205383] mpp_vepu2 fdba4000.jpege-core: attach ccu success
[    4.205462] mpp_vepu2 fdba4000.jpege-core: probing finish
[    4.205531] mpp_vepu2 fdba8000.jpege-core: Adding to iommu group 7
[    4.205617] mpp_vepu2 fdba8000.jpege-core: probing start
[    4.205715] mpp_vepu2 fdba8000.jpege-core: attach ccu success
[    4.205796] mpp_vepu2 fdba8000.jpege-core: probing finish
[    4.205862] mpp_vepu2 fdbac000.jpege-core: Adding to iommu group 8
[    4.205952] mpp_vepu2 fdbac000.jpege-core: probing start
[    4.206044] mpp_vepu2 fdbac000.jpege-core: attach ccu success
[    4.206128] mpp_vepu2 fdbac000.jpege-core: probing finish
[    4.206353] mpp-iep2 fdbb0000.iep: Adding to iommu group 9
[    4.206441] mpp-iep2 fdbb0000.iep: probe device
[    4.206554] mpp-iep2 fdbb0000.iep: allocate roi buffer failed
[    4.206620] mpp-iep2 fdbb0000.iep: probing finish
[    4.206787] mpp_jpgdec fdb90000.jpegd: Adding to iommu group 4
[    4.206941] mpp_jpgdec fdb90000.jpegd: probe device
[    4.207128] mpp_jpgdec fdb90000.jpegd: probing finish
[    4.207461] mpp_rkvdec2 fdc30000.rkvdec-ccu: rkvdec-ccu, probing start
[    4.207516] mpp_rkvdec2 fdc30000.rkvdec-ccu: probing finish
[    4.207600] mpp_rkvdec2 fdc38100.rkvdec-core: Adding to iommu group 12
[    4.207854] mpp_rkvdec2 fdc38100.rkvdec-core: rkvdec-core, probing start
[    4.207964] mpp_rkvdec2 fdc38100.rkvdec-core: shared_niu_a is not found!
[    4.207969] rkvdec2_init:1010: No niu aclk reset resource define
[    4.207974] mpp_rkvdec2 fdc38100.rkvdec-core: shared_niu_h is not found!
[    4.207977] rkvdec2_init:1013: No niu hclk reset resource define
[    4.208003] mpp_rkvdec2 fdc38100.rkvdec-core: no regulator, devfreq is disabled
[    4.208052] mpp_rkvdec2 fdc38100.rkvdec-core: core_mask=00010001
[    4.208057] mpp_rkvdec2 fdc38100.rkvdec-core: attach ccu as core 0
[    4.208199] mpp_rkvdec2 fdc38100.rkvdec-core: sram_start 0x00000000ff001000
[    4.208203] mpp_rkvdec2 fdc38100.rkvdec-core: rcb_iova 0x00000000fff00000
[    4.208207] mpp_rkvdec2 fdc38100.rkvdec-core: sram_size 491520
[    4.208211] mpp_rkvdec2 fdc38100.rkvdec-core: rcb_size 1048576
[    4.208216] mpp_rkvdec2 fdc38100.rkvdec-core: min_width 512
[    4.208246] mpp_rkvdec2 fdc38100.rkvdec-core: probing finish
[    4.208318] mpp_rkvdec2 fdc48100.rkvdec-core: Adding to iommu group 13
[    4.208547] mpp_rkvdec2 fdc48100.rkvdec-core: rkvdec-core, probing start
[    4.208654] mpp_rkvdec2 fdc48100.rkvdec-core: shared_niu_a is not found!
[    4.208659] rkvdec2_init:1010: No niu aclk reset resource define
[    4.208663] mpp_rkvdec2 fdc48100.rkvdec-core: shared_niu_h is not found!
[    4.208666] rkvdec2_init:1013: No niu hclk reset resource define
[    4.208692] mpp_rkvdec2 fdc48100.rkvdec-core: no regulator, devfreq is disabled
[    4.208731] mpp_rkvdec2 fdc48100.rkvdec-core: core_mask=00020002
[    4.208748] mpp_rkvdec2 fdc48100.rkvdec-core: attach ccu as core 1
[    4.208911] mpp_rkvdec2 fdc48100.rkvdec-core: sram_start 0x00000000ff079000
[    4.208915] mpp_rkvdec2 fdc48100.rkvdec-core: rcb_iova 0x00000000ffe00000
[    4.208919] mpp_rkvdec2 fdc48100.rkvdec-core: sram_size 487424
[    4.208923] mpp_rkvdec2 fdc48100.rkvdec-core: rcb_size 1048576
[    4.208928] mpp_rkvdec2 fdc48100.rkvdec-core: min_width 512
[    4.208957] mpp_rkvdec2 fdc48100.rkvdec-core: probing finish
[    4.209121] mpp_rkvenc2 rkvenc-ccu: probing start
[    4.209127] mpp_rkvenc2 rkvenc-ccu: probing finish
[    4.209244] mpp_rkvenc2 fdbd0000.rkvenc-core: Adding to iommu group 10
[    4.209443] mpp_rkvenc2 fdbd0000.rkvenc-core: probing start
[    4.209459] mpp_rkvenc2 fdbd0000.rkvenc-core: link mode task capacity 8
[    4.209595] mpp_rkvenc2 fdbd0000.rkvenc-core: attach ccu as core 0
[    4.209678] mpp_rkvenc2 fdbd0000.rkvenc-core: probing finish
[    4.209737] mpp_rkvenc2 fdbe0000.rkvenc-core: Adding to iommu group 11
[    4.209951] mpp_rkvenc2 fdbe0000.rkvenc-core: probing start
[    4.209967] mpp_rkvenc2 fdbe0000.rkvenc-core: link mode task capacity 8
[    4.210122] mpp_rkvenc2 fdbe0000.rkvenc-core: attach ccu as core 1
[    4.210204] mpp_rkvenc2 fdbe0000.rkvenc-core: probing finish
[    4.210696] mpp_av1dec: Adding child /av1d@fdc70000
[    4.210914] mpp_av1dec: register device av1d-master
[    4.210932] mpp_av1dec av1d-master: av1_iommu_of_xlate,784
[    4.210952] av1_iommu_probe_device,736, consumer : av1d-master, supplier : fdca0000.iommu
[    4.210959] mpp_av1dec av1d-master: Adding to iommu group 15
[    4.211180] mpp_av1dec av1d-master: probing start
[    4.211367] mpp_av1dec av1d-master: probing finish
[    4.211403] mpp_service mpp-srv: probe success
[    4.218820] dma-pl330 fea10000.dma-controller: Loaded driver for PL330 DMAC-241330
[    4.218829] dma-pl330 fea10000.dma-controller:       DBUFF-128x8bytes Num_Chans-8 Num_Peri-32 Num_Events-16
[    4.219674] dma-pl330 fea30000.dma-controller: Loaded driver for PL330 DMAC-241330
[    4.219682] dma-pl330 fea30000.dma-controller:       DBUFF-128x8bytes Num_Chans-8 Num_Peri-32 Num_Events-16
[    4.220544] dma-pl330 fed10000.dma-controller: Loaded driver for PL330 DMAC-241330
[    4.220552] dma-pl330 fed10000.dma-controller:       DBUFF-128x8bytes Num_Chans-8 Num_Peri-32 Num_Events-16
[    4.220981] rockchip-pvtm fda40000.pvtm: pvtm@0 probed
[    4.221040] rockchip-pvtm fda50000.pvtm: pvtm@1 probed
[    4.221092] rockchip-pvtm fda60000.pvtm: pvtm@2 probed
[    4.221144] rockchip-pvtm fdaf0000.pvtm: pvtm@3 probed
[    4.221193] rockchip-pvtm fdb30000.pvtm: pvtm@4 probed
~~~



~~~shell
ln -s  rk3588/BoardConfig-rk3588-topeet.mk .BoardConfig.mk
~~~

将一个文件进行软链接



# 12.21 工作记录

3588 邮票孔触摸搞完了、3588的镜像也更新完成了，没啥活了呀，今天应该是要搞3588s的硬件手册，这次直接从0开始，之前的问题可真的太大了，都不知道哪里有错误。

## 1.未来的规划

先像一个流水账简单的写一下我要做的事情，其实要做的事情真的挺多的，尤其是这一系列衍生出来的东西。并不是这一件事情做完就不再做了，而是有很多，先来按大的项目来分。

1. 3588S 一系列手册的编写、源码的配置
2. 基础视频的录制
3. Linux驱动视频手册的编写

## 2. 3588S

首先说一下我有疑问的地方！！！！！！

问题1：为什么核心板的原理图不开源呢？

​	可能各有各的想法，在公司的角度上应该是避免客户自己做底板，从某种意义上来说，我们其实也是客户，我们跟客户的立场其实是一致的，客户有的我们都有，客户没有的我们都没有，唯一有区别的地方在于，客户不需要写相关的手册和文档，而我们是要写文档、配置源码的，所以我会有这个抱怨，但是站在公司的角度，这个做法确实是没问题的，所以抱怨就抱怨了，后面我在做硬件复用手册的时候，看看怎样做才能更好的让客户所接受呢？而且一定要保证相应的准确率，在3568和3588上面有问题的地方就挺多的，也是当时理解不了，认知层次的问题。

目前有问题的地方就这一个，其他倒也还好，这是3588要搞的一些东西，具体如下所示：

![image-20231221145051349](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312211450382.png)

对于源码这件事情我认为不能随随便便的就搞了，也并不是移植一下就能搞好的，除此之外还有源码的瘦身、源码的优化等等，我继续列举我能想到的东西：

- 无用的设备树应该删掉，现在的设备树里面有很多无用的节点，虽然他们最终并不会有效果，但是很影响后面的阅读、修改，让我来搞的话必须整理，而且要写上相关的注释，而至于git的使用，可以先等等。
- 真正的理解瑞芯微的编译脚本，一年多的时间过去了，其实你都没有真正的理解瑞芯微的脚本，有哪些是需要保留的、又有哪些是无用的，甚至还可以再美化，添加图形界面，等等都是可以的。
- 去掉Linux SDK里面那些无用的东西，有很多东西其实保留下来并没有什么用，平白无故的占地方罢了，裁剪、瘦身源码。

然后是手册相关的问题，里面的一些东西是不是需要补充，有些东西是不是需要进行替换，从0搭建ubuntu开发环境是不是需要补充，问题还是很多的。

## 3.Linux驱动手册

之前已经写好的前面12章的手册,怎么说呢，其实倒像是为了完成而完成，那些更深层次的东西其实还差点很多，自身积累还不够，虽然也不可能在第一次就做好，但总应该尽力而为，更重要的是要有自己的思考，之前写那玩意的时候还没有搞博客，还不会写markdown，如今应该就好多了，慢慢来。

## 4.基础视频的录制

也不能说这个是最难的吧，但这个肯定是最心累的，录课并不是简简单单的讲两个命令就可以的，还有更多深层次的东西，就比如shell编程、Makefile脚本等一系列的内容、甚至还有那一系列ide软件的使用，环境的搭建等等，而且这些都要在一个完整的条条框框下，才能开展，总不能今天讲解这个，明天讲解那个，对吧，每一个视频跟每一个视频都不能联系在一起，这必然是不符合道理的，这些都需要一点一点的来进行规划，就先这样了，一直思考不进行任何的行动，那肯定是不行的。目前就先这样，我先去简单的认识一下3588S.

## 5.3588s基本认识

[准备博客](https://blog.csdn.net/weixin_43245753/article/details/124375165?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170314644216777224432722%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170314644216777224432722&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-124375165-null-null.142^v96^pc_search_result_base5&utm_term=3588S%E5%92%8C3588&spm=1018.2226.3001.4187)

| 特性                               | RK3588                                                    | RK3588S                                                   |
| :--------------------------------- | :-------------------------------------------------------- | :-------------------------------------------------------- |
| 封装                               | 23*23 mm, 0.65 pitch                                      | 17*17 mm, 0.4 pitch                                       |
| USB                                | 2 x USB3.1 + 2 x USB2.0 OTG (两组完整Typec)               | 1 x USB3.1 + 1 x USB2.0 OTG (一组完整Typec)               |
| 显示输出                           | TYPEC/DP1.4 复用，2 x 4-lane DP1.4                        | TYPEC/DP1.4 复用，1 x 4-lane DP1.4                        |
| 显示输出                           | 2 x HDMI2.1 TX / eDP1.4                                   | 1 x HDMI2.1 TX / eDP1.4                                   |
| 摄像头/显示输入                    | MIPI CSI DPHY: 2 x 4-lanes 或 4 x 2-lanes                 | MIPI CSI DPHY: 1 x 4-lanes 或 2 x 2-lanes                 |
| HDMI RX                            | HDMI2.0 RX                                                | 无                                                        |
| PCIe 3.0                           | 2 x 2-lanes PCIe3.0                                       | 无                                                        |
| PCIe 2.0/SATA 3.0/USB 3.0 复用接口 | 3 × 1-lane PCIE2.0/3 组 SATA 3.0/1 x USB3.0 (USB栏已体现) | 2 × 1-lane PCIE2.0/2 组 SATA 3.0/1 x USB3.0 (USB栏已体现) |
| SARADC                             | 8 个                                                      | 6 个                                                      |
| SDIO                               | 一组 SDIO，IOMUX 到两个位置                               | 一组 SDIO，IOMUX 到一个位置                               |
| GMAC                               | 2 组 (GMAC0 + GMAC1)                                      | 1 组 (GMAC1)                                              |

# 12.20 工作记录

问题可真的多呀,终于是将一些问题堆砌的差不多了，先总结一下。

## 1.更新3588镜像和源码

更新了这么多天了，这是真的不容易呀，但目前仍旧还是存在问题，也就是在系统版本的选择上，还存在一些争议，目前提供的都是xfce的构建，这个以后再说吧，但是这次肯定是要缓存的，这么多的镜像构建脚本，要是丢了，那可真的太难了。备份过程如下所示：
![image-20231220154800638](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201548741.png)

等着备份完成吧。

## 2.重新规划目录

现在无论是网盘、我自己的硬盘、亦或者是nas还有网盘，都养成良好的规范习惯，目前在F盘也就是日常工作盘，里面的文件都是按日期来划分的，这样也好

![image-20231220154910903](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201549937.png)

这样可以直观的看到每天都做了哪些任务，反正两个T的机械硬盘肯定够用了，无论干什么都够了，除此之外我还将nas里的内容进行了规整，删掉了那些无用的资料：
![image-20231220160048983](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201600021.png)

![image-20231220160138990](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201601024.png)

本来用到其他板子的概率就很低，所有这里直接放到other目录里了，在nas的根目录下还有着每个人的共享文件夹，我可以将一些有用的东西放这里。

最后将百度网盘里的一些资料我也进行了整理，目前也都是有相应的标号和分类，具体如下所示：
![image-20231220160830829](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201608873.png)

具体有没有效果咱不知道，但是赏心悦目确实是。

## 3.编译3588 邮票孔安卓

目前客户那边的问题是，使用0826日期的源码，也根据手册修改了，屏幕能正常亮，但是触摸出现了问题，客户将镜像发到了这边，这边测试发现也是同样的问题，具体的报错如下所示：

![image-20231220161520404](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312201615175.png)

看打印感觉是设备树的配置有问题，但是奇怪的是，他的这个镜像在3588全能板子上就能用，同样的系统，同样的显示屏





















# 12.19 工作记录



测试昨天编译完成的两个镜像，分别是ubuntu20 的XFCE镜像和ubuntu22的xfce镜像。

## 1.继续解决沾滞键问题

还是没办法解决，不知道为什么，这个先暂时搁置，目前就先这样了。

## 2.gnome桌面

其实也就无非几个库而已，大佬的构建方式也已经开源了，所以我用人家的deb包完全没有问题

## 3.镜像和源码的更新

首先修改我的编译脚本，添加对应的ubuntu22—gnome的。添加完成。

~~~shell
XZ_OPT="-0 -T0" tar -cpJvf update_rk3588.tar.xz update_rk3588
~~~

以后压缩就用这个了。

# 12.18 工作记录

​	周六的时候重新更新了一下镜像，并且完善了3568和3588的构建脚本，但是3588目前仍旧是有一些问题，目前有问题的地方在图形化界面和MPV,其实之前的MPV也能用吧，唯一有问题的地方在于ubuntu20绿屏，其他倒是没啥.

==*现在怀疑的是某些包的问题，可是这些包在rk3568上是没问题的，那些包的唯一区别就是RGA的版本不一样，原因真的在这里吗，可能吧。*==现在先去看看香橙派的那些版本的镜像，看看xfce桌面的GPU版本.

## 1.虚拟机nat模式

现在的问题是虚拟机和主机之间的速度我还是不满意，现在的速度限制在了50-100，这个限制主要是当前内网千兆限制的，而我的电脑网卡是2500兆的.理论上的速度可以达到300M每秒，所以我将网络换为了NAT模式，具体如下所示：

![image-20231218110016233](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312181100278.png)

添加了一个网卡，将这个网卡设置为NAT模式，这样虚拟机就有两个网卡了，一个是直连，可以用来和服务器啥的通信，一个可以是走的就是我的本地回环了，也就是我的本地机器的网卡，我的网卡是2500M的速度，测试的速度如下所示

![image-20231218105450909](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312181054983.png)

以后下载的东西就放在F盘里面了，速度也不慢，能跑满机械的速度，当然你要是想再参谋一个2T硬盘也不是不行，哈哈，没必要了。

## 2.ubuntu问题寻找

目前感觉是drm和xserver的问题，所以这里换回了之前的xserver和drm，重新编译试试。	

~~~
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/chromium/chromium-codecs-ffmpeg-extra_110.0.5481.4-0ubuntu1~jammy~rkmpp20230130_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/chromium/chromium-browser_110.0.5481.4-0ubuntu1~jammy~rkmpp20230130_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/chromium/chromium-browser-l10n_110.0.5481.4-0ubuntu1~jammy~rkmpp20230130_all.deb"
                #dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/chromium/chromium-chromedriver_110.0.5481.4-0ubuntu1~jammy~rkmpp20230130_arm64.deb"
                cp $EXTER/cache/sources/rk3588_packages_jammy/chromium/default $SDCARD/etc/chromium-browser/

                ## for panfork
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/mali-g610-firmware_1.0.0-1_all.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgbm1_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgbm-dev_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libglapi-mesa_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgl1-mesa-dri_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libegl-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libglx-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                # Improve mesa performance
                echo "PAN_MESA_DEBUG=gofaster" >> $SDCARD/etc/environment
~~~

问题可能找到了，但无法定位，只能扩大ubuntu的容量了，这个没办法，本来安装的是core，现在来安装完整的desktop镜像，这是没办法的事情，目前来看问题不大，这样也好，所有的命令都统一了，也还行吧。

~~~
apt-get -y install ubuntu-desktop dbus-x11 xterm pulseaudio pavucontrol qtwayland5 
~~~







~~~
mali-g610-firmware_1.0.0-1_all.deb libgbm1_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb libgbm-dev_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb  libglapi-mesa_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb libgl1-mesa-dri_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb libegl-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb libglx-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb
~~~









































# 12.16 工作记录

​	遇到的问题挺多的，但总归是要一点一点的解决的，饭要一口一口吃，路要一步一步走。

​	昨天将3568和3588的一键编译脚本写了一下，倒是有用，最大的一点好处就是，终于可以不用在一个一个镜像的编译了，真的浪费心神，就很无语，所有之前为什么没有去解决这个问题呢，有问题当然要解决了。

## 1.windows安装ssh 服务端

先说一下需求，目前呢我只能在windows拉取或者推送文件到uubntu，但是并不能在ubuntu直接拉取windows的东西，这就很不方便，所以找到了下面的方法。

首先找到应用。然后点击添加可选功能，如下图所示：

![image-20231216101623640](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161016732.png)

​	搜索ssh，你会看到一个openssh服务端，具体如下所示：
![image-20231216101709975](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161017025.png)

勾选之后安装即可。输入命令在PowerShell(管理员）模式下操作

输入命令来查看OpenSSH服务器与客户端是否安装完成，安装完成如图下所示

~~~
 Get-WindowsCapability -Online | ? Name -like 'OpenSSH*'
~~~

![image-20231216101857012](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161018244.png)

然后输入以下命令开启ssh，如下图所示：

```sql
net start sshd
```

![image-20231216101933702](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161019791.png)

 输入命令ssh localhost检查连接状态，图下所示表示连接正常

```undefined
ssh localhost
```

![image-20231216101957944](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161019071.png)

开机自启动SSH

~~~
Set-Service -Name sshd -StartupType 'Automatic'
~~~

到这里就可以了，这里的密码遇到了问题，需要重新设置一下密码，在这个地方：
![image-20231216104719070](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161047119.png)

uubntu直接拉取windows文件内容成功如下所示：

```
scp -r Administrator@192.168.1.11:F:/02_3588编译脚本/*
```

![image-20231216104745847](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312161047161.png)

需要注意的是这里的盘符路径需要加个冒号，我就困扰在了这个地方，所以一直失败。

注：==nas的话ssh是不行的，一直检测不到盘符，就先这样把==

## 2.更新快速构建脚本

## 3.测试ubuntu镜像

从昨天开始就发现了一些问题，在3588上会卡死，但是之前就没有遇到过这个情况，我先来测试3568的，先测试的是3568的debian10，debian10 目前的问题是mpv不能调用mpp所以在使用mpv播放 1080p视频的时候，CPU会利用率过高，但是并没有出现所谓的难用的情况。
	   然后测试了3568的ubuntu20，我的使用情况依然很流畅，最后再测试3568的uubntu22，























# 12.15工作记录

## 1.更新3568 源码和镜像

## 2.更新3588源码和镜像

​	修改：修改分区文件，默认将文件系统分区改为

```
CMDLINE: mtdparts=rk29xxnand:0x00002000@0x00004000(uboot),0x00002000@0x00006000(misc),0x00020000@0x00008000(b
oot),0x00040000@0x00028000(recovery),0x00010000@0x00068000(backup),0x02e00000@0x00078000(rootfs),0x00040000@0
x02e78000(oem),-@0x02eb8000(userdata:grow) 
```

默认23G

##  3.完善全部镜像编译的脚本

### 3.1 rk3568

首先可以进行选择，根据文件系统镜像的类型来划分，具体如下所示：
~~~
buildroot
debian10
debian11
ubuntu20
ubuntu22
yocto
all
~~~



~~~shell
#!/bin/bash

echo "请选择一个选项："
echo "1. buildroot"
echo "2. debian10"
echo "3. debian11"
echo "4. ubuntu20"
echo "5. ubuntu22"
echo "6. yocto"
echo "7. all"

read -p "请输入选项: " choice

case $choice in
    1)
        echo "您选择了 buildroot"
        ;;
    2)
        echo "您选择了 debian10"
        ;;
    3)
        echo "您选择了 debian11"
        ;;
    4)
        echo "您选择了 ubuntu20"
        ;;
    5)
        echo "您选择了 ubuntu22"
        ;;
    6)
        echo "您选择了 yocto"
        ;;
    7)
        echo "您选择了 all"
        ;;
    *)
        echo "无效的选项"
        ;;
esac
~~~











# 12.14日工作记录



## 1.debian系统继续更新_3588

这次直接以3568的debian11为蓝本进行修改。

1.修改开机启动的打印

2.摄像头的iqfile文件

3.GPU的驱动固件

4.RGA要改

5.RKAIQ要改

6.rkmpp-v4l2

## 2.3588 debian12

没问题就行

## 3.qt5.15的编译和运行

​	首先将提供好的ubuntu-focal-arm64.tar.xz压缩包传输到虚拟机ubuntu上，拷贝完成如下所示：
![image-20231214145445998](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509467.png)

然后使用以下命令进行解压

~~~shell
tar -vxf ubuntu-focal-arm64.tar.xz
~~~

解压完成之后会在生成一个build目录,如下所示：

![image-20231214145526924](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509387.png)

然后使用==cd build/binary==命令进入binary文件系统源码目录，进入之后如下所示：
![image-20231214145649952](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509500.png)

该源码就是烧写到开发板ubuntu镜像的源码，然后将要编译的qt工程放到该目录下，这里以rk3568的QLed测试为例进行编译的演示，工程拷贝完成如下所示：
![image-20231214145947186](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509481.png)	然后使用以下命令更改根目录到该ubuntu下，更改完成如下所示：

~~~
chroot .
~~~

![image-20231214150055553](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509507.png)

现在根用户就切换到上面解压出的ubuntu源码目录下了。然后进入QLed命令，运行以下命令构建该QT工程的Makefile，如下图所示：

~~~
/opt/qt5.15.2/bin/qmake
~~~

![image-20231214150257774](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509460.png)

先使用以下命令来进行工程的清理,清理过程如下所示：

~~~
make clean
~~~

![image-20231214150340328](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509947.png)

然后使用==make==命令进行工程的构建，构建过程如下所示：

![image-20231214150446114](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509047.png)

至此，qt的编译就完成了，然后将编译生成的可执行文件传输到开发板上。传输完成如下所示：
![image-20231214150613802](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509967.png)

直接运行该可执行文件即可，运行之后的打印如下所示（这些报错可以忽略，不影响实际效果）：

![image-20231214150651556](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509998.png)

QT显示效果如下所示：

![image-20231214150729348](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141509013.png)

## 4.3568 源码更新

- 修改1：打开ch341
- 修改2：解决buildroot系统 usb键盘的问题
- 修改3：更新ubutnu和debian系统
- 修改4：解决摄像头可能顺光发绿的问题
- 



## 5.scp无需密码验证

这不就是创造需求了吗，每一次我复制本地虚拟机ubuntu的文件，或者向上推送一个文件都要输入一个命令，虽然输入命令很简单把，但是输入的多了，就会烦人，所以就去搜索了ssh免密码。

![image-20231214160739634](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141607695.png)

在机器Client上root用户执行ssh-keygen命令，生成建立安全信任关系的证书。

~~~shell
ssh-keygen -b 1024 -t rsa
~~~

我这里将密钥地址放在了/C/Users/Administrator/.ssh/id_rsa目录下，执行过程如下所示：
![image-20231214161222875](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312141612921.png)

在程序提示输入passphrase时直接输入回车，表示无证书密码。上述命令将生成私钥证书id_rsa和公钥证书id_rsa.pub，存放在用户家目录的.ssh子目录中。

将公钥证书id_rsa.pub复制到机器Server的root和topeet家目录的.ssh子目录中，同时将文件名更换为authorized_keys。

~~~shell
scp.exe id_rsa.pub root@192.168.1.41:/root/.ssh/authorized_keys
scp.exe id_rsa.pub topeet@192.168.1.41:/home/topeet/.ssh/authorized_keys
~~~

可以了，但是上面的那个路径是不对的，不知道为啥我这里的电脑只能为啥是在D:\cadence\Cadence\SPB_Data\.ssh路径，不是很懂。。。。

















# 12.13日工作记录

## 1.安卓12动画的问题

如果仅仅是那个开场动画的问题，很是简单，只需让客户简单修改一下即可，目前问题就在这里了，但是客户后面出现的,搞完了，没啥问题了，打包一下源码即可。

## 2.ubutnu继续更新

今天将各个版本的ubuntu整理好，终于是发现了一个很重要的知识点了。那就是为什么在目前的XFCE桌面中无论是3568还是3588都不能在图形界面显示图形显卡，但是glmark-es 的测试却没问题，这是因为在那些桌面中只支持opengl选渲染，而瑞芯微提供的arm闭源驱动里，并没有对opengl的支持，所以图形界面没有加速。这也就是为什么选用xfce桌面的理由。

![image-20231213133404477](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312131334549.png)

而XFCE是与X11集成在一起的，他们之间的联系如下：XFCE和X11之间有密切的关系，因为XFCE是一个基于X11的桌面环境。

X11，也称为X Window System或X，是一种用于图形用户界面（GUI）的开放标准协议和软件栈。它提供了一种在计算机显示器上绘制图形和处理用户输入的机制。X11为用户提供了一个窗口化的桌面环境，并允许多个应用程序并发运行，并与显示器、键盘和鼠标等输入设备进行交互。

XFCE是一个轻量级的桌面环境，旨在提供简单、快速和易于使用的用户体验。XFCE的设计目标之一是在保持低系统资源消耗的同时提供现代的桌面功能。XFCE桌面环境构建在X11之上，并使用X11协议来管理窗口、绘制图形、处理用户输入等。

具体地说，XFCE使用X11的客户端-服务器模型。X11服务器（也称为X服务器）运行在计算机上，负责与显示器和输入设备进行通信，并提供图形显示和用户输入处理的基本功能。XFCE作为X11的客户端运行在X服务器之上，利用X11协议与X服务器进行通信，请求绘制窗口、处理鼠标和键盘事件等。

通过与X11的集成，XFCE能够利用X11的功能和特性，实现窗口管理、窗口装饰、窗口移动和调整大小、多任务处理、窗口间通信等桌面环境的基本功能。

而现在提供的镜像都是X11的，对应的deb文件也是X11的，但因为提供的deb文件不支持opengl，所以桌面加速仍旧不支持。有个人是这样写的[博客](https://blog.csdn.net/qq_43862401/article/details/133846232?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170244697016800213045976%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170244697016800213045976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-133846232-null-null.142^v96^pc_search_result_base5&utm_term=3588%20gpu&spm=1018.2226.3001.4187)，

~~~
	opi官方提供了debian的xfce和kde桌面的镜像，提供了ubuntu的xfce和gnome桌面的镜像。
以上镜像，除了gnome之外，用的GPU驱动都是arm官方的闭源驱动libmali，只支持openGL ES和openCL。由于wayland方式需要openGL支持，而openGL ES仅仅是openGL的子集，所以官方驱动其实并不支持wayland方式。也就是说，使用官方驱动的镜像都只能使用xorg的显示服务器。

有困难就会有人解决，据网友willzen所说，有大佬做了rk3588的开源GPU驱动panfrost，这个驱动支持完整的openGL，opi官方就是用的这个开源驱动去做的gnome桌面，但由于这个开源驱动不支持openCL(或者说有bug，反正就是不支持xorg)，所以也只能选择wayland的显示方式，如果选xorg则会出问题。
总结：
	官方闭源驱动——支持openGL ES和openCL——只能使用xorg显示服务器
	某开源驱动——支持完整的openGL但不支持openCL——只能使用wayland显示服务器
~~~

我还是不懂呀，先这样吧，对于这个层面的理解确实不多呀，先更新了全部的镜像再说。gnome的就先这样子，现在先去搞debian的

## 3.debian镜像的更新

debian10仍旧以ubuntu20的构建脚本为蓝本进行修改

修改1：打包的名称 共有三个地方

修改2：构建需要的镜像源 两个地方

修改3：xfce桌面安装task-xfce-minimal

修改4：删掉默认的ffmpeg，debian10



debian11仍旧以ubuntu22的构建脚本为蓝本进行修改

修改1：打包的名称 共有三个地方

修改2：构建需要的镜像源 两个地方

修改3：xfce桌面安装task-xfce-minimal

修改4：删掉默认的ffmpeg，debian10





# 12.12日工作记录

## 1.nfc问题

在昨天晚上下班前将客户的底板进行了简单的焊接修改，将原本的NFC模块取下来，然后将昨天邮寄过来的模块进行更换，发现问题依旧，所以现在排除了模块的问题，然后更换了一个I2C数据线，发现问题还是，这也就排除了I2C的问题，然后IRQ引脚也修改过了，另外两个功能IO也测试过了，都可以正常的使用，那问题可就太奇怪了，不知道问题出在哪里了~~，现在板子已经邮寄回去了，等之后有结果了再说吧。

## 2.安卓12 动画问题

昨天下午已经找到问题了，但是现在要在客户的源码上来进行，客户的源码总共是遇到了两个问题，第一个是解压的问题，具体打印如下所示：
![image-20231212163100645](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312121631914.png)

这里要选择SA，然后是第二个，报了一堆不相干的错误，但不知道为啥会这样，但幸好有其他人遇到过所以也就还好，解决方法如下所示：![image-20231212163152391](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312121631420.png)

修改完成之后，源码就可以正常编译了，在编译之前还需要根据昨天写的手册将开机动画进行删除，步骤如下所示：测试发现，经过上面修改之后会在开机之后仍旧先加载到桌面，随后才进入相应的app，又经过测试发现这是开机动画的影响，所以仍旧需要下面的操作关掉启动中的动画。

**步骤一：**

~~~
vim frameworks/base/services/core/java/com/android/server/wm/ActivityRecord.java
~~~

在onWindowsDrawn方法的最后添加下面的内容

~~~java
//解锁后退出开机动画
// phoebe add for exit bootanim start
if (isHomeIntent(intent) && shortComponentName != null && !shortComponentName.contains("FallbackHome")) {
    SystemProperties.set("service.bootanim.exit", "1");
    android.util.Log.e("ActivityRecord", "real home....." + shortComponentName);

    try {
        IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
        if (surfaceFlinger != null) {
            Slog.i(TAG_WM, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
            Parcel data = Parcel.obtain();
            data.writeInterfaceToken("android.ui.ISurfaceComposer");
            surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                    data, null, 0);
            data.recycle();
        }
    } catch (RemoteException ex) {
        Slog.e(TAG, "Boot completed: SurfaceFlinger is dead!");
    }
}
// phoebe add for exit bootanim end
~~~

**步骤2**

~~~
vim frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
~~~

注释以下内容：
![image-20231211144308708](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111443061.png)

**步骤3：**

~~~
vim packages/apps/Settings/src/com/android/settings/FallbackHome.java
~~~

注释掉下面的内容：	

![image-20231211144520230](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111445364.png)

随后编译重新烧写即可：

~~~shell
source javaenv.sh 
java -version 
lunch rk3588_s-userdebug
./build.sh -AUCKu
~~~

至此，嘉丰伟业的也就解决了。

## 3.3568和3588 ubutnu22

昨天其实也在搞，但也仅仅是高了一点点，































# 12.11日工作记录

## 1.继续研究安卓启动的那个问题

问题描述：客户要修改默认的launcher,根据安卓11的修改方式修改之后，发现确实跟客户的描述相同，会先进入默认的桌面：
![image-20231211125659596](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111257275.png)

目前来看要解决这个问题我并没有什么好的方法，问题1 为什么同样的方法在安卓11就可以在安卓12就不行呢？我找到的可能的原因是这样的：
**12**带来的一个巨大的变化之一就是导航栏从SystemUI整合到了Launcher3QuickStep，众所周知, 曾经的**SystemUI**才是导航栏的拥有者, 把导航栏交给Launcher这意味着, 以后的Launcher, 不是你想动就能动的了.要替换Launcher的就好好考虑清楚了。

1. **移除默认Launcher**：
   - 在`PRODUCT_PACKAGES`中确保没有包含任何默认的Launcher（如`Launcher3`, `Launcher3QuickStep`等）。
   - 检查`device.mk`或类似的设备特定的make文件，确保它们没有包含默认的Launcher。
2. **修改Intent Filter**：
   - 确保你的应用的`AndroidManifest.xml`中声明了正确的intent filters，使其成为默认的Home应用。
3. **更新系统级配置文件**：
   - 修改像`handheld_system_ext.mk`或`handheld_product.mk`这样的文件，确保你的应用被包括在内，并且没有其他Launcher被包括。
4. **检查启动器覆盖**：
   - 确保在你的`Android.mk`文件中，`LOCAL_OVERRIDES_PACKAGES`正确地覆盖了所有默认的Launcher应用。



操作1：

​	将这些都修改回去了，然后只是没改回去默认添加的apk，但是仍旧是一样的效果，那这是为什么呢，是不是就代表我并没有完全屏蔽Launcher呢

操作2： 删掉3588-android12/packages/apps下的Launcher3，得到的现象是一样的，这证明跟Launcher3无关

操作3：在上面的基础上删掉了和默认自启动的app，卡在了正在启动的动画，目前认为是这里的问题：



~~~
frameworks/base/services/core/java/com/android/server/wm/ActivityRecord.java
~~~

在onWindowsDrawn方法的最后添加下面的内容

~~~java
//解锁后退出开机动画
// phoebe add for exit bootanim start
if (isHomeIntent(intent) && shortComponentName != null && !shortComponentName.contains("FallbackHome")) {
    SystemProperties.set("service.bootanim.exit", "1");
    android.util.Log.e("ActivityRecord", "real home....." + shortComponentName);

    try {
        IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
        if (surfaceFlinger != null) {
            Slog.i(TAG_WM, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
            Parcel data = Parcel.obtain();
            data.writeInterfaceToken("android.ui.ISurfaceComposer");
            surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                    data, null, 0);
            data.recycle();
        }
    } catch (RemoteException ex) {
        Slog.e(TAG, "Boot completed: SurfaceFlinger is dead!");
    }
}
// phoebe add for exit bootanim end
~~~

~~~
frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
~~~

注释以下内容：
![image-20231211144308708](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111443061.png)

~~~
packages/apps/Settings/src/com/android/settings/FallbackHome.java
~~~

注释掉下面的内容：	

![image-20231211144520230](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111445364.png)

测试发现确实是桌面动画引起来的，经过上面的操作，发现测试没有问题，就先这样了，下面继续去搞那个客户的。

## 2.nfc继续搞

客户发来了一个外设模块，这里总共是八根线，现在来确定一下对应关系



| 网络标号 | 引脚名称    |
| -------- | ----------- |
| SCK      | I2C3_SDA_M0 |
| SDA      | I2C3_SCL_M0 |
| IRQ      | GPIO1_PB0   |
| VEN      | GPIO1_PB1   |
| DWL      | GPIO1_PB2   |
| PVDD     | 3.3         |
| GND      | GND         |
| VBAT     | 3.3         |

连接好之后，用源码和他们的设备树进行测试，测试结果如下所示：

![image-20231211161423617](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111614666.png)

读卡结果如上图所示：

GPIO读卡前的状态如下

![image-20231211161402479](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111614612.png)

| IRQ  | GPIO1_PB0 | 低   |
| ---- | --------- | ---- |
| VEN  | GPIO1_PB1 | 高   |
| DWL  | GPIO1_PB2 | 低   |

在读取到之后

![image-20231211161655924](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111616995.png)

| IRQ  | GPIO1_PB0 | 高   |
| ---- | --------- | ---- |
| VEN  | GPIO1_PB1 | 高   |
| DWL  | GPIO1_PB2 | 低   |

状态确实发生了变化，现在来看客户底板的那三个引脚。

| IRQ  | DVP_PWREN0_H_GPIO0_B0              |
| ---- | ---------------------------------- |
| VEN  | VGA_HPDIN_GPIO0_C0                 |
| DWL  | PWM_FAN  ==LCD1_PWREN_H_GPIO0_C5== |



![image-20231211162845031](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111628051.png)

然后开始修改设备树。

**步骤1：GPIO0_B0复用取消**

~~~
rk3568.dtsi
~~~

![image-20231211165003826](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111650958.png)

**步骤2 取消GPIO0_C0复用**

只在使用VGA的情况下有用到，这里忽略即可

![image-20231211165155832](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111651872.png)

**步骤3 取消GPIO0_C5复用**

```
rk3568-evb.dtsi
```

![image-20231211165306410](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111653619.png)

![image-20231211165453957](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111654010.png)



启动之后，电平如下所示：
![image-20231211170442788](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111704962.png)

# 12.9日工作记录

## 1.继续ubuntu优化脚本

ubuntu的优化倒是搞完了，每个步骤我都写了详细的中问注释，如下所示：

![image-20231209092704590](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312090927358.png)

但在这个过程中依然是有了一些想法，让我感觉有些疑惑。现在的ubuntu20 的大体框架以及出来了。



## 2.3588 ubuntu20

这次直接以3568的uubntu20为蓝本进行修改。

1.修改开机启动的打印

2.摄像头的iqfile文件

3.GPU的驱动固件

4.RGA要改

5.RKAIQ要改

6.rkmpp-v4l2

ubuntu22 debian11 debian12

~~~
chmod 0666 /dev/mpp_service
{
    echo "type=dec"
    echo "codecs=VP8:VP9:H.264:H.265:AV1"
    echo "max-width=7680"
    echo "max-height=4320"
} > /dev/video-dec0
echo enc > /dev/video-enc0
chmod 0660 /dev/video-*
chown root:video /dev/video-*
~~~



~~~
chmod 0666 /dev/mpp_service
echo dec > /dev/video-dec0
echo enc > /dev/video-enc0
chmod 0660 /dev/video-*
chown root:video /dev/video-*
~~~

7.pulse 要改

## 3.3588 邮票孔安卓12替换launcher

### 1.取消原生桌面：

~~~
build/make/target/product/handheld_system_ext.mk
Launcher3QuickStep
~~~

![image-20231209155544647](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091555769.png)

```
3588-android12/device/rockchip/common/device.mk
PRODUCT_PACKAGES += Launcher3QuickStepGo
Launcher3QuickStep
```

![image-20231209154408563](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091544722.png)

~~~
device/generic/common/mgsi/mgsi_product.mk
~~~

![image-20231209154601429](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091546515.png)

### 2.内置app并设置成launcher

在安卓源码下的packages\apps下创建文件夹（名称必须和APK同名），并把apk放进创建的文件夹里面去。

![img](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091556137.jpg) 

在创建的文件夹下创建一个Android.mk文件，内容:

~~~mk
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := hmkq3568s_code_37_1.0.17_11_28_20_38_47
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_PRIVILEGED_MODULE :=true
LOCAL_OVERRIDES_PACKAGES := Home Launcher2 Launcher3 Launcher3QuickStep   
LOCAL_CERTIFICATE := platform
include $(BUILD_PREBUILT)
~~~

![image-20231209155950136](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091559307.png)



### 3.将内置的app设置成launcher

打开安卓源码下的这个文件

```
3588-android12/build/make/target/product/handheld_product.mk
```

将自己的app加到PRODUCT_PACKAGES列表

![image-20231209160141718](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091601937.png)

### 4.删掉开机动画

测试发现，经过上面修改之后会在开机之后仍旧先加载到桌面，随后才进入相应的app，又经过测试发现这是开机动画的影响，所以仍旧需要下面的操作关掉启动中的动画。

**步骤一：**

~~~
vim frameworks/base/services/core/java/com/android/server/wm/ActivityRecord.java
~~~

在onWindowsDrawn方法的最后添加下面的内容

~~~java
//解锁后退出开机动画
// phoebe add for exit bootanim start
if (isHomeIntent(intent) && shortComponentName != null && !shortComponentName.contains("FallbackHome")) {
    SystemProperties.set("service.bootanim.exit", "1");
    android.util.Log.e("ActivityRecord", "real home....." + shortComponentName);

    try {
        IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
        if (surfaceFlinger != null) {
            Slog.i(TAG_WM, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
            Parcel data = Parcel.obtain();
            data.writeInterfaceToken("android.ui.ISurfaceComposer");
            surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
                    data, null, 0);
            data.recycle();
        }
    } catch (RemoteException ex) {
        Slog.e(TAG, "Boot completed: SurfaceFlinger is dead!");
    }
}
// phoebe add for exit bootanim end
~~~

**步骤2**

~~~
vim frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
~~~

注释以下内容：
![image-20231211144308708](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111443061.png)

**步骤3：**

~~~
vim packages/apps/Settings/src/com/android/settings/FallbackHome.java
~~~

注释掉下面的内容：	

![image-20231211144520230](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312111445364.png)

随后编译重新烧写即可：
~~~shell
source javaenv.sh 
java -version 
lunch rk3588_s-userdebug
./build.sh -AUCKu
~~~



学到了一个scp命令，我发现这样还挺快：

~~~shell
 scp chai@192.168.1.123:/home/chai/Android/3588-android12/rockdev/Image-rk3588_s/update.img /e/01_烧写工具/RKDevTool_Release_v2.84/RKDevTool_Release_v2.84
~~~

![image-20231209173511174](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312091735220.png)

## 4.ubuntu22 

~~~
                ## for panfork
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/mali-g610-firmware_1.0.0-1_all.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgbm1_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgbm-dev_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libglapi-mesa_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libgl1-mesa-dri_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libegl-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                dpkg_install_deb_chroot "$EXTER/cache/sources/rk3588_packages_jammy/mesa/libglx-mesa0_23.0~panfork~csf~git221210.120202c6757~j+3_arm64.deb"
                # Improve mesa performance
                echo "PAN_MESA_DEBUG=gofaster" >> $SDCARD/etc/environment
~~~

### 



# 12.8日工作记录

## 1.nfc适配

今天先将这个客户的nfc内容进行一下整理：

==已知条件==：

1. 客户在我们的底板上移植测试成功了NFC，并且提供了在七寸LVDS上测试成功的源码，客户的测试结果如下所示：
   ![image-20231208100057538](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312081000024.png)

2. 4.3寸屏幕的源码，触摸和镜像进行翻转，适配了5寸屏

总结：我适配的4.3寸屏幕只对设备树进行了修改，按道理来说是不可能存在问题的，没办法了，目前我认为问题出在irq上，其他的问题还好。先去做我的deb包吧。

## 2.ubuntu22 deb包的制作

其实ubuntu20也需要重新做，但是也还好吧，就这样吧，目前的想法是能用就行，而且要能复现出来。

步骤一：先整理ubuntu20 的构建文件，后面的一切都要以ubuntu20 为蓝本





# 12.6日工作记录

## 1.docker镜像的构建

先将所有的docker镜像制作完成。

rk3568

```shell
docker build -f Dockerfile -t ubuntu20_rk3568 .
docker build -f Dockerfile -t ubuntu22_rk3568 .
docker build -f Dockerfile -t debian10_rk3568 .
docker build -f Dockerfile -t debian11_rk3568 .
docker build -f Dockerfile -t debian12_rk3568 .
```

rk3588

~~~shell
docker build -f Dockerfile -t ubuntu20_rk3588 .
docker build -f Dockerfile -t ubuntu22_rk3588 .
docker build -f Dockerfile -t debian11_rk3588 .
docker build -f Dockerfile -t debian12_rk3588 .
~~~



打包docker

rk3568

```shell
docker save -o ubuntu20_rk3568.tar.gz ubuntu20_rk3568
docker save -o ubuntu22_rk3568.tar.gz ubuntu22_rk3568
docker save -o debian10_rk3568.tar.gz debian10_rk3568
docker save -o debian11_rk3568.tar.gz debian11_rk3568
docker save -o debian12_rk3568.tar.gz debian12_rk3568
```

rk3588

~~~shell
docker save -o ubuntu20_rk3588.tar.gz ubuntu20_rk3588
docker save -o ubuntu22_rk3588.tar.gz ubuntu22_rk3588
docker save -o debian11_rk3588.tar.gz debian11_rk3588
docker save -o debian12_rk3588.tar.gz debian12_rk3588
~~~



搞成zip的压缩

~~~shell
zip ubuntu20.zip ubuntu20_rk3568.tar.gz
zip ubuntu22.zip ubuntu22_rk3568.tar.gz
zip debian10.zip debian10_rk3568.tar.gz
zip debian11.zip debian11_rk3568.tar.gz
zip debian12.zip debian12_rk3568.tar.gz

zip ubuntu20.zip ubuntu20_rk3588.tar.gz
zip ubuntu22.zip ubuntu22_rk3588.tar.gz
zip debian11.zip debian11_rk3588.tar.gz
zip debian12.zip debian12_rk3588.tar.gz
~~~

~~~shell
#!/bin/bash

# 目录列表
directories=("01_debian10" "02_debian11" "03_debian12" "04_ubuntu20" "05_ubuntu22")

# 循环处理每个目录
for dir in "${directories[@]}"
do
    zip -r "${dir}.zip" "$dir"
done
~~~

~~~shell
#!/bin/bash

# 目录列表
directories=("01_debian11" "02_debian12" "03_ubuntu20" "04_ubuntu22")

# 循环处理每个目录
for dir in "${directories[@]}"
do
    zip -r "${dir}.zip" "$dir"
done
~~~

行了，现在的docker镜像算是搞完了，然后就开始搞ubuntu22了。

## 2.ubuntu22 deb包的构建

# 12.5日工作记录

## 1 内核驱动程序

NFC Android堆栈使用nxpnfc内核驱动程序与NXP NCI NFC控制器进行通信。该驱动程序可以从以下存储库获取：https://github.com/NXPNFCLinux/nxpnfc。

### 1.1 驱动程序详细信息

nxpnfc内核驱动程序通过I2C或SPI物理接口提供与NFC控制器的通信。当加载到内核时，该驱动程序通过名为/dev/nxpnfc的设备节点公开与NFC控制器的接口。该内核驱动程序与广泛范围的NXP NFC控制器兼容，源代码中解释了特定的NXP引用。提供的源代码允许根据内核配置构建I2C和SPI版本的内核驱动程序。

### 1.2 获取源代码

将nxpnfc存储库克隆到内核目录中，替换现有的实现：

~~~shell
rm -rf drivers/nfc
git clone https://github.com/NXPNFCLinux/nxpnfc.git drivers/nfc
~~~

这将在drivers/nfc文件夹中包含以下文件：
• README.md：存储库信息
• Makefile：驱动程序主要的Makefile文件
• Kconfig：驱动程序的配置文件
• LICENSE：驱动程序的许可条款
• i2c_devicetree.txt：I2C设备树定义示例
• spi_devicetree.txt：SPI设备树定义示例
• nfc子文件夹包含：

Makefile：

common.c：通用驱动程序实现

common.h：通用驱动程序接口定义

i2c.c：特定于I2C的驱动程序实现

i2c.h：特定于I2C的驱动程序接口定义

spi.c：特定于SPI的驱动程序实现

spi.h：特定于SPI的驱动程序接口定义

为了方便这里已经将拉取好的下载了下来，如下图所示：

![image-20231204153016150](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041530293.png)

![image-20231204170159295](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041701347.png)

### 1.3 将驱动程序包含到内核中

将驱动程序包含到内核中，并在设备启动时加载，需要使用设备树。在根据下面的示例更新设备树定义后，必须重新构建与平台相关的设备树。

#### 1.3.1 I2C版本

根据平台上硬件集成情况，必须根据I2C地址（以下示例中为0x28）和GPIO分配进行适配。
以下是要添加到平台设备树文件（.dts文件，例如位于kernel/arch/arm64/boot/dts/rockchip内核子文件夹下的arm平台）的定义示例。

```
rk3568-evb1-ddr4-v10.dts
```

~~~
&i2c1 {
    status = "okay";
        nxpnfc: nxpnfc@28 {
        compatible = "nxp,nxpnfc";
        status = "ok";
        reg = <0x28>;
        clock-frequency = <100000>;
        nxp,nxpnfc-irq = <&gpio0 RK_PB0 0>;  8
        nxp,nxpnfc-ven = <&gpio0 RK_PC0 0>; 16
        nxp,nxpnfc-fw-dwnld = <&gpio0 RK_PC5 0>;  21
    };
};
~~~

![image-20231204160009875](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041600994.png)

![image-20231204170250260](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041702556.png)

修改1：
![image-20231204173221891](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041732985.png)

这个时钟和0_B0复用，所以这里注释掉。



![image-20231204173858951](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041738199.png)

0C5这里也注释掉

#### 1.3.2 SPI版本(忽略)

根据平台上硬件集成情况，必须根据SPI句柄（以下示例中为0）和GPIO分配进行适配。
以下是要添加到平台设备树文件（.dts文件，例如位于arch/arm/boot/dts内核子文件夹下的arm平台）的定义示例。

~~~
spi2: spi@ffd68000 {
...
    status = "ok";
    nxpnfc@0 {
    compatible = "nxp,nxpnfc";
    reg = <0>;
    nxp,nxpnfc-irq = <&gpio26 0 0>;
    nxp,nxpnfc-ven = <&gpio26 2 0>;
    nxp,nxpnfc-fw-dwnld = <&gpio26 4 0>;
    spi-max-frequency = <7000000>;
    };
};
~~~

### 1.4 构建驱动程序

通过menuconfig过程将目标驱动程序（I2C或SPI版本）包含到构建中，作为内置（<*>）：
设备驱动程序 --->
< > NXP-NFCC的NFC I2C从设备驱动程序
< > NXP-NFCC的NFC SPI从设备驱动程序
重新构建完整的内核，驱动程序将包含在内核映像中。

![image-20231204170504309](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041705357.png)

![image-20231204170547198](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041705468.png)

## 2 Android 11

以下步骤是基于NXP在https://github.com/NXPNFCLinux/ nxpnfc_android11存储库中提供的Android NFC交付内容。当前发布版本基于Android AOSP版本11.0.0_r3，移植到其他Android 11子版本可能需要对API进行轻微调整（在编译时检测到）。

### 2.1 第一步：获取NXP的Android NFC交付内容

将存储库克隆到AOSP源代码目录中：\

~~~shell
git clone https://github.com/NXPNFCLinux/nxpnfc_android11.git {ANDROID_BUILD_TOP}/vendor/nxp/nfc
~~~

![image-20231204160454621](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041604754.png)

### 2.2 第二步：安装NXP-NCI交付内容

运行安装脚本：

~~~
vendor/nxp/nfc/install_NFC.sh
~~~

这将执行以下操作：
• 对AOSP system/nfc实现进行修补，以添加PN7160的特定支持
• 对AOSP hardware/nxp/nfc实现进行修补，以添加PN7160的特定支持
• 对AOSP packages/apps/Nfc文件夹进行修补，以添加对PN7160扩展的支持
• 对AOSP frameworks/base定义进行修补，以添加特定API
• 对AOSP frameworks/native定义进行修补，以添加特定权限
• 对vendor/nxp文件夹进行修补，以添加T4T NDEF模拟的特定API

### 2.3 第3步：将NFC添加到构建中

在device.mk makefile（例如device/brand/platform/device.mk）中，包含特定的makefile：
$(call inherit-product, vendor/nxp/nfc/device-nfc.mk)

```
rk_android11.0_sdk/device/rockchip/rk356x/device.mk
$(call inherit-product, vendor/nxp/nfc/device-nfc.mk)
```

在BoardConfig.mk文件中（例如device/brand/platform/BoardConfig.mk），包含特定的makefile
-include vendor/nxp/nfc/BoardConfigNfc.mk

~~~
rk_android11.0_sdk/device/rockchip/rk356x/BoardConfig.mk
-include vendor/nxp/nfc/BoardConfigNfc.mk
~~~

### 2.4 第4步：添加固件库

Android NFC堆栈集成了对NFC控制器固件的支持。为了允许更新机制，更新的固件版本必须以库（或二进制）的形式包含在目标设备上。NXP的NFC控制器固件的Arm架构库通过专用存储库https://github.com/NXP/nfc-NXPNFCC_FW 提供。
使用以下命令从存储库中检索PN7160固件库文件，并放置在专用子文件夹中：

~~~
$ wget -r -np -nd -P ${ANDROID_BUILD_TOP}/vendor/nxp/pn7160/firmware/64-bit/ https://github.com/NXP/nfc-NXPNFCC_FW/tree/master/InfraFW/pn7160/64-bit/libpn7160_fw.so
$ wget -r -np -nd -P ${ANDROID_BUILD_TOP}/vendor/nxp/pn7160/firmware/32-bit/ https://github.com/NXP/nfc-NXPNFCC_FW/tree/master/InfraFW/pn7160/32-bit/libpn7160_fw.so
~~~

nxp目录解压即可：

![image-20231204161416163](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312041614227.png)这将创建包含32位和64位Arm架构库的vendor/nxp/pn7160/firmware子文件夹。这些库将在构建Android映像时包含在映像中（在vendor/nxp/nfc/device-nfc.mk中定义)。

### 2.5 第5步：构建和安装NFC

将Android映像构建并刷入目标设备（引导映像必须包含内核驱动程序，如第4节所述）。

### 2.6 第6步：验证NFC功能

在Android的“设置”菜单中，检查NFC是否打开。NFC功能应该已经启动，可以用于发现NFC标签或与远程NFC设备交换数据。
要进一步测试NFC读取器功能，可以从Google Play商店免费下载NXP的NFC TagInfo和NFC TagWriter这两个应用程序。
