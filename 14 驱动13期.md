目前定的是我来写到14，前面的一些内容倒也还可以还能接受，第一遍也已经看完了，然后开始看第二遍，昨天在心流中找到的愿意是技巧和难度的原因，做一件事情既不能过于简单，当然也不能过于难，当做这件事的技巧和难度达到平衡的时候，也正是你进入心流的最好机会，看的第一遍只是看，难度已经限制了，而第二遍就不仅仅是看了，而应该将那些简单的章节进行写文档，而对于那些难的章节，可以再看第二遍。

| 总领：本期视频介绍                         | 视频的总览，很重要，正好可以趁这个机会学习借鉴一下法师的风格 |
| ------------------------------------------ | ------------------------------------------------------------ |
| 1 什么是输入子系统？                       |                                                              |
| 2 如何确定输入设备与节点的对应关系？       |                                                              |
| 3 实践：确定输入设备对应的设备节点         |                                                              |
| 4 输入子系统框架讲解                       |                                                              |
| 5 输入子系统框架分析                       |                                                              |
| 6 输入子系统关键数据结构之间关系           |                                                              |
| 7 认识输入子系统源码以及裁剪               |                                                              |
| 8 编写一个最简单的设备驱动层代码           |                                                              |
| 9 通过最简单设备驱动代码分析匹配规则和流程 |                                                              |
| 10 引入多对多的匹配关系                    |                                                              |
| 11 继续编写设备驱动层代码（理论指导）      |                                                              |
| 12 继续编写设备驱动层代码（实现循环上报）  |                                                              |
|                                            |                                                              |

需要注意的是，对于一些C语言代码，这次不应该直接似懂非懂了，而是应该知其然，然后知其所以然，不然问题一直在这里，并不是你假装看不见他，他就会消失，所以这一次要尽可能的解答自己的疑问，你懂了吗。

## 0.本期视频介绍

我负责的是4个部分，分别是基础知识、整体认识输入子系统、通过编写设备驱动层代码边学边练、上报数据处理。

**基础知识** 

​	什么是输入子系统

​	如何确定输入设备和节点的关系

**整体认识输入子系统**

​	输入子系统框架讲解

​	输入子系统框架分析

​	输入子系统关键数据结构之间的关系

**通过编写设备驱动层代码边学边练**

​	编写一个最简单的设备驱动层代码

​	通过最简单的设备驱动层代码分析匹配流程和匹配规则

​	进一步探究匹配规则：多对多的匹配关系

​	继续编写最简单的设备驱动层代码

**上报数据处理**

​	编写应用程序获取上报数据

​	输入子系统上报数据格式分析



 

# 1 初识input子系统

## 1.1什么是输入子系统？

在Linux中，input子系统是专门为处理输入类设备而设计的一个子系统或框架。它提供了一套通用的接口和机制，用于驱动开发人员编写和管理输入设备的驱动程序。输入设备包括键盘、鼠标、触摸屏、游戏手柄等，具体示意图如下所示：

![image-20240124104005062](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241040091.png)

使用input子系统的主要目的是规范和简化输入设备驱动的开发过程，以提高驱动的通用性和兼容性。它通过将输入设备的共同功能和处理逻辑提取出来，编写成通用的代码，将差异化的代码留给具体的设备驱动开发人员，这种分工合作的方式使得驱动开发人员可以更专注地处理设备特定的细节，从而大大降低工程师的开发难度。

在不使用输入子系统的情况下，可能会使用不同的代码来表示相同的动作。例如，一个同学可能使用数字1来表示按键按下，数字0来表示按键松开；而另一个同学可能使用数字2来表示按键按下，数字3来表示按键松开。这样的情况下，应用程序很难适配所有不同的驱动程序，从而导致程序的兼容性和移植性较差。

而在使用输入子系统后就可以解决这个问题。例如，当不同厂家的键盘连接到计算机上时，它们的驱动程序都是按照输入子系统框架来编写的。这意味着所有厂家的驱动程序都使用相同的代码规范来表示按键动作，例如使用1表示按下，使用0表示松开。这样一来，无论是哪个厂家的键盘，都可以在任意计算机上正常使用。

使用输入子系统的另一个好处是驱动开发人员不需要自己实现文件操作集函数。输入子系统已经提供了一套标准的接口和函数，开发人员只需要按照这些接口进行开发，而无需关心底层的文件操作细节。这样可以大大降低开发的难度和复杂度。

综上使用input子系统的作用如下所示：

1. **兼容性：** 输入子系统提供了一个统一的框架和接口，使得不同厂家的输入设备都可以按照相同的规范进行驱动开发。无论是键盘、鼠标还是其他输入设备，只要符合输入子系统定义的接口和事件格式，都可以在Linux系统中正常工作。这样一来，工程师不需要针对每个厂家的设备编写和维护不同的驱动代码，大大提高了设备的兼容性。
2. **统一的驱动编程方式：** 输入子系统定义了一套通用的驱动编程方式，工程师只需要按照输入子系统的规范进行开发即可。输入设备的驱动模块需要实现相应的接口函数，如初始化函数、事件处理函数等。这些接口函数的实现方式是相同的，不论是键盘驱动还是鼠标驱动，都可以按照统一的方式进行开发。这样一来，工程师可以更加专注于设备特定的细节，而无需关心通用的驱动框架，简化了开发过程。
3. **统一的应用操作接口：** 输入子系统通过提供一组统一的应用操作接口，如/dev/input/eventX，使得应用程序可以方便地与输入设备进行交互。应用程序可以通过读取这些设备节点，获取输入事件的信息，并进行相应的处理。无论是哪种类型的输入设备，应用程序都可以使用相同的方式进行访问和操作。这样一来，应用程序的开发人员不需要关心底层输入设备的细节，可以更加专注于应用程序的逻辑开发。

## 1.2 如何确定输入设备和节点的关系



在输入子系统中，输入设备与设备节点之间有一定的对应关系。以下是判断设备节点与输入设备的方法：

1.**设备名：** 输入子系统的设备节点可以分为通用设备名和专用设备名。专用设备名通常可以从设备名中直接识别出设备类型，例如"keyboard"（键盘）或"mouse"（鼠标）。而通用设备名则不能直接确定设备类型。如下图所示，event0-event4属于通用设备名，而mouse0和mouse2属于专用设备名。

![image-20240124105150921](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241051947.png)

2.**试探性方法：** 可以使用"cat"命令打开设备节点文件，然后对物理设备进行操作，观察终端是否有输出。例如，对于键盘设备，你可以运行"cat /dev/input/eventX"，其中"/dev/input/eventX"是设备节点的路径，然后按下键盘按键，观察终端是否输出相应的字符。通过这种试探性的方法，你可以判断设备节点与具体设备之间的对应关系。例如使用以下命令来测试鼠标，如下所示：

~~~bash
sudo cat /dev/input/mouse0
~~~

![image-20240124111027829](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241110859.png)

注：鼠标节点也可能是mouse1或者mouse2。

**3.查看输入设备信息：** 可以使用以下命令查看"/proc/bus/input/devices"文件：

~~~bash
cat /proc/bus/input/devices
~~~

部分打印截图如下所示：
![image-20240124111506720](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241115891.png)	该文件记录了当前系统的所有输入设备的信息在该文件中，你可以找到与设备节点相关的信息，例如设备名称、供应商ID、产品ID等。通过对比设备节点的路径和设备信息中的对应字段，你可以确定设备节点与特定输入设备之间的关系，例如可以通过上述打印信息查看到，键盘对应的设备节点为/dev/input/event1，如下图所示:

![image-20240124112341353](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241123439.png)

其他相关内容的解释如下所示：

- **I: Bus=0011 Vendor=0001 Product=0001 Version=ab41:** 这一行显示了设备的总线类型、供应商ID、产品ID和固件版本。在这个例子中，该设备的总线类型为0011，供应商ID为0001，产品ID为0001，固件版本为ab41。
- **N: Name="AT Translated Set 2 keyboard":** 这一行显示了设备的名称。在这个例子中，该设备的名称为"AT Translated Set 2 keyboard"。
- **P: Phys=isa0060/serio0/input0:** 这一行显示了设备的物理位置。在这个例子中，该设备的物理位置是isa0060/serio0/input0。
- **S: Sysfs=/devices/platform/i8042/serio0/input/input1:** 这一行显示了设备在sysfs文件系统中的路径。在这个例子中，该设备的路径是/devices/platform/i8042/serio0/input/input1。
- **U: Uniq=:** 这一行显示了设备的唯一标识符。在这个例子中，唯一标识符为空。
- **H: Handlers=sysrq kbd event1 leds:** 这一行显示了设备的处理程序。它指示了处理设备输入事件的程序或模块。在这个例子中，设备有sysrq、kbd、event1和leds这些处理程序，其中event1就表示设备节点为/dev/input/event1。
- **B: PROP=0:** 这一行显示了设备的属性。在这个例子中，设备的属性值为0。
- **B: EV=120013:** 这一行显示了设备支持的事件类型。在这个例子中，设备支持EV_SYN、EV_KEY、EV_MSC和EV_LED这些事件类型。
- **B: KEY=402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe:** 这一行显示了设备支持的按键。每个按键对应一个位，1表示按键被按下，0表示按键未被按下。该行显示了按键的状态，以16进制表示。
- **B: MSC=10:** 这一行显示了设备支持的杂项事件。在这个例子中，设备支持MSC_SCAN事件。
- **B: LED=7:** 这一行显示了设备支持的LED灯。在这个例子中，设备支持3个LED灯，使用一个7位的二进制数表示灯的状态。

上面讲解的cat命令是一种试探性的方法，除此之外还可以使用hexdump命令对输出信息进行二进制内容查看，它可以将二进制文件以十六进制和ASCII码的形式进行显示。它的基本语法为：

```
hexdump [选项] [文件]...
```

下面是一些常用的选项：

- **-C：** 以规范的格式输出十六进制和ASCII码。它会按照十六进制的形式显示文件的内容，并在每行的右侧显示相应的ASCII码。这种格式可以很方便地查看二进制文件的内容。
- **-b：** 以单字节八进制的形式显示文件内容。每个字节的值将以八进制数字的形式显示。
- **-c：** 以单字节字符的形式显示文件内容。每个字节将以字符的形式显示，非可打印字符将显示为"."。
- **-d：** 以双字节十进制的形式显示文件内容。每个字节对应的十进制值将以十进制数字的形式显示。
- **-o：** 以双字节八进制的形式显示文件内容。每个字节的值将以八进制数字的形式显示。
- **-x：** 以双字节十六进制的形式显示文件内容。每个字节的值将以十六进制数字的形式显示。
- **-s offset：** 从指定的偏移量开始输出文件内容。可以使用十进制或十六进制表示偏移量。

然后使用以下命令对键盘的输出信息进行二进制内容查看，如下图所示：

~~~bash
sudo hexdump /dev/input/event1
~~~

![image-20240124130036626](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241300676.png)

## 1.3.确定开发板输出设备节点

在上个小节基于虚拟机ubuntu来学习了如何确定输入设备和节点的关系，本小节将使用RK3568开发板进行实践，开发板上的的输入设备如下所示：

![image-20240124133730567](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241337416.png)

总共有4个输入设备，分别是触摸屏、红外接收器、adc按键以及耳机接口，然后启动开发板，进入系统之后如下图所示：

![image-20240124134206711](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241342761.png)

​	首先通过以下命令查看总共有多少个输入设备，如下图所示：
~~~shell
ls /dev/input/
~~~

![image-20240124150559533](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241505598.png)

可以看到总共有event0-event4 五个通用设备名，上面我们总共找出来了4个输入设备，那这里为什么会有五个节点呢，所以我们就需要使用下面的命令查看详细的输入设备信息了，如下图所示：
~~~shell
 cat /proc/bus/input/devices
~~~

![image-20240124153148261](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241531436.png)

​		从上到下依次是红外接收器、电源power按键、触摸屏、adc按键和耳机，为了更简单的进行演示，这里选取触摸屏和adc按键来进行测试，从上面的信息可以得到触摸屏和adc按键分别对应event2和event3，所以可以使用以下命令对两个输入设备的输出信息进行二进制内容查看，如下图所示：

~~~bash
hexdump /dev/input/event2
hexdump /dev/input/event3
~~~

![image-20240124154035899](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241540022.png)

至此，开发板输出设备节点的测试就完成了。

# 2.输入子系统框架

![image-20240124160339888](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401241603932.png)

Input子系统可以分为事件处理层、设备驱动层、核心层三层，这三层在输入子系统中有着不同的作用和分工。

分层的好处在于提高代码的可重用性和可维护性，以及降低开发的难度。通过将输入子系统划分为不同的层次，每个层次可以专注于特定的功能和责任，减少了代码的冗余和重复编写。例如，在设备驱动层编写的通用代码可以被多个不同的驱动程序共享和复用，提高了开发效率。同时，分层的结构也使得不同层次之间的接口清晰明确，降低了开发过程中的耦合度，使得代码的维护和调试更加容易。

下面是对每个层次的详细解释：

1. 事件处理层（Event Handling Layer）：
   事件处理层是输入子系统的最上层，可以处理输入设备产生的事件并将其传递给上层应用程序，并在操作系统中创建设备节点，以便应用程序可以通过设备节点与输入设备进行通信。它接收来自核心层的输入事件，并根据事件的类型和属性进行相应的处理。

2. 核心层（Core Layer）：

   ​	核心层的主要功能是作为匹配器位于事件处理层和设备驱动层之间。它起到协调和连接这两个层级的作用，以确保输入设备的事件能够正确地传递给相应的事件处理程序。

   以下是核心层在输入子系统中的主要功能：

   1. 事件匹配： 核心层负责将输入设备产生的原始输入数据与相应的事件处理程序进行匹配。它会解析原始输入数据，并根据预定义的规则和配置信息，确定应该将输入数据传递给哪个事件处理程序进行处理。
   2. 设备管理和控制：
      核心层负责维护输入设备的状态、属性和配置信息，并提供设备的注册、注销和管理功能。它与设备驱动层进行交互，接收来自设备驱动层的输入事件，并将其转化为抽象化的事件表示形式。核心层提供一致的接口，使得上层应用程序可以独立于具体的硬件设备进行操作。
   3. 事件处理和分发：
      核心层负责事件的处理和分发，将输入事件传递给对应的事件处理层。它通过事件队列的机制，接收和缓存来自设备驱动层的输入事件，并按照特定的规则将事件分发给对应的事件处理层或应用程序。这样，事件处理层可以通过核心层提供的接口，获取输入事件并进行相应的处理。
   4. 抽象化接口和事件处理机制：
      核心层为上层应用程序和事件处理层提供了一组抽象化的接口和事件处理机制。它提供了统一的事件表示形式，使得不同类型的输入设备（如键盘、鼠标、触摸屏等）的事件可以被表示和处理。通过核心层的接口，事件处理层可以注册事件监听器、订阅特定类型的事件，并获取输入设备的状态信息。

3. 设备驱动层（Device Driver Layer）：
   设备驱动层是输入子系统的最底层，负责与硬件设备进行通信和交互。它的主要职责是将硬件设备的操作和功能抽象为统一的接口，以便核心层和事件处理层可以与之交互。设备驱动层的代码通常包括硬件的初始化、中断处理、数据传输等操作，以确保输入设备的正常工作。开发者在这一层编写驱动程序，以适配特定的硬件设备。

​	Linux源码中已经写好了核心层相关的代码，所以在后续编写输入子系统驱动的时候，核心层的代码是不需要编写的，而事件处理层在Linux中也为我们提供了一个模板，除了一些例如固定设备节点的需求外，一般不需要编写事件处理层的代码，而设备驱动层由于要面对不同的硬件，每个硬件的初始化方式又都都不同，所以设备驱动层的代码在编写输入子系统驱动的时候是需要填充的。

至此，关于输入子系统的框架就讲解完成了，会在下个小节对输入子系统要用到的数据结构进行介绍。

# 3 输入子系统数据结构介绍

事件处理层的代码位于drivers/input/evdev.c文件中,为上层的应用程序提供了统一的事件处理机制。它定义了处理输入设备事件的函数，并提供了读取事件、控制设备等功能的接口。

当evdev设备注册时，首先会调用input_register_handler函数来注册input handler结构体，具体内容如下所示：

```c
static int __init evdev_init(void)
{
    return input_register_handler(&evdev_handler);
}
```

这里的input_register_handler函数会将evdev handler添加到输入子系统的handler列表中，并分配一个唯一的handler编号，evdev handler结构体内容如下所示：

```c
static struct input_handler evdev_handler = {
    .event = evdev_event,// 事件处理函数指针，指向名为 evdev_event 的函数，用于处理输入事件   
    .events = evdev_events,// 批量事件处理函数指针，指向名为 evdev_events 的函数，用于处理输入设备的多个事件   
    .filter = evdev_filter,// 事件过滤函数指针，指向名为 evdev_filter 的函数，用于确定是否接收和处理特定类型和代码的事件   
    .match = evdev_match,// 匹配函数指针，指向名为 evdev_match 的函数，用于确定处理程序是否适用于给定的输入设备   
    .name = "evdev",// 设备名称，设置为字符串 "evdev"
    .id_table = evdev_ids,// 输入设备ID表，指向名为 evdev_ids 的表，用于匹配输入设备的ID   
};
```

evdev_handler是一个struct input_handler 类型的结构体变量，它的目的是定义和管理输入处理程序的行为，处理程序可以注册到输入子系统中，以接收和处理特定输入设备产生的事件。通过使用不同的处理程序，输入子系统可以支持各种类型的输入设备，并提供定制的事件处理逻辑。input_handler结构体内容如下所示：

~~~c
struct input_handler {
    void *private;  // 私有数据指针，用于存储特定处理程序的私有数据
    
	// 事件处理函数指针，当输入事件发生时调用，参数包括输入句柄、事件类型、事件代码和事件值
    void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
    
	// 批量事件处理函数指针，当输入设备有多个事件同时发生时调用，参数包括输入句柄、事件值数组和事件数量
    void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count);
    
 	// 事件过滤函数指针，用于确定是否接收和处理特定类型和代码的事件，返回值为布尔类型，表示是否接受该事件
    bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);

    // 匹配函数指针，用于确定处理程序是否适用于给定的输入设备，返回值为布尔类型，表示是否适用
    bool (*match)(struct input_handler *handler, struct input_dev *dev);
    
	// 连接函数指针，用于建立输入设备和处理程序之间的连接，返回值为整数类型，表示连接的结果
    int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
    
	// 断开连接函数指针，用于断开输入设备和处理程序之间的连接
    void (*disconnect)(struct input_handle *handle);
    
	// 启动函数指针，用于启动输入设备的数据传输或处理过程
    void (*start)(struct input_handle *handle);
    
    bool legacy_minors;  // 是否使用旧版次设备号
    int minor;  // 设备次设备号
    const char *name;  // 设备名称

    const struct input_device_id *id_table;  // 输入设备ID表

    struct list_head h_list;  // 处理程序链表头
    struct list_head node;  // 处理程序链表节点
};
~~~

然后继续回到drivers/input/evdev.c文件中，驱动入口函数中的input_register_handler函数定义在kernel/drivers/input/input.c文件中，该函数的具体内容如下所示：

~~~c
int input_register_handler(struct input_handler *handler)
{
    struct input_dev *dev;
    int error;

    // 尝试获取输入互斥锁，以确保在注册处理程序时不会被中断
    error = mutex_lock_interruptible(&input_mutex);
    if (error)
        return error;

    // 初始化处理程序链表头
    INIT_LIST_HEAD(&handler->h_list);

    // 将处理程序添加到全局处理程序链表的末尾
    list_add_tail(&handler->node, &input_handler_list);

    // 遍历输入设备链表，为每个设备附加处理程序
    list_for_each_entry(dev, &input_dev_list, node)
        input_attach_handler(dev, handler);

    // 唤醒procfs读取器，通知其有新的处理程序注册
    input_wakeup_procfs_readers();

    // 释放输入互斥锁
    mutex_unlock(&input_mutex);

    return 0;
}
~~~

函数的详细解释如下：

第7行：函数尝试获取输入互斥锁，通过调用 mutex_lock_interruptible(&input_mutex)函数，确保在注册处理程序时不会被中断，以保护关键操作的完整性。

第12行：函数初始化处理程序链表头，通过调用 INIT_LIST_HEAD(&handler->h_list)函数创建一个空的链表头，用于存储与此处理程序相关的其他结构体。

第15行：函数将处理程序添加到全局处理程序链表的末尾，通过调用 list_add_tail(&handler->node, &input_handler_list)函数将处理程序加入到全局链表中，使其能够与输入子系统的其他组件进行交互。

第18-19行：函数使用 list_for_each_entry 循环遍历输入设备链表（input_dev_list），为每个输入设备建立与处理程序的连接。在每次迭代中，它调用 input_attach_handler(dev, handler)，将当前设备和处理程序作为参数传递给 input_attach_handler 函数。这样可以为每个输入设备建立与处理程序的连接，以便处理设备发送的输入事件。

第22行：在为所有输入设备附加处理程序后，函数调用 input_wakeup_procfs_readers()，唤醒正在阻塞的 procfs 读取器。这是为了通知 procfs 读取器有新的处理程序已经注册，以便读取器可以及时获取新的输入事件信息。

第25行，函数释放输入互斥锁，通过调用 mutex_unlock(&input_mutex)，以允许其他线程继续访问输入子系统。

在上述程序中最重要的就是18-19行的input_attach_handler 函数，该函数可以为每个输入设备建立与处理程序的连接，该函数同样定义在input.c中，具体内容如下所示：

~~~c
static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)
{
    const struct input_device_id *id;
    int error;

    // 通过输入设备和处理程序的匹配函数来确定是否适用于该设备
    id = input_match_device(handler, dev);
    if (!id)
        return -ENODEV;

    // 调用处理程序的连接函数来建立设备和处理程序之间的连接
    error = handler->connect(handler, dev, id);
    if (error && error != -ENODEV)
        pr_err("failed to attach handler %s to device %s, error: %d\n",
               handler->name, kobject_name(&dev->dev.kobj), error);
    // 如果连接失败且错误码不是-ENODEV，则打印错误消息

    return error;
}
~~~

第7行：调用 input_match_device(handler, dev)函数来确定输入设备和处理程序是否匹配。这个函数将在处理程序的输入设备ID表中查找与给定的输入设备匹配的ID，并返回匹配的ID。如果没有找到匹配的ID，则返回 NULL。

第12行：如果找到匹配的ID会调用 handler->connect(handler, dev, id)函数，这是处理程序的连接函数。该函数用于建立输入设备和处理程序之间的连接，并执行必要的初始化和配置。它将处理程序、输入设备和匹配的ID作为参数传递。

无论是第7行的input_match_device函数还是第12行的handler->connect函数都是很重要的，首先来看第7行调用的input_match_device函数，函数具体内容如下所示：

~~~c
static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)
{
    const struct input_device_id *id;

    // 遍历处理程序的输入设备ID表，直到找到匹配的ID或遍历完所有ID为止
    for (id = handler->id_table; id->flags || id->driver_info; id++) {
        // 使用输入设备ID匹配函数判断给定的输入设备是否与当前ID匹配
        if (input_match_device_id(dev, id) &&
            (!handler->match || handler->match(handler, dev))) {
            // 如果输入设备与ID匹配，并且处理程序的匹配函数返回true（或者没有匹配函数），则返回该ID
            return id;
        }
    }

    return NULL;
}
~~~

这个函数在输入子系统中的作用是在给定的输入事件处理程序（input handler）中查找与指定输入设备匹配的输入设备ID（input device ID）。下面是对函数的详细解释：

第6-13行：函数通过一个循环遍历处理程序的输入设备ID表，直到找到匹配的ID或遍历完所有ID为止。处理程序的输入设备ID表是一个以 struct input_device_id结构为元素的数组，每个元素表示一个可能的输入设备ID。

在循环中，函数使用 input_match_device_id(dev, id)调用输入设备ID匹配函数来判断给定的输入设备是否与当前ID匹配。匹配函数的作用是比较输入设备的属性与ID中指定的属性是否一致，例如厂商ID、产品ID等。如果输入设备与当前ID匹配，并且处理程序的匹配函数（handler->match）返回 true，则表示找到了匹配的ID。处理程序的匹配函数用于进一步检查设备是否满足处理程序特定的要求。如果处理程序没有指定匹配函数（handler->match为 NULL），则默认认为匹配。如果找到匹配的ID，函数立即返回该ID。如果遍历完所有ID都没有找到匹配的ID，则函数返回 NULL，表示在处理程序的输入设备ID表中没有与给定输入设备匹配的ID。

由于input_handler结构体属于事件处理层，所以与它相对应的input_dev结构体自然就属于设备驱动层，input_dev结构体定义在input.h中，该结构体内容具体如下所示：

~~~c
struct input_dev {
	const char *name;                   // 设备的名称
	const char *phys;                   // 设备的物理位置
	const char *uniq;                   // 设备的唯一标识符
	struct input_id id;                 // 输入设备的标识信息

	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];     // 设备的属性位图
	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];               // 设备支持的事件类型位图
	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];             // 设备支持的按键位图
	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];             // 设备支持的相对坐标位图
	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];             // 设备支持的绝对坐标位图
	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];             // 设备支持的杂项事件位图
	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];             // 设备支持的LED位图
	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];             // 设备支持的声音位图
	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];               // 设备支持的力反馈位图
	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];               // 设备支持的开关位图

	unsigned int hint_events_per_packet;                      // 每个输入事件报告中的事件数量提示

	unsigned int keycodemax;                                  // 支持的按键编码的最大值
	unsigned int keycodesize;                                 // 按键编码的字节大小
	void *keycode;                                           // 按键编码数据的指针

	int (*setkeycode)(struct input_dev *dev,
			  const struct input_keymap_entry *ke,
			  unsigned int *old_keycode);                  // 设置按键编码的回调函数
	int (*getkeycode)(struct input_dev *dev,
			  struct input_keymap_entry *ke);              // 获取按键编码的回调函数

	struct ff_device *ff;                                    // 力反馈设备

	unsigned int repeat_key;                                 // 重复按键的编码
	struct timer_list timer;                                 // 定时器用于处理重复按键

	int rep[REP_CNT];                                        // 按键重复设置

	struct input_mt *mt;                                    // 多点触摸信息

	struct input_absinfo *absinfo;                          // 绝对坐标信息

	unsigned long key[BITS_TO_LONGS(KEY_CNT)];              // 当前按键状态位图
	unsigned long led[BITS_TO_LONGS(LED_CNT)];              // 当前LED状态位图
	unsigned long snd[BITS_TO_LONGS(SND_CNT)];              // 当前声音状态位图
	unsigned long sw[BITS_TO_LONGS(SW_CNT)];                // 当前开关状态位图

	int (*open)(struct input_dev *dev);                      // 打开设备的回调函数
	void (*close)(struct input_dev *dev);                    // 关闭设备的回调函数
	int (*flush)(struct input_dev *dev, struct file *file);  // 刷新设备的回调函数
	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);  // 处理输入事件的回调函数

	struct input_handle __rcu *grab;                         // 设备的当前占用者

	spinlock_t event_lock;                                   // 事件锁，用于保护事件队列
	struct mutex mutex;                                      // 互斥锁，用于保护设备状态

	unsigned int users;                                      // 设备的使用者数量
	bool going_away;                                         // 设备是否即将被移除

	struct device dev;                                       // 设备结构体

	struct list_head	h_list;                                // 用于设备管理的链表
	struct list_head	node;                                 // 用于设备管理的链表

	unsigned int num_vals;                                   // 输入值的数量
	unsigned int max_vals;                                   // 最大输入值的数量
	struct input_value *vals;                                // 输入值的数组

	bool devres_managed;                                     // 是否由设备资源管理

	ktime_t timestamp[INPUTCLK_MAX];    // 输入事件的时间戳数组
};
~~~

关于input_dev结构体在后面编写实际驱动程序的时候会进行讲解，然后继续回到input_attach_handler函数，在input_attach_handler函数第12行调用的handler->connect函数，建立了输入设备和处理程序之间的连接，在讲解该函数之前首先引入input_handle结构体，在调用connect函数之后，会创建一个input_handle结构体，用于记录匹配成功的输入处理程序（input_handler）和输入设备（input_dev），并建立它们之间的关系。下面是input_handle结构体的定义（位于include/linux/input.h）：

```c
struct input_handle {
    void *private;                  // 私有数据指针
    int open;                       // 打开计数
    const char *name;               // 名称
    struct input_dev *dev;          // 输入设备
    struct input_handler *handler;  // 输入处理程序
    struct list_head d_node;        // 指向输入设备链表的节点
    struct list_head h_node;        // 指向输入处理程序链表的节点
};
```

connect函数定义在kernel/drivers/input/evdev.c文件中，具体内容如下所示：

~~~c
static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)
{
	struct evdev *evdev;
	int minor;
	int dev_no;
	int error;

	// 获取一个新的次设备号
	minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);
	if (minor < 0) {
		error = minor;
		pr_err("failed to reserve new minor: %d\n", error);
		return error;
	}

	// 分配并初始化 evdev 结构体
	evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);
	if (!evdev) {
		error = -ENOMEM;
		goto err_free_minor;
	}

	// 初始化 evdev 结构体中的成员
	INIT_LIST_HEAD(&evdev->client_list);  // 初始化客户端链表
	spin_lock_init(&evdev->client_lock);  // 初始化客户端链表的自旋锁
	mutex_init(&evdev->mutex);  // 初始化互斥锁
	init_waitqueue_head(&evdev->wait);  // 初始化等待队列头
	evdev->exist = true;  // 设置 evdev 存在标志为 true

	dev_no = minor;
	/* Normalize device number if it falls into legacy range */
	// 如果设备号在旧版范围内，则进行标准化处理
	if (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)
		dev_no -= EVDEV_MINOR_BASE;
	dev_set_name(&evdev->dev, "event%d", dev_no);  // 设置设备名称

	evdev->handle.dev = input_get_device(dev);  // 设置输入句柄的输入设备
	evdev->handle.name = dev_name(&evdev->dev);  // 设置输入句柄的名称为设备名称
	evdev->handle.handler = handler;  // 设置输入句柄的处理程序为传入的处理程序
	evdev->handle.private = evdev;  // 设置输入句柄的私有数据指针为 evdev 结构体的指针

	evdev->dev.devt = MKDEV(INPUT_MAJOR, minor);  // 设置设备号
	evdev->dev.class = &input_class;  // 设置设备的类
	evdev->dev.parent = &dev->dev;  // 设置设备的父设备
	evdev->dev.release = evdev_free;  // 设置设备的释放函数为 evdev_free
	device_initialize(&evdev->dev);  // 初始化设备

	error = input_register_handle(&evdev->handle);  // 注册输入句柄
	if (error)
		goto err_free_evdev;

	cdev_init(&evdev->cdev, &evdev_fops);  // 初始化字符设备结构体

	error = cdev_device_add(&evdev->cdev, &evdev->dev);  // 添加字符设备
	if (error)
		goto err_cleanup_evdev;

	return 0;

err_cleanup_evdev:
	evdev_cleanup(evdev);  // 清理 evdev 结构体
	input_unregister_handle(&evdev->handle);  // 取消注册输入句柄
err_free_evdev:
	put_device(&evdev->dev);  // 释放设备
err_free_minor:
	input_free_minor(minor);  // 释放次设备号
	return error;
}
~~~

该函数的主要功能是建立与输入设备的连接，初始化并注册输入句柄，设置设备属性，并添加字符设备到系统中 。

第8-14行：函数调用 input_get_new_minor 获取一个新的次设备号,以便将其分配给新的输入设备。

第16-21行：使用 kzalloc函数为 evdev 分配了一块内存，大小为 sizeof(struct evdev)，并将返回的指针赋值给 evdev。evdev 是一个结构体指针，用于管理与输入设备相关的数据和状态。

第23-27行，对 evdev 结构体进行初始化。它调用了几个初始化函数，包括 INIT_LIST_HEAD、spin_lock_init、mutex_init 和 init_waitqueue_head，用于初始化 evdev 结构体中的成员。

第28行：函数将 evdev->exist 设置为 true，表示 evdev 结构体表示的设备存在。

第30-34行：计算设备号 dev_no。

第35行：使用 dev_set_name 函数来设置设备的名称，格式为 "event%d"，其中 %d 是设备号。

第37-40行：设置 evdev 结构体中的输入句柄的属性。它将输入句柄的 dev 成员设置为输入设备 dev，将 name 成员设置为设备名称的字符串表示，将 handler 成员设置为传入的输入处理程序 handler，将 private 成员设置为 evdev 结构体的指针。

第42-45行：函数设置设备的属性。它将设备号设置为 MKDEV(INPUT_MAJOR, minor)，这是一个宏，用于创建设备号。它将设备的类设置为 input_class，这是一个表示输入设备的类结构体指针。它将设备的父设备设置为输入设备 dev 的父设备。最后，它将设备的释放函数设置为 evdev_free，这是在设备被释放时调用的函数。

第46行：调用 device_initialize 初始化设备。

第48行：调用 input_register_handle 注册输入句柄。这将输入句柄添加到输入子系统中，以便处理输入事件。

第52行：使用 cdev_init 函数初始化字符设备结构体 evdev->cdev，并将字符设备的操作函数指针设置为 evdev_fops。

第54行：调用 cdev_device_add 将字符设备添加到系统中。这将使得字符设备可以被用户空间的程序打开和访问。

input_register_handle函数用来注册input_handle句柄，该函数定义在drivers/input/input.c文件中，具体内容如下所示：

~~~c
int input_register_handle(struct input_handle *handle)
{
	struct input_handler *handler = handle->handler;  // 获取输入处理程序
	struct input_dev *dev = handle->dev;              // 获取输入设备
	int error;

	/*
	 * 在这里获取 dev->mutex 锁，以防止与 input_release_device() 的竞争。
	 */
	error = mutex_lock_interruptible(&dev->mutex);
	if (error)
		return error;

	/*
	 * 将过滤器添加到链表头部，普通处理程序添加到链表尾部。
	 */
	if (handler->filter)
		list_add_rcu(&handle->d_node, &dev->h_list);
	else
		list_add_tail_rcu(&handle->d_node, &dev->h_list);

	mutex_unlock(&dev->mutex);

	/*
	 * 由于我们假设被从 ->connect() 调用，这与 ->disconnect() 是互斥的，
	 * 所以我们不能与 input_unregister_handle() 竞争，因此此处不需要额外的锁定。
	 */
	list_add_tail_rcu(&handle->h_node, &handler->h_list);

	if (handler->start)
		handler->start(handle);

	return 0;
}
~~~

该函数的主要作用是将输入处理程序（input_handler）和输入设备（input_dev）建立关联。对于输入设备来说，可以通过遍历handler->h_list链表来查找与之匹配的输入处理程序。这意味着输入设备可以通过遍历与之相关联的输入处理程序链表来找到相应的处理程序。对于输入处理程序来说，可以通过遍历dev->h_list链表来查找与之匹配的输入设备。这意味着输入处理程序可以通过遍历与之相关联的输入设备链表来找到相应的设备。这样，通过建立输入处理程序和输入设备之间的关联关系，可以实现输入处理程序对特定输入设备的处理和控制。

第3-4行：获取输入句柄中的输入处理程序和输入设备分别赋值给handler和dev。

第10行：函数获取输入设备的互斥锁dev->mutex，以防止与input_release_device()函数的竞争。如果获取锁失败，函数返回相应的错误代码。

第17-20行：根据输入处理程序的类型，将输入句柄添加到输入设备的h_list链表中。如果输入处理程序是过滤器类型（handler->filter为真），则将输入句柄添加到链表头部（使用list_add_rcu函数），否则将输入句柄添加到链表尾部（使用list_add_tail_rcu函数）。通过将输入句柄添加到链表中，建立了输入设备与输入句柄之间的关联关系。

第22行：解锁输入设备的互斥锁dev->mutex。

第28行：将输入句柄添加到输入处理程序的h_list链表中，使用list_add_tail_rcu函数将输入句柄添加到链表尾部。通过将输入句柄添加到链表中，建立了输入处理程序与输入句柄之间的关联关系。

第30-31行：如果输入处理程序的start函数存在，则调用handler->start(handle)来启动输入处理程序的相关操作。

input_handler结构体要使用input_register_handler来注册，而输入处理程序（input_handler）和输入设备（input_dev）链接的结构体input_handle也需要input_register_handle函数来注册，那输入设备input_dev结构体肯定也需要一个函数来注册，input_dev结构体的注册函数为input_register_device，定义在drivers/input/input.c文件中，函数的具体内容如下所示

____

~~~c
int input_register_device(struct input_dev *dev)
{
	struct input_devres *devres = NULL;  // 输入设备资源结构体指针
	struct input_handler *handler;       // 输入处理程序指针
	unsigned int packet_size;            // 数据包大小
	const char *path;                    // 设备路径字符串指针
	int error;

	if (test_bit(EV_ABS, dev->evbit) && !dev->absinfo) {
		dev_err(&dev->dev,
			"Absolute device without dev->absinfo, refusing to register\n");
		return -EINVAL;
	}

	if (dev->devres_managed) {  // 如果设备资源是由管理的，则分配设备资源结构体
		devres = devres_alloc(devm_input_device_unregister,
				      sizeof(*devres), GFP_KERNEL);
		if (!devres)
			return -ENOMEM;

		devres->input = dev;
	}

	/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */
	__set_bit(EV_SYN, dev->evbit);

	/* KEY_RESERVED 不应传递给用户空间。 */
	__clear_bit(KEY_RESERVED, dev->keybit);

	/* 确保未在 dev->evbit 中提及的位掩码是干净的。 */
	input_cleanse_bitmasks(dev);

	packet_size = input_estimate_events_per_packet(dev);
	if (dev->hint_events_per_packet < packet_size)
		dev->hint_events_per_packet = packet_size;

	dev->max_vals = dev->hint_events_per_packet + 2;
	dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);
	if (!dev->vals) {
		error = -ENOMEM;
		goto err_devres_free;
	}

	/*
	 * 如果延迟和周期由驱动程序预设，
	 * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。
	 */
	if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD])
		input_enable_softrepeat(dev, 250, 33);

	if (!dev->getkeycode)
		dev->getkeycode = input_default_getkeycode;

	if (!dev->setkeycode)
		dev->setkeycode = input_default_setkeycode;

	error = device_add(&dev->dev);
	if (error)
		goto err_free_vals;

	path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
	pr_info("%s as %s\n",
		dev->name ? dev->name : "Unspecified device",
		path ? path : "N/A");
	kfree(path);

	error = mutex_lock_interruptible(&input_mutex);
	if (error)
		goto err_device_del;

	list_add_tail(&dev->node, &input_dev_list);

	// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联
	list_for_each_entry(handler, &input_handler_list, node)
		input_attach_handler(dev, handler);

	input_wakeup_procfs_readers();

	mutex_unlock(&input_mutex);

	if (dev->devres_managed) {
		dev_dbg(dev->dev.parent, "%s: registering %s with devres.\n",
			__func__, dev_name(&dev->dev));
		devres_add(dev->dev.parent, devres);
	}
	return 0;

err_device_del:
	device_del(&dev->dev);
err_free_vals:
	kfree(dev->vals);
	dev->vals = NULL;
err_devres_free:
	devres_free(devres);
	return error;
}
~~~

input_register_device函数用于注册输入设备（input_dev），将输入设备添加到输入子系统中，会在后面的输入子系统驱动编写中重新讲解该函数，至此关于输入子系统数据结构的介绍就完成了，整理好的输入子系统数据结构关系框图如下所示：

____

![image-20240205103215813](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402051032885.png)



# 4.认识内核中输入子系统的源码和裁剪

## 4.1 认识内核中输入子系统的源码

input子系统源码所在路径为kernel/drivers/input,如下图所示：
![image-20240205110519547](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402051105606.png)

每个文件和文件夹的作用如下所示：

| 文件/目录       | 作用                                                         |
| :-------------- | :----------------------------------------------------------- |
| apm-power.c     | 提供与Advanced Power Management (APM)相关的输入设备接口。    |
| evbug.c         | 提供用于调试的虚拟输入设备，可以模拟按键、鼠标移动等事件。   |
| evdev.c         | 提供通用的输入事件层，将所有输入设备的事件转化为标准化的输入事件格式，并提供给上层用户空间程序使用。 |
| ff-core.c       | 提供力反馈设备的支持，允许输入设备发送力反馈信息。           |
| ff-memless.c    | 提供一种无需分配内存的力反馈设备支持，适用于资源受限的嵌入式系统。 |
| gameport/       | 包含支持游戏控制器的驱动程序的目录。                         |
| input.c         | 提供输入子系统的初始化和事件处理等操作。                     |
| input-leds.c    | 提供LED指示灯设备的支持，允许控制LED指示灯的状态。           |
| joydev.c        | 提供支持游戏杆的驱动程序，处理游戏杆设备的输入事件。         |
| keyboard/       | 包含支持键盘的驱动程序的目录。                               |
| misc/           | 包含其他类型输入设备的驱动程序的目录，如红外线遥控器、输入音频等。 |
| remotectl/      | 提供支持远程控制的驱动程序，处理通过遥控器发送的输入事件。   |
| serio/          | 提供支持通过串行端口接入的输入设备的驱动程序，处理串行输入设备的通信和处理。 |
| sensors/        | 包含与传感器相关的驱动程序的目录，用于与各种传感器设备通信和处理。 |
| sparse-keymap.c | 提供稀疏键映射的支持，允许按任意键码分配键位，适用于具有非标准键盘布局或特殊功能键的设备。 |
| tablet/         | 提供支持绘图板和其他类型图形输入设备的驱动程序，处理绘图板设备的输入事件。 |
| touchscreen/    | 提供支持触摸屏的驱动程序，处理触摸屏设备的输入事件。         |

## 4.2 输入子系统源码裁剪和配置

默认情况下，linux内核已经支持了很多设备，但是在实际的使用中并使用不到，这时候就需要对输入子系统进行裁剪了，首先使用以下命令进入到内核图像化配置界面，如下图所示：

```shell
export ARCH=arm64
make rockchip_linux_defconfig
make menuconfig
```

![image-20240205112214533](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402051122577.png)

![image-20240205112241251](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402051122305.png)

使用键盘导航键移动光标，进入以下路径,如下图所示：

```
Device Drivers --->
	Input device support --->
```

![image-20240205112543066](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402051125132.png)

该图形化界面的部分注释如下所示：

~~~
   -*- Generic input layer (needed for keyboard, mouse, ...)   //input 核心层                           │ │  
  │ │              <*>   Export input device LEDs in sysfs                                             │ │  
  │ │              <*>   Support for memoryless force-feedback devices                                 │ │  
  │ │              -*-   Polled input device skeleton                                                  │ │  
  │ │              < >   Sparse keymap support library                                                 │ │  
  │ │              -*-   Matrix keymap support library                                                 │ │  
  │ │                    *** Userland interfaces ***                                                   │ │  
  │ │              < >   Mouse interface              //事件处理层                                      │ │  
  │ │              < >   Joystick interface         //事件处理层                                        │ │  
  │ │              <*>   Event interface            //事件处理层                                        │ │  
  │ │              < >   Event debugging                                                               │ │  
  │ │                    *** Input Device Drivers ***                                                  │ │  
  │ │              [*]   Keyboards  --->            //设备驱动层                                        │ │  
  │ │              [*]   Mice  --->                //设备驱动层                                         │ │  
  │ │              [ ]   Joysticks/Gamepads  ----    //设备驱动层                                       │ │  
  │ │              [ ]   Tablets  ----                                                                 │ │  
  │ │              [*]   Touchscreens  --->         //设备驱动层                                        │ │  
  │ │              <*>   rockchip remotectl  --->                                                      │ │  
  │ │                    *** handle all sensors ***                                                    │ │  
  │ │              < >   handle angle,accel,compass,gyroscope,lsensor psensor etc  ----                │ │  
  │ │              [*]   Miscellaneous devices  --->                                                   │ │  
  │ │              < >   Synaptics RMI4 bus support                                                    │ │  
  │ │                  Hardware I/O ports  --->                                   
~~~

如果想要对内核裁剪和配置，只需要勾选和取消即可，至此，关于输入子系统源码裁剪和配置就完成了



# 5.编写最简单的设备驱动层代码

从上面的学习中可以了解到，输入子系统可以分为三层，分别为中间的核心层，靠近上层应用的事件处理层，以及靠近硬件设备的设备驱动层，事件处理层的代码一般情况下也不需要编写，所以需要我们来编写的就只有设备驱动层的代码。本小节将编写一个最简单的设备驱动层代码。

## 5.1 设备驱动层代码编写步骤

步骤一：创建输入设备结构体变量
	在设备驱动的开发中，首先需要创建一个输入设备的结构体变量，该结构体变量将用于表示和管理设备的属性和状态。可以使用 input_allocate_device 函数来分配输入设备结构体的内存。

步骤二：初始化输入设备结构体变量
	在创建输入设备结构体变量后，需要对其进行初始化。这包括设置设备的名称、支持的事件类型、事件处理函数等。可以使用结构体提供的成员变量和函数来完成初始化过程。

步骤三：注册输入设备结构体变量
	在初始化输入设备结构体变量后，需要将其注册到系统中，以便系统能够正确地识别和使用该设备。可以使用 input_register_device 函数来注册输入设备结构体变量。在注册过程中，系统将完成设备的匹配和初始化工作。

步骤四：上报事件
	一旦设备注册成功，就可以通过输入设备结构体变量上报事件。这可以通过调用输入设备结构体提供的函数来完成，例如 input_event 函数。根据设备类型和事件类型，可以生成相应的输入事件，并通过调用该函数将事件发送给系统。

注：本章节只是为了编写最简单的设备驱动层代码，所以本章节不会涉及到事件上报这一步骤相关的代码，会在后面的章节再进行填充。

步骤五：注销和释放输入设备结构体变量
	当设备不再需要使用时，应该进行注销和释放操作，以确保资源的正确释放。可以使用 input_unregister_device 函数来注销输入设备结构体变量，并使用 input_free_device 函数来释放相关资源和内存。

## 5.2 input_allocate_device 函数讲解

input_allocate_device 函数定义在drivers/input/input.c文件中，具体内容如下所示：
~~~c
struct input_dev *input_allocate_device(void)
{
    static atomic_t input_no = ATOMIC_INIT(-1);
    struct input_dev *dev;

    // 分配输入设备结构体的内存
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    if (dev) {
        // 设置设备类型和设备类
        dev->dev.type = &input_dev_type;
        dev->dev.class = &input_class;

        // 初始化设备
        device_initialize(&dev->dev);

        // 初始化互斥锁和事件自旋锁
        mutex_init(&dev->mutex);
        spin_lock_init(&dev->event_lock);

        // 初始化定时器
        timer_setup(&dev->timer, NULL, 0);

        // 初始化链表头
        INIT_LIST_HEAD(&dev->h_list);
        INIT_LIST_HEAD(&dev->node);

        // 设置设备名称，使用原子变量递增来保证唯一性
        dev_set_name(&dev->dev, "input%lu", (unsigned long)atomic_inc_return(&input_no));

        // 增加模块引用计数
        __module_get(THIS_MODULE);
    }

    return dev;
}
~~~

这个函数的作用是为输入设备分配内存并进行必要的初始化，为后续的输入事件处理和设备注册做准备。

## 5.3 初始化input_dev 结构体

在使用input_allocate_device函数创建了一个input_dev结构体之后，接下来就要初始化input_dev结构体内容了，在该步骤中又有两个内容，分别为设置事件类型和设置具体类型。

### 5.3.1 设置事件类型

在头文件include/uapi/linux/input-event-codes.h中，Linux内核已经为我们定义了一些输入事件类型，它们的含义如下：

- EV_SYN (0x00): 用于同步事件，表示一组输入事件的结束。
- EV_KEY (0x01): 用于按键事件，表示按下、释放或重复一个键。
- EV_REL (0x02): 用于相对位移事件，表示设备的相对位置变化，例如鼠标的移动。
- EV_ABS (0x03): 用于绝对位移事件，表示设备的绝对位置变化，例如触摸屏的坐标。
- EV_MSC (0x04): 用于杂项事件，包含一些特殊目的的事件类型，例如设备状态变化等。
- EV_SW (0x05): 用于开关事件，表示开关的状态变化，例如电源按钮、开合盖等。
- EV_LED (0x11): 用于 LED 事件，表示 LED 灯的状态变化。
- EV_SND (0x12): 用于声音事件，表示声音的播放相关事件。
- EV_REP (0x14): 用于重复事件，表示键盘重复发送事件。
- EV_FF (0x15): 用于力反馈事件，表示力反馈设备的输出事件。
- EV_PWR (0x16): 用于电源事件，表示电源状态变化。
- EV_FF_STATUS (0x17): 用于力反馈状态事件，表示力反馈设备的状态变化。
- EV_MAX (0x1f): 输入事件类型的最大值。
- EV_CNT: 输入事件类型的数量。

而在input_dev结构体中定义了一系列的位图，在输入子系统中用于表示输入设备的能力和支持的功能，具体定义如下所示：

~~~c
unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];     // 设备的属性位图
unsigned long evbit[BITS_TO_LONGS(EV_CNT)];               // 设备支持的事件类型位图
unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];             // 设备支持的按键位图
unsigned long relbit[BITS_TO_LONGS(REL_CNT)];             // 设备支持的相对坐标位图
unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];             // 设备支持的绝对坐标位图
unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];             // 设备支持的杂项事件位图
unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];             // 设备支持的LED位图
unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];             // 设备支持的声音位图
unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];               // 设备支持的力反馈位图
unsigned long swbit[BITS_TO_LONGS(SW_CNT)];               // 设备支持的开关位图
~~~

- evbit（事件类型位图）是一个长度为 EV_CNT 的数组，每个元素对应一个事件类型。通过设置相应的位，可以指示设备支持的事件类型，如按键事件、相对位移事件、绝对位移事件、杂项事件等。
- keybit（按键类型位图）表示输入设备支持的按键类型，通常与 EV_KEY 事件类型相关。通过设置相应的位，可以指示设备支持的按键。
- relbit（相对位移类型位图）表示输入设备支持的相对位移类型，通常与 EV_REL 事件类型相关。通过设置相应的位，可以指示设备支持的相对位移，例如鼠标的移动。
- absbit（绝对位移类型位图）表示输入设备支持的绝对位移类型，通常与 EV_ABS 事件类型相关。通过设置相应的位，可以指示设备支持的绝对位移，例如触摸屏的坐标。
- mscbit（杂项类型位图）表示输入设备支持的杂项类型，通常与 EV_MSC 事件类型相关。通过设置相应的位，可以指示设备支持的杂项事件，例如设备状态变化等。
- ledbit（LED 类型位图）表示输入设备支持的 LED 类型，通常与 EV_LED 事件类型相关。通过设置相应的位，可以指示设备支持的 LED 灯控制。
- sndbit（声音类型位图）表示输入设备支持的声音类型，通常与 EV_SND 事件类型相关。通过设置相应的位，可以指示设备支持的声音事件。
- ffbit（力反馈类型位图）表示输入设备支持的力反馈类型，通常与 EV_FF 事件类型相关。通过设置相应的位，可以指示设备支持的力反馈事件。
- swbit（开关类型位图）表示输入设备支持的开关类型，通常与 EV_SW 事件类型相关。通过设置相应的位，可以指示设备支持的开关状态变化。

这些位图用于向输入子系统提供关于输入设备的能力和功能的信息，以便在注册和处理输入设备时进行相应的配置和过滤。通过设置相应的位，可以告知输入子系统设备所支持的事件类型和功能，使得输入子系统能够正确识别和处理来自设备的输入数据。

__set_bit是一个位操作函数，用于设置一个位图中的特定位，例如可以通过下面的代码将输入设备设置为支持按键事件：

~~~c
__set_bit(EV_KEY,myinput_dev->evbit)
~~~

### 5.3.2 设置具体类型

设置完事件类型之后，还需要设置具体类型，宏定义仍旧定义在头文件include/uapi/linux/input-event-codes.h中，部分内容如下所示：

~~~c
#define KEY_RESERVED		0
#define KEY_ESC			1
#define KEY_1			2
#define KEY_2			3
#define KEY_3			4
#define KEY_4			5
#define KEY_5			6
#define KEY_6			7
#define KEY_7			8
#define KEY_8			9
#define KEY_9			10
~~~

上一小节只是将输入设备设置为了按键事件，但具体要表示什么呢，是按键1还是按键2亦或者其他按键，都无法确定，所以仍旧需要使用__set_bit函数来确定具体类型，例如使用以下程序将该输入设备设置为按键1

~~~c
__set_bit(KEY_1,myinput_dev->keybit)
~~~

## 5.4 驱动程序的编写

本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\91_myinput_dev。

编写完成的myinput_dev.c代码如下所示:

~~~C
#include <linux/input.h>
#include <linux/module.h>

struct input_dev *myinput_dev;

static int myinput_dev_init(void)
{
    int ret;

    // 分配输入设备结构体
    myinput_dev = input_allocate_device();
    if (myinput_dev == NULL) {
        printk("input_allocate_device error\n");
        return -1;
    }

    // 设置输入设备的名称
    myinput_dev->name = "myinput_dev";

    // 设置输入设备支持的事件类型
    __set_bit(EV_KEY, myinput_dev->evbit);    // 设置支持按键事件
    __set_bit(KEY_1, myinput_dev->keybit);    // 设置支持按键1

    // 注册输入设备
    ret = input_register_device(myinput_dev);
    if (ret < 0) {
        printk("input_register_device error\n");
        goto error;
    }

    return 0;

error:
    // 注册失败，释放输入设备结构体
    input_free_device(myinput_dev);
    return ret;
}

static void myinput_dev_exit(void)
{
    // 注销输入设备
    input_unregister_device(myinput_dev);
}

module_init(myinput_dev_init);
module_exit(myinput_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("topeet");
~~~

## 5.5 运行测试

### 5.5.1  编译驱动程序

在上一小节中的myinput_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += myinput_dev.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放myinput_dev.c和Makefile文件目录下，如下图所示：

![image-20240218105121774](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181051813.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240218105107214](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181051292.png)

编译完生成myinput_dev.ko目标文件，如下图所示：

![image-20240218105313897](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181053934.png)

至此驱动模块就编译成功了。

### 5.5.2 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181059675.png)

然后将上一小节编译完成的myinput_dev.ko驱动文件拷贝到开发板上，拷贝完成如下所示：
![image-20240218110447298](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181104348.png)

在加载驱动之前首先使用以下命令查看当前的输入设备，如下所示：

~~~
ls /dev/input
~~~



![image-20240218110719974](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181107008.png)

可以看到目前有4个输入设备的设备节点，然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod myinput_dev.ko
~~~

![image-20240218111545664](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181115715.png)

然后重新查看设备节点，可以看到多出来了一个event4节点，如下图所示：
![image-20240218111708043](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181117078.png)

然后使用以下命令查看设备节点信息，可以根据名字确定event4正是加载驱动所创建的，如下图所示：

~~~
cat /proc/bus/input/devices
~~~

![image-20240218111840838](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181118884.png)

至此，关于最简单的设备驱动程序就测试完成了。

# 6.从最简单的设备驱动代码入手分析匹配规则

​	在上一章中编写完成了最简单的设备驱动层代码，从实验现象可以得到，输入设备注册完成之后会自动生成相应的设备节点，在数据结构的介绍中讲解过，设备驱动层的结构体会和事件处理层的结构体进行匹配，可是从上一章编写的代码中并没有看到匹配的过程，所以在本章中将会分析设备驱动层是怎样跟事件处理层进行匹配的？

设备驱动层的input_dev结构体由input_register_device函数所注册，该函数的具体内容如下所示：

~~~c
int input_register_device(struct input_dev *dev)
{
	struct input_devres *devres = NULL;  // 输入设备资源结构体指针
	struct input_handler *handler;       // 输入处理程序指针
	unsigned int packet_size;            // 数据包大小
	const char *path;                    // 设备路径字符串指针
	int error;

	if (test_bit(EV_ABS, dev->evbit) && !dev->absinfo) {
		dev_err(&dev->dev,
			"Absolute device without dev->absinfo, refusing to register\n");
		return -EINVAL;
	}

	if (dev->devres_managed) {  // 如果设备资源是由管理的，则分配设备资源结构体
		devres = devres_alloc(devm_input_device_unregister,
				      sizeof(*devres), GFP_KERNEL);
		if (!devres)
			return -ENOMEM;

		devres->input = dev;
	}

	/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */
	__set_bit(EV_SYN, dev->evbit);

	/* KEY_RESERVED 不应传递给用户空间。 */
	__clear_bit(KEY_RESERVED, dev->keybit);

	/* 确保未在 dev->evbit 中提及的位掩码是干净的。 */
	input_cleanse_bitmasks(dev);

	packet_size = input_estimate_events_per_packet(dev);
	if (dev->hint_events_per_packet < packet_size)
		dev->hint_events_per_packet = packet_size;

	dev->max_vals = dev->hint_events_per_packet + 2;
	dev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);
	if (!dev->vals) {
		error = -ENOMEM;
		goto err_devres_free;
	}

	/*
	 * 如果延迟和周期由驱动程序预设，
	 * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。
	 */
	if (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD])
		input_enable_softrepeat(dev, 250, 33);

	if (!dev->getkeycode)
		dev->getkeycode = input_default_getkeycode;

	if (!dev->setkeycode)
		dev->setkeycode = input_default_setkeycode;

	error = device_add(&dev->dev);
	if (error)
		goto err_free_vals;

	path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
	pr_info("%s as %s\n",
		dev->name ? dev->name : "Unspecified device",
		path ? path : "N/A");
	kfree(path);

	error = mutex_lock_interruptible(&input_mutex);
	if (error)
		goto err_device_del;

	list_add_tail(&dev->node, &input_dev_list);

	// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联
	list_for_each_entry(handler, &input_handler_list, node)
		input_attach_handler(dev, handler);

	input_wakeup_procfs_readers();

	mutex_unlock(&input_mutex);

	if (dev->devres_managed) {
		dev_dbg(dev->dev.parent, "%s: registering %s with devres.\n",
			__func__, dev_name(&dev->dev));
		devres_add(dev->dev.parent, devres);
	}
	return 0;

err_device_del:
	device_del(&dev->dev);
err_free_vals:
	kfree(dev->vals);
	dev->vals = NULL;
err_devres_free:
	devres_free(devres);
	return error;
}
~~~

上述内容的重点为75行的input_attach_handler 函数，该函数可以为每个输入设备建立与处理程序的连接，该函数同样定义在input.c中，具体内容如下所示：

~~~c
static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)
{
    const struct input_device_id *id;
    int error;

    // 通过输入设备和处理程序的匹配函数来确定是否适用于该设备
    id = input_match_device(handler, dev);
    if (!id)
        return -ENODEV;

    // 调用处理程序的连接函数来建立设备和处理程序之间的连接
    error = handler->connect(handler, dev, id);
    if (error && error != -ENODEV)
        pr_err("failed to attach handler %s to device %s, error: %d\n",
               handler->name, kobject_name(&dev->dev.kobj), error);
    // 如果连接失败且错误码不是-ENODEV，则打印错误消息

    return error;
}
~~~

第7行：调用 input_match_device(handler, dev)函数来确定输入设备和处理程序是否匹配。这个函数将在处理程序的输入设备ID表中查找与给定的输入设备匹配的ID，并返回匹配的ID。如果没有找到匹配的ID，则返回 NULL。

第12行：如果找到匹配的ID会调用 handler->connect(handler, dev, id)函数，这是处理程序的连接函数。该函数用于建立输入设备和处理程序之间的连接，并执行必要的初始化和配置。它将处理程序、输入设备和匹配的ID作为参数传递。

无论是第7行的input_match_device函数还是第12行的handler->connect函数都是很重要的，首先来看第7行调用的input_match_device函数，函数具体内容如下所示：

~~~c
static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)
{
    const struct input_device_id *id;

    // 遍历处理程序的输入设备ID表，直到找到匹配的ID或遍历完所有ID为止
    for (id = handler->id_table; id->flags || id->driver_info; id++) {
        // 使用输入设备ID匹配函数判断给定的输入设备是否与当前ID匹配
        if (input_match_device_id(dev, id) &&
            (!handler->match || handler->match(handler, dev))) {
            // 如果输入设备与ID匹配，并且处理程序的匹配函数返回true（或者没有匹配函数），则返回该ID
            return id;
        }
    }

    return NULL;
}
~~~

这个函数在输入子系统中的作用是在给定的输入事件处理程序（input handler）中查找与指定输入设备匹配的输入设备ID（input device ID）。下面是对函数的详细解释：

第6-13行：函数通过一个循环遍历处理程序的输入设备ID表，直到找到匹配的ID或遍历完所有ID为止。处理程序的输入设备ID表是一个以 struct input_device_id结构为元素的数组，每个元素表示一个可能的输入设备ID。

在循环中，函数使用 input_match_device_id(dev, id)调用输入设备ID匹配函数来判断给定的输入设备是否与当前ID匹配。匹配函数的作用是比较输入设备的属性与ID中指定的属性是否一致，例如厂商ID、产品ID等。如果输入设备与当前ID匹配，并且处理程序的匹配函数（handler->match）返回 true，则表示找到了匹配的ID。处理程序的匹配函数用于进一步检查设备是否满足处理程序特定的要求。如果处理程序没有指定匹配函数（handler->match为 NULL），则默认认为匹配。如果找到匹配的ID，函数立即返回该ID。如果遍历完所有ID都没有找到匹配的ID，则函数返回 NULL，表示在处理程序的输入设备ID表中没有与给定输入设备匹配的ID。

在上面的for循环中会遍历所有事件处理层的handler，这里以drivers/input/evdev.c这一通用事件处理层中的input_handler为例进行讲解，类型的结构体中有如下内容：

~~~c
static struct input_handler evdev_handler = {
	.event		= evdev_event,
	.events		= evdev_events,
	.connect	= evdev_connect,
	.disconnect	= evdev_disconnect,
	.legacy_minors	= true,
	.minor		= EVDEV_MINOR_BASE,
	.name		= "evdev",
	.id_table	= evdev_ids,
};
~~~

其中evdev_handler结构体中的id_table变量为evdev_ids，evdev_ids内容如下所示：

~~~c
static const struct input_device_id evdev_ids[] = {
	{ .driver_info = 1 },	/* Matches all devices */
	{ },			/* Terminating zero entry */
};
~~~

由于driver_info为1，所以for循环的条件就会一直成立，在每一次的循环中都会判定id是不是匹配，判定的函数是input_match_device_id，该函数的内容如下所示：
~~~c
bool input_match_device_id(const struct input_dev *dev,
                           const struct input_device_id *id)
{
    // 检查设备的总线类型是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
        if (id->bustype != dev->id.bustype)
            return false;

    // 检查设备的厂商ID是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)
        if (id->vendor != dev->id.vendor)
            return false;

    // 检查设备的产品ID是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)
        if (id->product != dev->id.product)
            return false;

    // 检查设备的版本号是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)
        if (id->version != dev->id.version)
            return false;

    // 检查设备的事件位图是否是给定ID的子集
    if (!bitmap_subset(id->evbit, dev->evbit, EV_MAX) ||
        !bitmap_subset(id->keybit, dev->keybit, KEY_MAX) ||
        !bitmap_subset(id->relbit, dev->relbit, REL_MAX) ||
        !bitmap_subset(id->absbit, dev->absbit, ABS_MAX) ||
        !bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX) ||
        !bitmap_subset(id->ledbit, dev->ledbit, LED_MAX) ||
        !bitmap_subset(id->sndbit, dev->sndbit, SND_MAX) ||
        !bitmap_subset(id->ffbit, dev->ffbit, FF_MAX) ||
        !bitmap_subset(id->swbit, dev->swbit, SW_MAX) ||
        !bitmap_subset(id->propbit, dev->propbit, INPUT_PROP_MAX)) {
        return false;
    }

    // 所有匹配条件都满足，返回true
    return true;
}
~~~

由于在编写的最简单的设备驱动层代码中并未定义id的flags参数，所以第5、10、15、20中的判断都不成立，而bitmap_subset`是一个内联函数，用于判断两个位图是否具有子集关系，id中并未定义evbit、keybit、relbit等，所以25-34行的if判断也不成立，最终该函数会返回true，当然这仅仅只是对evdev.c这一通用事件处理代码进行的分析，返回true之后然后回到input_attach_handler 函数，在第12行会调用handler->connect建立与输入设备的连接。

至此上一章节中编写的最简单设备驱动层代码的匹配就讲解完成了，这一章节中是根据drivers/input/evdev.c这一通用时间处理层的代码来进行分析的，而drivers/input/joydev.c也是一个事件处理层代码，那在上一章中编写的最简单的设备驱动层代码能跟drivers/input/joydev.c匹配上吗，会在下一小节中进行分析。

# 7.多对多的匹配关系分析

## 7.1 joydev.c事件处理层匹配分析

drivers/input/joydev.c文件的input_handler结构体内容如下所示：

~~~c
static struct input_handler joydev_handler = {
	.event		= joydev_event,
	.match		= joydev_match,
	.connect	= joydev_connect,
	.disconnect	= joydev_disconnect,
	.legacy_minors	= true,
	.minor		= JOYDEV_MINOR_BASE,
	.name		= "joydev",
	.id_table	= joydev_ids,
};

static int __init joydev_init(void)
{
	return input_register_handler(&joydev_handler);
}
~~~

与上面讲解的通用设备驱动层evdev.c的evdev_handler结构体不同的是，joydev_handler结构体中有着对应的匹配函数，也就是说当设备驱动层与事件处理层进行匹配的时候，需要joydev_ids结构体数组和相应的匹配函数共同决定，首先来看joydev_ids结构体，joydev_ids结构体内容如下所示：

~~~c
static const struct input_device_id joydev_ids[] = {
    // 第一个标识符，匹配X轴（ABS_X）的绝对事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_ABSBIT,
		.evbit = { BIT_MASK(EV_ABS) },    // 匹配的事件类型是EV_ABS（绝对事件）
		.absbit = { BIT_MASK(ABS_X) },    // 匹配的绝对事件类型是ABS_X（X轴）
	},
	// 第二个标识符，匹配Z轴（ABS_Z）的绝对事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_ABSBIT,
		.evbit = { BIT_MASK(EV_ABS) },    // 匹配的事件类型是EV_ABS（绝对事件）
		.absbit = { BIT_MASK(ABS_Z) },    // 匹配的绝对事件类型是ABS_Z（Z轴）
	},
	// 第三个标识符，匹配滚轮（ABS_WHEEL）的绝对事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_ABSBIT,
		.evbit = { BIT_MASK(EV_ABS) },    // 匹配的事件类型是EV_ABS（绝对事件）
		.absbit = { BIT_MASK(ABS_WHEEL) },    // 匹配的绝对事件类型是ABS_WHEEL（滚轮）
	},
	// 第四个标识符，匹配油门（ABS_THROTTLE）的绝对事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_ABSBIT,
		.evbit = { BIT_MASK(EV_ABS) },    // 匹配的事件类型是EV_ABS（绝对事件）
		.absbit = { BIT_MASK(ABS_THROTTLE) },    // 匹配的绝对事件类型是ABS_THROTTLE（油门）
	},
	// 第五个标识符，匹配游戏杆（BTN_JOYSTICK）的按键事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_KEYBIT,
		.evbit = { BIT_MASK(EV_KEY) },    // 匹配的事件类型是EV_KEY（按键事件）
		.keybit = { [BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) },    // 匹配的按键类型是BTN_JOYSTICK（游戏杆）
	},
	// 第六个标识符，匹配游戏手柄（BTN_GAMEPAD）的按键事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_KEYBIT,
		.evbit = { BIT_MASK(EV_KEY) },    // 匹配的事件类型是EV_KEY（按键事件）
		.keybit = { [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) },    // 匹配的按键类型是BTN_GAMEPAD（游戏手柄）
	},
	// 第七个标识符，匹配快乐键（BTN_TRIGGER_HAPPY）的按键事件
	{
		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
				INPUT_DEVICE_ID_MATCH_KEYBIT,
		.evbit = { BIT_MASK(EV_KEY) },    // 匹配的事件类型是EV_KEY（按键事件）
		.keybit = { [BIT_WORD(BTN_TRIGGER_HAPPY)] = BIT_MASK(BTN_TRIGGER_HAPPY) },    // 匹配的按键类型是BTN_TRIGGER_HAPPY（快乐键）
	},
	{ }	/* 终止项 */
};
~~~

​	结构体input_device_id的作用是描述输入设备的特征，以便内核能够识别和匹配正确的驱动程序。在通用设备驱动层evdev.c中的evdev_ids结构体数组设置的是driver_info表示匹配全部设备，而joydev.c中的joydev_ids结构体数组包含以下字段：

- flags：标识符的标志位，用于指定匹配方式。在这里，使用flags字段的INPUT_DEVICE_ID_MATCH_EVBIT和INPUT_DEVICE_ID_MATCH_ABSBIT标志表示匹配事件类型和绝对事件类型。
- evbit：事件类型的位掩码，用于指定要匹配的事件类型。在这里，evbit字段的位掩码表示匹配的事件类型是EV_ABS（绝对事件）或EV_KEY（按键事件）。
- absbit：绝对事件类型的位掩码，用于指定要匹配的绝对事件类型。在这里，absbit字段的位掩码表示匹配的绝对事件类型是ABS_X（X轴）、ABS_Z（Z轴）、ABS_WHEEL（滚轮）或ABS_THROTTLE（油门）。
- keybit：按键类型的位掩码，用于指定要匹配的按键类型。在这里，keybit字段的位掩码表示匹配的按键类型是BTN_JOYSTICK（游戏杆）、BTN_GAMEPAD（游戏手柄）或BTN_TRIGGER_HAPPY（快乐键）。

​	这个结构体数组中的每个元素都描述了一种输入设备的特征，包括事件类型和按键类型。内核可以使用这些标识符来匹配输入设备并加载适当的驱动程序，以便正确解析和处理设备的输入数据。

​	然后来看相应的匹配链接相关的函数，具体内容如下所示：

~~~c
static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)
{
    const struct input_device_id *id;
    int error;

    // 通过输入设备和处理程序的匹配函数来确定是否适用于该设备
    id = input_match_device(handler, dev);
    if (!id)
        return -ENODEV;

    // 调用处理程序的连接函数来建立设备和处理程序之间的连接
    error = handler->connect(handler, dev, id);
    if (error && error != -ENODEV)
        pr_err("failed to attach handler %s to device %s, error: %d\n",
               handler->name, kobject_name(&dev->dev.kobj), error);
    // 如果连接失败且错误码不是-ENODEV，则打印错误消息

    return error;
}
~~~

​	第7行通过input_match_device函数，进行输入设备和处理程序的匹配，input_match_device函数内容如下所示：

~~~c
static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)
{
    const struct input_device_id *id;

    // 遍历处理程序的输入设备ID表，直到找到匹配的ID或遍历完所有ID为止
    for (id = handler->id_table; id->flags || id->driver_info; id++) {
        // 使用输入设备ID匹配函数判断给定的输入设备是否与当前ID匹配
        if (input_match_device_id(dev, id) &&
            (!handler->match || handler->match(handler, dev))) {
            // 如果输入设备与ID匹配，并且处理程序的匹配函数返回true（或者没有匹配函数），则返回该ID
            return id;
        }
    }

    return NULL;
}
~~~

​	在6-13行的for循环中首先会依次取出id_table的值，即上面讲解的joydev_ids结构体数组中的值，一一进行匹配，在for循环中由于每个joydev_ids结构体数组中都存在flags参数且值不为零，所以for循环的条件是成立的，在for循环中会调用input_match_device_id函数判定给定的输入设备是否与当前ID匹配，input_match_device_id函数内容如下所示

~~~c
bool input_match_device_id(const struct input_dev *dev,
                           const struct input_device_id *id)
{
    // 检查设备的总线类型是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
        if (id->bustype != dev->id.bustype)
            return false;

    // 检查设备的厂商ID是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)
        if (id->vendor != dev->id.vendor)
            return false;

    // 检查设备的产品ID是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)
        if (id->product != dev->id.product)
            return false;

    // 检查设备的版本号是否匹配
    if (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)
        if (id->version != dev->id.version)
            return false;

    // 检查设备的事件位图是否是给定ID的子集
    if (!bitmap_subset(id->evbit, dev->evbit, EV_MAX) ||
        !bitmap_subset(id->keybit, dev->keybit, KEY_MAX) ||
        !bitmap_subset(id->relbit, dev->relbit, REL_MAX) ||
        !bitmap_subset(id->absbit, dev->absbit, ABS_MAX) ||
        !bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX) ||
        !bitmap_subset(id->ledbit, dev->ledbit, LED_MAX) ||
        !bitmap_subset(id->sndbit, dev->sndbit, SND_MAX) ||
        !bitmap_subset(id->ffbit, dev->ffbit, FF_MAX) ||
        !bitmap_subset(id->swbit, dev->swbit, SW_MAX) ||
        !bitmap_subset(id->propbit, dev->propbit, INPUT_PROP_MAX)) {
        return false;
    }

    // 所有匹配条件都满足，返回true
    return true;
}
~~~

​	在5、10、15、20行的if判断中，由于flags的值和后面的宏都不为零，所以if判断都是成立的，但是第6、11、16、21四行中，dev->id在我们编写的最简单设备驱动层代码中并没有赋值，所以值为零，而在joydev.c中id->bustype、id->vendor、id->product和id->version同样没有赋值，所以值同样为0，所以第二层if判断不成立。

​	然后来看25-36行的if判断，bitmap_subset在上面讲解过，它是一个内联函数，用于判断两个位图是否具有子集关系，这时就需要用到上面讲解的joydev_ids结构体数组的描述特征了。在编写的最简单的设备驱动层代码中的设置如下所示：

~~~c
    __set_bit(EV_KEY, myinput_dev->evbit);    // 设置支持按键事件
    __set_bit(KEY_1, myinput_dev->keybit);    // 设置支持按键1
~~~

​	结合joydev_ids结构体数组的描述特征来对比，在上述的if判断中并不能与之匹配，所以最终会返回false，导致匹配失败。

​	讲解joydev.c的目的是让了解匹配规则是有多种多样的，对设备驱动层和事件处理层的知识重新进行梳理，在下次遇到相似的情况时可以自行分析。

## 7.2 扩展：多对多匹配关系

### 7.2.1 内核源码修改

​	首先对内核源码进行修改，修改涉及到两个函数分别是input_match_device_id函数和input_match_device函数，修改完成的代码内容如下所示：

~~~c
bool input_match_device_id(const struct input_dev *dev,
			   const struct input_device_id *id)
{
	if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
		if (id->bustype != dev->id.bustype)
			return false;

	if (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)
		if (id->vendor != dev->id.vendor)
			return false;

	if (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)
		if (id->product != dev->id.product)
			return false;

	if (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)
		if (id->version != dev->id.version)
			return false;

	if (!bitmap_subset(id->evbit, dev->evbit, EV_MAX) ||
	    !bitmap_subset(id->keybit, dev->keybit, KEY_MAX) ||
	    !bitmap_subset(id->relbit, dev->relbit, REL_MAX) ||
	    !bitmap_subset(id->absbit, dev->absbit, ABS_MAX) ||
	    !bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX) ||
	    !bitmap_subset(id->ledbit, dev->ledbit, LED_MAX) ||
	    !bitmap_subset(id->sndbit, dev->sndbit, SND_MAX) ||
	    !bitmap_subset(id->ffbit, dev->ffbit, FF_MAX) ||
	    !bitmap_subset(id->swbit, dev->swbit, SW_MAX) ||
	    !bitmap_subset(id->propbit, dev->propbit, INPUT_PROP_MAX)) {
			printk("input dev is error %s\n", dev->name);
			return false;
	}
	printk("input dev is ok %s\n", dev->name);
	return true;
}
EXPORT_SYMBOL(input_match_device_id);

static const struct input_device_id *input_match_device(struct input_handler *handler,
							struct input_dev *dev)
{
	const struct input_device_id *id;
	printk("handler name is %s\n", handler->name);
	for (id = handler->id_table; id->flags || id->driver_info; id++) {
		if (input_match_device_id(dev, id) &&
		    (!handler->match || handler->match(handler, dev))) {
			return id;
		}
	}

	return NULL;
}
~~~

​	相较于原函数只是在第30、33和42三行添加了printk打印，目的是在匹配过程中通过打印更好的了解匹配流程，由于修改的是内核源码，所以需要在修改之后重新编译内核源码，并将编译完成后生成的boot.img内核镜像烧写到开发板上。

注：joydev事件处理层代码在内核中默认是没有勾选的，需要根据输入子系统的裁剪和配置相关章节对内核的默认配置文件进行修改，勾选"Joystick interface"选项即可，勾选完成如下所示：

![image-20240218132755339](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181333673.png)

修改编译完成的boot.img内核镜像的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\92_myinput_dev_02\01_img路径下，如下图所示：
![image-20240218135114935](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181351968.png)

### 7.2.2 运行测试

本节测试仍旧使用前面编写的最简单的设备驱动层的ko文件，需要注意的是要想得到跟实验效果相同的结论，必须已经按照上一小节的操作修改过了内核源码，并重新烧写到了开发板上。

开发板上电正常启动之后如下所示：

![image-20240218135326024](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181353078.png)

由于myinput_dev.ko在之前已经拷贝到了开发板上，所以这里可以直接使用下面的命令加载myinput_dev.ko文件，打印内容如下所示：

~~~
insmod  myinput_dev.ko
~~~

![image-20240218135000769](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181350913.png)

其中红色框中的是joydev相关的打印，可以看到joydev是匹配失败的，证明在第一小节中我们的推理是正确的，而红色框下方的蓝色框中的是evdev通用设备驱动层程序，根据打印可以看到evdev匹配成功了，这时候细心的小伙伴可能发现了，除了evdev之外还有kbd、cpufreq_interactive和dmcfreq也匹配成功了，这是为什么呢？

### 7.2.3 结论

在输入子系统中，输入设备和输入处理器之间的关系是多对多的。这意味着一个输入设备可以与多个输入处理器关联，而一个输入处理器也可以处理多个输入设备的事件。

这种多对多的关系设计是为了提供更大的灵活性和可扩展性。不同的输入设备可能具有不同的特性和事件类型，而不同的输入处理器可能针对特定的事件类型提供不同的处理逻辑。通过将输入设备和输入处理器解耦并建立多对多的关系，可以使输入子系统更加灵活，可以根据需求将特定的输入设备与适合的输入处理器进行匹配，以实现定制化的事件处理。例如，对于鼠标输入设备，它可以产生鼠标移动事件、鼠标点击事件和滚轮滚动事件等，对于键盘输入设备，它可以产生按键事件，包括按下和释放按键的事件。

所以在上个小节中最简单的设备驱动层代码会跟内核中全部的事件处理层想匹配，最终匹配成功了evdev、kbd、cpufreq_interactive和dmcfreq四个事件处理层程序。



# 8 继续完善设备驱动层代码

在编写最简单的设备驱动层代码中，为了便于理解只填充了以下四个步骤：1.创建输入设备结构体变量、2.初始化输入设备结构体变量、3.注册输入设备结构体变量、5.注销和释放输入设备结构体变量，而在本章节将会对设备驱动层代码要填充的第四个步骤上报事件进行讲解和实验。

## 8.1 上报事件

​	上报事件是指在设备驱动层中，当输入设备产生事件时，将该事件通知给输入子系统。在上报事件之前，首先要确定要上报的事件类型。事件类型可以是按键事件、相对位置事件、绝对位置事件等，取决于输入设备的特性和能力。在Linux内核中，事件类型由预定义的常量表示，如EV_KEY表示按键事件，EV_REL表示相对位置事件，EV_ABS表示绝对位置事件等。在前面编写的最简单的设备驱动层代码的第二个步骤中已经对事件类型和具体事件进行了确认。
​	而在确定事件类型之后，就需要使用相应的上报函数将事件数据传递给输入子系统。常用的上报函数包括：

- input_report_key()：上报按键事件，用于通知按键的按下和释放状态。
- input_report_rel()：上报相对位置事件，用于通知设备的相对移动量，如鼠标的移动。
- input_report_abs()：上报绝对位置事件，用于通知设备的绝对位置，如触摸屏的坐标。

![image-20240218143022867](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181430934.png)

## 8.2 上报函数

​		当在设备驱动层中使用上报函数时，这些函数负责将事件数据传递给输入子系统，以便将事件信息传递给应用程序或系统组件进行响应和处理。下面逐个详细讲解每个上报函数的作用和参数：

1. input_report_key(struct input_dev *dev, unsigned int code, int value)：
   - 功能：上报按键事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。
     - code：按键码，表示按下或释放的具体按键。
     - value：按键状态，0 表示按键释放，非零值表示按键按下。
2. input_report_rel(struct input_dev *dev, unsigned int code, int value)：
   - 功能：上报相对位置事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。
     - code：位置码，表示相对位置的具体类型。
     - value：位置偏移量，表示设备相对于先前位置的移动量。
3. input_report_abs(struct input_dev *dev, unsigned int code, int value)：
   - 功能：上报绝对位置事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。
     - code：位置码，表示绝对位置的具体类型。
     - value：位置值，表示设备的绝对位置。
4. input_report_ff_status(struct input_dev *dev, unsigned int code, int value)：
   - 功能：上报力反馈状态事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。
     - code：力反馈码，表示力反馈的具体类型。
     - value：力反馈状态，0 表示停止，非零值表示运行中。
5. input_report_switch(struct input_dev *dev, unsigned int code, int value)：
   - 功能：上报开关事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。
     - code：开关码，表示开关的具体类型。
     - value：开关状态，0 表示关闭，非零值表示打开。
6. input_sync(struct input_dev *dev)：
   - 功能：同步事件。
   - 参数：
     - dev：输入设备结构体指针，表示要发送事件的输入设备。

​	每个上报函数都是内联函数，通过调用input_event()函数将事件数据添加到输入事件队列中。这些函数的参数中包含了事件类型（如EV_KEY、EV_REL等）、事件码（如按键码、位置码等）以及事件的具体值（如按键状态、位置偏移量等）。这些参数用于构造输入事件，并将其添加到输入事件队列中，以便后续的处理。

在使用上报函数之后，通常会调用input_sync()函数进行同步。同步事件的目的是告知输入子系统事件的结束，以便子系统可以将事件传递给相应的应用程序或系统组件进行处理。同步事件的调用可以防止事件数据的丢失或混乱。

## 8.3 驱动程序的编写

​		本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\92_myinput_dev_02\02_module。

​	由于RK3568开发板上的按键是ADC按键，并不是普通的按键，所以在本章节编写的驱动程序中并不通过按键的按下和弹起来进行事件的上报，而是采用定时器的方式对数据进行循环上报，当后面讲解到ADC相关的章节时会对本章内容进行回顾。

​	编写完成的myinput_dev.c代码如下所示:

~~~c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/input.h>
#include <linux/timer.h>

struct input_dev *myinput_dev; // 输入设备结构体指针

static void timer_function(struct timer_list *t);

DEFINE_TIMER(test_timer, timer_function); // 定义定时器

static void timer_function(struct timer_list *t) {
    static int value = 0; // 静态变量用于切换键值
    value = value ? 0 : 1;

    input_event(myinput_dev, EV_KEY, KEY_1, value); // 发送按键事件
    input_event(myinput_dev, EV_SYN, SYN_REPORT, 0); // 发送同步事件

    mod_timer(&test_timer, jiffies + msecs_to_jiffies(1000)); // 更新定时器
}

static int myinput_dev_init(void) {
    int ret;

    myinput_dev = input_allocate_device(); // 分配输入设备
    if (myinput_dev == NULL) {
        printk("input_allocate_device error\n");
        return -ENOMEM;
    }

    myinput_dev->name = "myinput_dev"; // 设置设备名
    set_bit(EV_KEY, myinput_dev->evbit); // 设置支持的事件类型：按键事件
    set_bit(EV_SYN, myinput_dev->evbit); // 设置支持的事件类型：同步事件
    set_bit(KEY_1, myinput_dev->keybit); // 设置支持的按键键值

    ret = input_register_device(myinput_dev); // 注册输入设备
    if (ret < 0) {
        printk("input_register_device error\n");
        goto error;
    }

    mod_timer(&test_timer, jiffies + msecs_to_jiffies(1000)); // 启动定时器

    return 0;

error:
    input_free_device(myinput_dev);
    return ret;
}

static void myinput_dev_exit(void) {
    del_timer(&test_timer); // 删除定时器
    input_unregister_device(myinput_dev); // 取消注册输入设备
    input_free_device(myinput_dev); // 释放输入设备内存
}

module_init(myinput_dev_init);
module_exit(myinput_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("topeet");
~~~

## 8.4 运行测试

### 8.4.1  编译驱动程序

在上一小节中的myinput_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：

~~~makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m += myinput_dev.o    #此处要和你的驱动源文件同名
KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            
PWD ?= $(shell pwd)
all:
        make -C $(KDIR) M=$(PWD) modules    #make操作
clean:
        make -C $(KDIR) M=$(PWD) clean    #make clean操作    
~~~

对于Makefile的内容注释已在上图添加，保存退出之后，来到存放myinput_dev.c和Makefile文件目录下，如下图所示：

![image-20240218144043878](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181440927.png)

然后使用命令“make”进行驱动的编译，编译完成如下图所示:

![image-20240218144101905](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181441966.png)

编译完生成myinput_dev.ko目标文件，如下图所示：

![image-20240218144126215](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181441267.png)

至此驱动模块就编译成功了。

### 8.4.2 运行测试

首先启动开发板，进入系统之后如下所示：
![image-20240218105912628](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181059675.png)

然后将上一小节编译完成的myinput_dev.ko驱动文件拷贝到开发板上，拷贝完成如下所示：
![image-20240218110447298](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181104348.png)

在加载驱动之前首先使用以下命令查看当前的输入设备，如下所示：

~~~
ls /dev/input
~~~

![image-20240218110719974](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181107008.png)

可以看到目前有4个输入设备的设备节点，然后使用以下命令进行驱动的加载，如下图所示：

~~~shell
insmod myinput_dev.ko
~~~

![image-20240218144241099](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181442193.png)

然后重新查看设备节点，可以看到多出来了一个event4节点，如下图所示：
![image-20240218111708043](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181117078.png)	然后使用以下命令查看设备节点的输出信息，如下图所示：

~~~
hexdump /dev/input/event4
~~~

![image-20240218144329862](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181443924.png)

可以看到，每隔一秒钟就会打印一次数据，至此，关于在最简单的设备驱动程序中完善上报事件的实验就完成了。

## 8.5 编写应用获取上报数据

在上一个小节的实验中，我们是通过hexdump命令从输入设备的设备节点获取的16进制数据，那要如何通过编写上层应用程序获取到上述相应的数据呢？

如果要读取某个输入设备的数据对应的流程如下所示：

| 步骤 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| 1    | 应用程序打开/dev/input/eventX设备文件，X为对应的输入设备编号。 |
| 2    | 应用程序使用read函数从设备文件中读取数据。如果设备上没有数据可读，则read函数会一直阻塞等待，直到数据可用。 |
| 3    | 读取的数据为一个input_event结构体，其包含事件类型、事件码和事件值三个字段，用于描述输入设备发生的事件信息。事件类型指示事件的分类，例如按键事件、鼠标事件、触摸屏事件等；事件码指示事件的具体类型，例如按下键盘上的某个键、移动鼠标等；事件值表示事件的取值，例如按键按下/释放、鼠标移动的距离、触摸屏触点的坐标等。 |
| 4    | 应用程序根据读取到的事件数据进行处理，例如根据事件类型和事件码判断是哪个键被按下、鼠标移动的距离等，并进行相应的操作。 |
| 5    | 在使用完输入设备后，使用close系统调用关闭输入设备文件。      |

每一步骤实现的具体代码，在之后的实验小节中会进行演示。

在第二步中，通过read函数进行读取输入设备数据的读取，每一次 read 操作获取的都是一个 struct input_event 结构体类型数据，struct input_event 是 Linux 内核中用于描述输入事件的结构体类型。它定义在 <linux/input.h> 头文件中，用于在内核和用户空间之间传递输入事件的信息。在用户空间中，应用程序通过读取输入设备文件获得 struct input_event 数据，并解析其中的事件类型、事件码和事件值等信息，以进行相应的处理。结构体struct input_event 定义如下： 

~~~c
struct input_event {
	struct timeval time;
	__u16 type;// 类型
	__u16 code;// 具体事件
	__s32 value;// 对应的取值
};
~~~

下面对struct input_event结构体的三个字段及其相应的宏进行详细的讲解：

**type：**type 用于描述发生了哪一种类型的事件（对事件的分类），Linux 系统所支持的输入事件类型如下所示： 

~~~c
#define EV_SYN          0x00	//同步类事件，用于同步事件
#define EV_KEY          0x01	//按键类事件
#define EV_REL          0x02	//相对位移类事件(譬如鼠标)
#define EV_ABS          0x03	//绝对位移类事件(譬如触摸屏)
#define EV_MSC          0x04	//其它杂类事件
#define EV_SW           0x05
#define EV_LED          0x11
#define EV_SND          0x12
#define EV_REP          0x14
#define EV_FF           0x15
#define EV_PWR          0x16
#define EV_FF_STATUS        0x17
#define EV_MAX          0x1f
#define EV_CNT          (EV_MAX+1)
~~~

以上这些宏定义同样在<linux/input.h>头文件中，所以在应用程序中需要包含该头文件；一种输入设备 通常可以产生多种不同类型的事件，譬如点击鼠标按键（左键、右键，或鼠标上的其它按键）时会上报按键类事件，移动鼠标时则会上报相对位移类事件。 

**code：**code 表示该类事件中的哪一个具体事件，以上列举的每一种事件类型中都包含了一系列具体事件，譬如一个键盘上通常有很多按键，而 code变量则告知应用程序是哪一个按键发生了输入事件。每一种事件类型都包含多种不同的事件，以按键类事件为例，对应的具体事件如下所示：

~~~c
#define KEY_RESERVED        0
#define KEY_ESC         1	//ESC 键
#define KEY_1           2	//数字 1 键
#define KEY_2           3	//数字 2 键
#define KEY_3           4	//数字 3 键
#define KEY_4           5	//数字 4 键
#define KEY_5           6	//数字 5 键
#define KEY_6           7	//数字 6 键
#define KEY_7           8	//数字 7 键
#define KEY_8           9	//数字 8 键
#define KEY_9           10	//数字 9 键
#define KEY_0           11	//数字 0 键
#define KEY_MINUS       12	//减号键
#define KEY_EQUAL       13	//加号键
#define KEY_BACKSPACE       14	//回退键
    ................................
~~~

 对于其他输入事件的code值，可以查看input-event-codes.h 头文件（该头文件被<linux/input.h>所包含）。

value：内核每次上报事件都会向应用层发送一个数据 value，对 value 值的解释随着 code 的变化而变化。譬如对于按键事件来说，如果 value 等于 1，则表示按键按下；value 等于 0 表示按键松开，如果 value 等于 2则表示按键长按。而在绝对位移事件中（type=3），如果 code=0（触摸点 X 坐标 ABS_X），那么 value 值就等于触摸点的 X 轴坐标值；如果 code=1（触摸点 Y 坐标 ABS_Y），此时value 值便等于触摸点的 Y 轴坐标值。

接下来根据上面讲解的内容编写最简单的获取上报数据的应用程序，编写完成的应用程序存放路径为iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\93_input_03，编写完成的应用程序代码如下所示：

~~~c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h>

int main() {
    int fd;  // 文件描述符
    int ret;  // 返回值
    struct input_event event;  // 输入事件结构体

    fd = open("/dev/input/event4", O_RDWR);  // 打开输入设备文件
    if (fd < 0) {
        printf("打开错误\n");
        return -1;
    }

    while (1) {
        ret = read(fd, &event, sizeof(struct input_event));  // 读取输入事件
        if (ret < 0) {
            printf("读取错误\n");
            return -2;
        }

        if (event.type == EV_KEY) {  // 判断事件类型为键盘事件
            if (event.code == KEY_1) {  // 判断键码为1
                if (event.value == 1)
                    printf("值为1\n");
                else if (event.value == 0)
                    printf("值为0\n");
            }
        }
    }

    return 0;
}
~~~

这个应用程序的主要功能是打开名为"/dev/input/event4"的输入设备文件，并读取输入事件。在读取事件后，它会检查事件的类型和代码，如果类型为EV_KEY且键值为KEY_1，则根据值的不同输出不同的消息。

## 8.6 应用程序测试

首先进行应用程序的编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图所示：

~~~shell
aarch64-linux-gnu-gcc app.c -o app
~~~

![image-20240218151659914](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181516964.png)

然后将编译完成的可执行程序拷贝到开发板上，拷贝完成如下所示：
![image-20240218151809070](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181518149.png)

然后输入"./app"命令运行该应用程序，运行结果如下所示：
![image-20240218151858644](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402181518708.png)

可以看到0和1的值每个一秒钟被交替打印，至此关于应用程序的测试就完成了，但对于通过hexdump命令获取得到的一系列16进制数据所表示的含义此时还并不清楚，会在下个章节中对得到的16进制数进行分析。 













