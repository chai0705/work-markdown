shell脚本编程视频 总共25集

|                                    |       |
| :--------------------------------- | :---- |
| 文本                               | 时间  |
| _01_为什么需要学shell编程          | 04:39 |
| _02_使用Linux背后的shell概念       | 09:48 |
| _03_Shebang的正确玩法              | 16:45 |
| _04_浅谈运维和编程语言             | 14:19 |
| _05_Bash特性                       | 8:30  |
| _06_Shell变量详解                  | 19:18 |
| _07_父子shell的面试题              | 12:11 |
| _08_通过set寻找父子shell的变量加载 | 20:13 |
| _09_趣谈Shell特殊参数变量          | 16:25 |
| _10_趣谈Shell特殊状态变量          | 12:44 |
| _11_几个简单内置shell命令          | 10:06 |
| _12_变量子串的语法介绍             | 08:19 |
| _13_子串玩法一                     | 06:50 |
| _14_统计变量子串的长度             | 05:35 |
| _15_统计命令执行的时长             | 05:35 |
| _16_详解字符串截取                 | 14:43 |
| _17_案例：批量修改文件名           | 12:02 |
| _18_提升：shell扩展变量            | 13:14 |
| _19_提升：实践shell扩展变量        | 05:56 |
| _20_详解：为什么需要父子shell      | 18:44 |
| _21_Shell内置、外置命令            |       |

256.72 分钟，大约是4个小时的时间就也还行把。

环境配置：https://blog.csdn.net/jangboyang222/article/details/130179148?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%20%E6%90%AD%E5%BB%BAshell%E7%8E%AF%E5%A2%83&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130179148.142^v99^pc_search_result_base9&spm=1018.2226.3001.4187

https://blog.csdn.net/u014012924/article/details/109923859?ops_request_misc=&request_id=&biz_id=102&utm_term=vscode%20%E6%90%AD%E5%BB%BAshell%E7%8E%AF%E5%A2%83&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-109923859.142^v99^pc_search_result_base9&spm=1018.2226.3001.4187

https://blog.csdn.net/lanwp5302/article/details/107948505?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171098877216800185896352%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171098877216800185896352&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107948505-null-null.142^v99^pc_search_result_base9&utm_term=vscode%20%E6%90%AD%E5%BB%BAshell%E7%8E%AF%E5%A2%83&spm=1018.2226.3001.4187



# 1.shell的概念

Shell是一种命令行解释器，它允许用户与操作系统进行交互，并执行各种命令、程序和脚本。它是用户与操作系统之间的接口。

Shell的主要作用包括：

1. 解释执行命令：当用户在命令行输入一条命令时，Shell会解释该命令并执行相应的操作。它将命令解析为可被操作系统理解和执行的指令。
2. 管理文件和目录：Shell提供了一系列用于管理文件和目录的命令，例如创建、复制、移动、删除文件和目录，改变文件的权限和所有权等。
3. 启动和管理进程：Shell可以启动和管理系统中的进程。用户可以使用Shell命令来启动应用程序、服务或脚本，并对其进行监控和控制。
4. 编写和执行脚本：Shell提供了编写脚本的功能，用户可以使用Shell脚本语言编写一系列命令和逻辑，以实现自动化任务、批处理操作和系统管理等。
5. 环境配置和自定义：Shell允许用户配置和自定义命令行环境。用户可以定义别名、环境变量、函数和脚本，以满足个人需求，并提高工作效率。

在Linux系统中，用户可以通过键盘输入命令，Shell会解释这些命令并执行相应的操作，并将结果输出到终端，这被称为交互式Shell。此外，Shell还支持脚本文件的批处理执行，用户可以将一系列命令写入脚本文件，并通过Shell解释器来执行整个脚本，无需逐行输入命令。

___

Shell解释器是一个强大的工具，它使我们能够方便地使用Linux系统并执行各种操作，无论是通过图形界面还是命令行界面。

通过Shell解释器，我们可以输入命令或脚本，然后Shell会解析和执行这些命令，并将结果输出到终端。这使得我们可以以交互的方式与计算机进行沟通，并获取我们需要的数据或执行特定的操作。

使用Shell解释器的好处包括：

1. 快速获取数据：通过输入Shell命令，我们可以快速获取计算机的数据，而无需编写和编译复杂的程序。
2. 自动化任务：使用Shell脚本，我们可以编写一系列命令和逻辑，以实现自动化任务。这可以帮助我们简化重复的操作，提高工作效率。
3. 灵活性和可定制性：Shell解释器提供了丰富的命令和功能，同时也支持用户自定义别名、环境变量和函数等。这使得我们可以根据个人需求来配置和定制命令行环境。
4. 批处理操作：通过编写Shell脚本，我们可以批量执行一系列操作，例如批量处理文件、批量安装软件等。

无论我们使用图形界面还是命令行界面，Shell解释器都可以接收我们的输入，并根据输入执行相应的操作。对于图形界面，Shell解释器可以接收我们的点击动作，并将其转换为相应的命令或操作进行执行。无论是使用图形界面还是命令行界面，Shell解释器都可以输出结果到终端，以便我们查看和分析。

总之，Shell解释器是Linux系统中强大而灵活的工具，它使我们能够方便地与计算机交互，并执行各种操作，从简单的命令到复杂的脚本。

# 2.什么是shell脚本？

Shell脚本是一种文本文件，其中包含一系列的Shell命令、程序语句、循环控制语句等。它允许我们将一组命令和逻辑组织在一个文件中，以便一次性执行这些命令。

通过编写Shell脚本，我们可以将多个Linux命令和操作组合在一起，形成一个可执行的脚本文件。脚本文件可以包含条件语句、循环语句、函数等，以实现更复杂的逻辑和自动化任务。

当我们执行Shell脚本时，Shell解释器会读取脚本文件中的命令和语句，并按照顺序执行它们。这种执行方式称为非交互式方式，因为不需要手动逐行输入命令，而是直接执行整个脚本文件。

在Linux系统中，通常使用以`.sh`为扩展名的文件来表示Shell脚本，这是一种常见的约定。类似地，在Windows系统中，使用以`.bat`为扩展名的批处理脚本文件来实现类似的功能。

通过编写和执行Shell脚本，我们可以批量处理任务、自动化操作、系统管理等，从而提高工作效率和简化重复操作的过程。

___

Shebang是指在文本文件的第一行前两个字符`#!`。在Unix系统中，当执行这个文本文件时，系统会根据Shebang后面的内容来确定使用哪个解释器执行该文件。

例如，以`#!/bin/sh`开头的文件会调用`/bin/sh`作为解释器，即使用Bash解释器执行文件。以`#!/usr/bin/python`开头的文件表示要使用Python解释器执行。而以`#!/usr/bin/env 解释器名称`开头的文件是一种在不同平台上都能正确找到解释器的方法。

需要注意的是：

- 如果脚本没有指定Shebang，系统会默认使用当前Shell来解释脚本，即`$SHELL`环境变量所指定的Shell。
- 如果Shebang指定了可执行的解释器（如`/bin/bash`、`/usr/bin/python`），在执行脚本时，文件名会作为参数传递给解释器。
- 如果指定的解释程序没有可执行权限，将会报错"bad interpreter: Permission denied"。
- 如果指定的解释程序不是一个可执行文件，系统会忽略指定的解释程序，转而使用当前的Shell来执行脚本。
- 如果指定的解释程序不存在，将会报错"bad interpreter: No such file or directory"。
- Shebang后面的解释程序需要写绝对路径，它不会自动在系统的`$PATH`路径中寻找解释器。
- 如果你使用`bash test.sh`这样的命令执行脚本，Shebang这一行会被忽略，解释器会使用命令行显式指定的Bash来执行脚本。





# 3.执行Shell脚本的方式

1. 使用bash或sh命令执行：如果脚本文件具有可执行权限（通常使用`chmod +x script.sh`命令添加可执行权限），可以使用bash或sh命令来执行脚本。例如：

   ```
   bash script.sh
   ```

   或者

   ```
   sh script.sh
   ```

2. 使用Shebang指定的解释器执行：如果脚本文件的第一行包含Shebang指令，并且指定了正确的解释器路径，可以直接执行脚本文件。例如，如果脚本的第一行是`#!/bin/bash`，可以直接执行：

   ```
   ./script.sh
   ```

3. 使用source或点命令执行：如果想要在当前Shell环境中执行脚本，并让脚本中的变量和函数在当前Shell中生效，可以使用source或点命令。例如：

   ```
   source script.sh
   ```

   或者

   ```
   . script.sh
   ```

4. 使用sh < script.sh语法：这是一种相对较少见的用法，可以使用sh命令将脚本文件重定向为标准输入来执行。例如：

   ```
   sh < script.sh
   ```

需要注意的是，执行脚本文件时需要确保脚本文件具有可执行权限（使用`chmod +x script.sh`命令添加权限），或者使用合适的执行方式（如使用解释器执行或source命令）。如果脚本文件没有可执行权限，尝试直接执行脚本可能会报错。

___

Shell作为一种脚本编程语言，在Linux系统中具有以下优势：

1. 原生支持：Shell是Linux系统内置的命令解释器，几乎所有的Linux底层命令都支持Shell语句。这使得Shell成为与操作系统紧密集成的工具，能够直接操作和管理系统资源。
2. 简单易学：Shell语法相对简单，易于学习和上手。它使用直观的命令和管道操作，使得编写和调试脚本变得简单直接。对于系统管理员和运维人员来说，这是一个重要的优势。
3. 系统管理脚本开发：Shell脚本在系统管理方面非常强大。它可以用于编写各种系统管理脚本，例如软件的启停脚本、定时任务脚本、监控和报警脚本、日志分析脚本等。Shell脚本可以自动化执行各种管理任务，提高工作效率。
4. 与核心工具的结合：Shell脚本可以与Linux系统的核心工具（如grep、sed、awk等）无缝结合，形成强大的组合。这些工具提供了丰富的文本处理和数据转换功能，使得Shell脚本能够处理和分析大量的数据和日志文件。
5. 扩展性和定制性：Shell脚本具有良好的扩展性和定制性。通过编写函数、条件语句、循环控制等结构，可以构建复杂的逻辑和处理流程。此外，Shell还支持命令行参数、环境变量等机制，可以根据具体需求进行定制。

# 4.bash基础特性

Bash（Bourne Again SHell）是一个命令处理器，通常用于运行在文本窗口中，并且可以执行用户直接输入的命令。除此之外，bash还支持从文件中读取Linux命令，这就是所谓的脚本。通过编写bash脚本，可以将一系列的命令组合在一起，实现自动化和批量处理。

Bash提供了丰富的功能，使得运维人员能够更高效地进行工作。以下是一些bash的方便功能：

1. 通配符（Wildcard）：Bash支持通配符，如`*`（匹配任意字符）、`?`（匹配单个字符）和`[]`（匹配指定范围的字符）。这使得在命令中处理多个文件或目录变得更加灵活和便捷。
2. 管道（Pipeline）：Bash支持管道操作符`|`，可以将多个命令连接起来，使得前一个命令的输出作为后一个命令的输入。这种方式可以实现数据流的传递和处理，提高了命令的灵活性和组合性。
3. 命令替换（Command Substitution）：Bash支持命令替换，使用反引号（`）或`$()`将命令包裹起来，将命令的输出结果作为变量的取值。这样可以方便地将命令的输出结果嵌入到其他命令中使用。
4. 条件判断（Conditional Statements）：Bash提供了条件判断语句，如if-then、if-then-else和case语句，可以根据条件的满足与否执行不同的命令或逻辑。这使得在脚本中可以实现复杂的条件判断和分支逻辑。

另外，bash还提供了循环控制语句（如for、while、until），可以实现对命令或操作的重复执行。还有各种内置变量和函数，以及丰富的字符串处理功能和算术运算符，都有助于运维人员提升工作效率和编写强大的脚本工具。 

# 5.反引号

在Shell中，反引号（``）用于进行命令替换，也称为命令替换语法。它允许将命令的输出结果嵌入到其他命令或变量中。

基本语法如下：

```
variable=`command`
```

或者使用更推荐的$()语法：

```
variable=$(command)
```

其中，`command`是要执行的命令，可以是任意合法的Shell命令。

命令替换的作用是将`command`命令的输出结果赋值给变量`variable`。这样，在后续的命令或操作中，可以使用`$variable`来引用这个命令的输出结果。

示例：

```
current_date=`date`
echo "Today is $current_date"
```

这个示例中，通过命令替换将`date`命令的输出结果赋值给`current_date`变量，然后在`echo`命令中使用`$current_date`引用该变量，输出当前的日期。

命令替换也可以嵌套使用，即在一个命令替换中执行另一个命令替换。例如：

```
result=$(echo $(ls))
```

这个示例中，内部的命令替换`$(ls)`将当前目录下的文件列表作为输出结果，然后通过外部的命令替换`$(echo ...)`将该输出结果赋值给`result`变量。

需要注意的是，在使用反引号或$()进行命令替换时，应确保命令的输出结果不包含换行符或其他特殊字符，以免引起意外的结果。在处理包含特殊字符的输出时，可以使用引号将命令替换部分括起来，例如：

```
result="$(command)"
```

这样可以保留输出结果的完整性。

总的来说，反引号或$()命令替换语法在Shell中是非常有用的功能，可以方便地将命令的输出结果嵌入到其他命令或变量中，实现灵活的数据处理和操作。

# 6.环境变量

环境变量在Shell中起着重要的作用，它们用于定义Shell的运行环境，为命令提供必要的配置和信息。环境变量可以通过export命令进行导出，以便在Shell会话中被其他命令和程序访问和使用。

环境变量在Shell中的作用包括但不限于以下几个方面：

1. 确定登录用户和用户环境：Shell使用环境变量来确定当前登录的用户名、用户的主目录、用户的shell类型等信息。例如，`$USER`环境变量存储当前登录用户的用户名，`$HOME`环境变量存储当前用户的主目录路径。
2. PATH路径设置：环境变量中最重要的一个是`$PATH`，它是一个包含多个目录路径的变量，用于指定Shell在执行命令时搜索可执行文件的路径列表。当输入一个命令时，Shell会按照`$PATH`中指定的路径顺序去搜索该命令的可执行文件。通过修改`$PATH`环境变量，可以添加或删除Shell搜索命令的路径，以满足个人或系统的需求。
3. 系统和应用配置：许多系统和应用程序使用环境变量来确定其配置和行为。例如，`$LANG`环境变量用于指定系统的默认语言设置，`$EDITOR`环境变量用于指定默认的文本编辑器，`$JAVA_HOME`环境变量用于指定Java的安装路径等。通过设置这些环境变量，可以调整系统和应用程序的行为和配置。

在Shell中，环境变量可以在命令行中临时创建，但是当用户退出Shell终端后，这些临时的环境变量将会丢失。如果需要让环境变量永久生效，需要修改Shell的配置文件。

在大多数Linux和Unix系统中，用户的个人配置文件为`~/.bash_profile`或`~/.bashrc`。这些文件用于定义用户登录时的环境变量和个人配置。用户可以在这些文件中添加或修改环境变量的定义，以便每次登录时都能生效。

对于远程登录用户而言，也存在特有的配置文件。例如，对于Bash Shell，远程登录用户的特有配置文件为`~/.bash_profile`或`~/.bashrc`，但是文件名前面会加上登录用户的用户名，例如`~/.bash_profile`变为`~/.bash_profile_user1`。

此外，还有全局的配置文件，用于设置系统范围内的环境变量。常见的全局配置文件包括`/etc/profile`和`/etc/bashrc`。这些文件中的环境变量定义将影响到所有登录系统的用户。

通常，建议将自定义的环境变量配置放在`/etc/profile.d/`目录下的一个新文件中，而不是直接修改全局配置文件。这样可以更好地管理和维护环境变量的定义，而不会干扰系统的其他配置。

总结来说，环境变量在Shell中用于定义运行环境、保证命令的正确执行，并且在Shell会话中起到重要的作用。通过合理设置环境变量，可以调整Shell的行为、配置系统和应用程序，并提供更加便利和定制化的Shell环境。

___

在Linux系统中，当用户通过SSH登录后，系统会启动一个Bash Shell，并按照一定的顺序加载环境变量文件。这些环境变量文件的加载顺序如下：

1. `/etc/profile`：这是系统的全局环境变量文件。它为系统的每个用户设置环境信息。当用户第一次登录时，该文件会被执行。
2. `/etc/profile.d/*.sh`：在`/etc/profile`文件中，会加载`/etc/profile.d/`目录下的所有以`.sh`为扩展名的脚本文件。这些脚本文件可以包含系统级别的环境变量定义和配置。
3. `$HOME/.bash_profile`、`$HOME/.bash_login`、`$HOME/.profile`：这些是用户的个人环境变量文件，根据存在的顺序依次加载。当用户登录时，Bash Shell会查找这些文件，并执行找到的第一个存在的文件。
4. `$HOME/.bashrc`：这是用户的个人Bash Shell配置文件。它包含用户自定义的环境变量定义、别名、函数等。该文件在每个新的交互式Shell会话时都会被加载。
5. `/etc/bashrc`：这是系统级别的Bash Shell配置文件。它包含系统范围内的Bash Shell配置，例如全局别名、函数等。该文件在每个新的交互式Shell会话时都会被加载。

需要注意的是，`/etc/profile`和`/etc/profile.d/*.sh`文件只在用户登录时执行一次，而`$HOME/.bashrc`和`/etc/bashrc`文件在每个新的交互式Shell会话时都会被加载。这样可以确保用户在每个Shell会话中都能获得正确的环境变量和配置。

通过配置这些环境变量文件，用户可以在登录后立即运行特定的脚本，设置自定义的环境变量，以及对Shell的行为进行定制化。

总结来说，SSH登录Linux后，Bash Shell会按照`/etc/profile`、`/etc/profile.d/*.sh`、`$HOME/.bash_profile`（或`$HOME/.bash_login`或`$HOME/.profile`）、`$HOME/.bashrc`和`/etc/bashrc`的顺序加载环境变量文件，以确保正确的环境配置和用户定制化的Shell行为。

# 7.特殊参数变量



在Shell中，有一些特殊的参数变量用于存储和访问与Shell脚本执行相关的特定信息。这些特殊参数变量提供了对脚本自身、命令行参数、环境以及Shell的一些属性的访问。下面是一些常用的特殊参数变量及其含义：

1. `$0`：表示当前脚本的名称。当Shell脚本被执行时，`$0`会被设置为脚本文件的路径和名称。
2. `$1`、`$2`、`$3`...：表示命令行参数。当在命令行执行Shell脚本时，这些变量用于访问传递给脚本的参数。`$1`代表第一个参数，`$2`代表第二个参数，以此类推。
3. `$*`：表示所有命令行参数的列表。当使用`$*`时，它会将所有的命令行参数作为一个单词字符串返回。
4. `$@`：表示所有命令行参数的列表。当使用`$@`时，它会将所有的命令行参数作为多个独立的字符串返回。
5. `$#`：表示命令行参数的数量。当使用`$#`时，它会返回传递给脚本的命令行参数的数量。

这些特殊参数变量可以在Shell脚本中使用，以便访问和处理与脚本执行相关的信息。通过使用这些变量，可以获取脚本的名称、处理命令行参数、检查命令的退出状态、获取进程信息等，从而实现更灵活和可定制的脚本逻辑。

# 8.特殊状态变量

在Shell脚本中，除了特殊参数变量之外，还有一些特殊状态变量用于控制和跟踪脚本的执行状态。这些特殊状态变量提供了对脚本执行过程中的状态信息的访问和控制。下面是一些常用的特殊状态变量及其含义：

1. `$?`：表示上一个命令的退出状态。当Shell执行一个命令后，`$?`会被设置为该命令的退出状态码。通常，0表示命令执行成功，非零值表示命令执行失败或出现错误。通过检查`$?`的值，可以根据命令执行的结果进行条件判断和错误处理。
2. `$!`：表示后台运行的最后一个进程的ID。当在Shell脚本中启动一个后台进程时，可以使用`$!`来获取该进程的ID。这对于需要跟踪和操作后台进程的脚本非常有用。
3. `$$`：表示当前Shell进程的ID。当使用`$$`时，它会返回当前Shell脚本的进程ID。通常，可以将`$$`用于生成唯一的临时文件名或标识符，以避免与其他进程的操作冲突。
4. `$PIPESTATUS`：表示管道命令中每个命令的退出状态。当Shell脚本中使用了管道命令（`|`）时，`$PIPESTATUS`会保存每个命令的退出状态码。它是一个数组，可以通过索引访问每个命令的状态码。例如，`${PIPESTATUS[0]}`表示第一个命令的退出状态码。
5. `$LINENO`：表示当前代码行的行号。当使用`$LINENO`时，它会返回当前执行的代码行的行号。这对于调试和错误追踪非常有用，可以在脚本中输出或记录行号，以定位问题所在。
6. `$OPTARG`：表示当前选项的参数值。当在Shell脚本中使用`getopts`命令解析命令行选项时，`$OPTARG`会保存当前选项的参数值。`$OPTARG`通常与`$OPTIND`一起使用，来获取和处理命令行选项的参数。
7. `$OPTIND`：表示下一个要处理的选项在命令行参数列表中的索引。当在Shell脚本中使用`getopts`命令解析命令行选项时，`$OPTIND`用于跟踪下一个要处理的选项的位置。可以使用`shift`命令结合`$OPTIND`来移除已处理的选项和参数，以便继续解析剩余的选项。

# 9.read命令

`read`命令是Shell中用于从标准输入读取用户输入的命令。它可以读取用户输入的文本，并将其保存到一个或多个变量中供后续处理使用。以下是`read`命令的详细说明：

语法：

```bash
read [options] [variable...]
```

参数和选项：

- `variable`：一个或多个变量名，用于保存读取到的输入值。输入值将被存储在这些变量中。如果未指定变量名，`read`命令将会将输入值存储到特殊变量`REPLY`中。
- `-r`：禁用对反斜杠的转义处理。通常情况下，`read`命令会将输入中的反斜杠进行转义处理，使用`-r`选项可以禁止这种转义处理。
- `-a array`：将输入值分割成数组元素，并将数组赋值给变量`array`。
- `-d delimiter`：指定输入值的分隔符。`read`命令将根据指定的分隔符将输入值拆分成多个字段，并将每个字段存储到不同的变量中。
- `-e`：启用行编辑模式。在行编辑模式下，用户可以使用编辑键（如方向键、删除键等）编辑输入的文本。
- `-i text`：使用给定的默认文本初始化输入。如果用户直接按下回车键而不输入任何内容，则默认文本将作为输入值。
- `-n count`：限制读取的字符数为`count`个字符。一旦读取的字符数达到指定的数量，`read`命令将立即返回。

使用示例：

```bash
read -p "请输入您的名字：" name
echo "您的名字是：$name"

read -s -p "请输入密码：" password
echo "您输入的密码是：$password"

read -a numbers
echo "您输入的数字是：${numbers[@]}"

read -d ":" -p "请输入姓名和年龄（用冒号分隔）：" name age
echo "您的姓名是：$name，年龄是：$age"
```

在这个示例中，`read`命令用于从用户处读取输入，并将输入值存储到变量中。使用`-p`选项可以在读取之前显示提示信息，`-s`选项可以隐藏用户输入的内容（例如密码输入），`-a`选项可以将输入的值分割成数组，`-d`选项可以指定分隔符用于拆分输入值。使用`-i`选项可以提供默认值，`-n`选项可以限制读取的字符数。

`read`命令在脚本中广泛使用，用于与用户进行交互，接受输入并进行后续处理。它提供了一种简单而灵活的方式来处理用户输入，并将输入值用于脚本的逻辑和操作中。

#  10.test内置命令

在Shell中，`test`命令用于进行条件测试和比较操作。它可以检查文件的属性和状态，比较字符串和数值，以及执行各种条件判断。`test`命令也可以使用方括号`[ ]`来表示，因为`test`实际上是一个可执行文件的名称，而方括号是`test`命令的一种等效形式。下面是`test`命令的详细说明：

语法： 

```
test expression
```

```
[ expression ]
```

`expression`是一个条件表达式，用于进行条件测试和比较操作。`test`命令会根据表达式的结果返回一个退出状态码，如果表达式为真，则返回0，否则返回非零值。这使得`test`命令非常适合用于条件语句（如`if`语句）中的条件判断。以下是`test`命令支持的一些常用参数和比较操作：

1. 文件检查：
   - `-e file`：检查文件是否存在。
   - `-f file`：检查文件是否存在且为普通文件。
   - `-d file`：检查文件是否存在且为目录。
   - `-r file`：检查文件是否存在且可读。
   - `-w file`：检查文件是否存在且可写。
   - `-x file`：检查文件是否存在且可执行。
2. 字符串比较：
   - `-z string`：检查字符串是否为空。
   - `-n string`：检查字符串是否非空。
   - `string1 = string2`：检查字符串是否相等。
   - `string1 != string2`：检查字符串是否不相等。
3. 数值比较：
   - `num1 -eq num2`：检查两个数字是否相等。
   - `num1 -ne num2`：检查两个数字是否不相等。
   - `num1 -lt num2`：检查num1是否小于num2。
   - `num1 -le num2`：检查num1是否小于或等于num2。
   - `num1 -gt num2`：检查num1是否大于num2。
   - `num1 -ge num2`：检查num1是否大于或等于num2。
4. 逻辑操作：
   - `! expression`：对表达式求反。
   - `expression1 -a expression2`：逻辑与操作，两个表达式都为真时返回真。
   - `expression1 -o expression2`：逻辑或操作，两个表达式中任意一个为真时返回真。
5. 文件比较：
   - `file1 -nt file2`：检查file1是否比file2新（根据修改时间）。
   - `file1 -ot file2`：检查file1是否比file2旧（根据修改时间）。

这些是`test`命令中的一些常用参数和比较操作。可以根据需要组合和嵌套这些比较操作，以实现复杂的条件判断和逻辑控制。此外，`test`命令还支持在`[ ]`中使用逻辑操作符`&&`和`||`，以及使用圆括号来分组条件。

以下是一些示例：

```bash
# 检查文件是否存在
if [ -e "file.txt" ]; then
    echo "文件存在"
fi

# 检查字符串是否相等
if [ "$name" = "Alice" ]; then
    echo "你好，Alice"
fi

# 数值比较
if [ $count -gt 10 ]; then
    echo "count大于10"
fi

# 逻辑操作
if [ ! -z "$str" -a "$str" != "hello" ]; then
    echo "str非空且不等于hello"
fi

# 文件比较
if [ "file1.txt" -nt "file2.txt" ]; then
    echo "file1比file2新"
fi
```

通过使用`test`命令，可以根据不同的条件进行条件测试和比较，并根据测试结果执行相应的操作。这使得Shell脚本能够根据不同的条件和情况做出不同的决策和行为。

在Shell脚本中，方括号`[]`通常用于条件测试，它是`test`命令的一种等效形式。实际上，`[ ]`和`test`在大多数情况下可以互换使用。需要注意的是，方括号`[]`的前后必须有空格，否则会导致语法错误。

以下是关于方括号`[]`条件测试的一些要点和示例：

- 方括号`[]`用于执行条件测试，并根据测试结果返回退出状态码。
- 在使用方括号进行条件测试时，表达式的各个部分需要用空格分隔开。
- 方括号支持与`test`相同的参数和比较操作符。
- 方括号还支持逻辑操作符`&&`和`||`，以及圆括号来分组条件。
- 方括号可以用于`if`语句、循环、命令行参数检查等各种场景。

以下是一些使用方括号进行条件测试的示例：

```shell
# 检查文件是否存在
if [ -e "file.txt" ]; then
    echo "文件存在"
fi

# 字符串比较
if [ "$name" = "Alice" ]; then
    echo "你好，Alice"
fi

# 数值比较
if [ $count -gt 10 ]; then
    echo "count大于10"
fi

# 逻辑操作
if [ ! -z "$str" ] && [ "$str" != "hello" ]; then
    echo "str非空且不等于hello"
fi

# 使用方括号进行循环
for ((i=1; i<=10; i++)); do
    if [ $i -eq 5 ]; then
        echo "达到5次"
        break
    fi
done
```

需要注意的是，方括号`[]`只是一种语法上的约定，它并不是Shell的关键字或内置命令。在实际使用中，方括号`[]`将被解释为一个命令，而不是一种数据类型。因此，方括号`[]`在Shell脚本中的使用方式和语义与`test`命令完全相同。



在方括号`[]`中，判断条件通常需要加上双引号`""`的原因是为了处理包含空格或特殊字符的字符串。

当条件中的字符串包含空格或特殊字符时，如果不使用双引号将其括起来，Shell会将其解析为多个独立的单词或符号，从而导致条件判断失败或产生意外的结果。

例如，假设有一个变量`name`的值为`John Doe`，若不使用双引号括起来，条件判断如下：

```bash
if [ $name = John Doe ]; then
    echo "姓名匹配"
fi
```

在上述示例中，Shell会将`John`、`Doe`视为两个独立的单词，而不是一个完整的字符串。这将导致条件判断失败，因为Shell会尝试解析`John`和`Doe`这两个未定义的变量。

为了正确处理包含空格或特殊字符的字符串，需要使用双引号将其括起来，使其作为一个完整的字符串进行判断：

```bash
if [ "$name" = "John Doe" ]; then
    echo "姓名匹配"
fi
```

在此示例中，双引号将`$name`和`John Doe`括起来，告诉Shell将其视为一个整体字符串。这样就能正确比较字符串，判断条件是否为真。

总结起来，为了避免由于字符串中包含空格或特殊字符而导致的意外行为，建议在方括号`[]`中的判断条件中使用双引号`""`将字符串括起来，以确保条件判断的正确性。

# 11 数值比较

以下是在`test`命令和`(( ))`（算术表达式）以及`[ ]`（方括号）中使用的比较操作符的整理：

在`test`命令和`[ ]`中使用的比较操作符：

- `-eq`：相等（Equal）
- `-ne`：不相等（Not Equal）
- `-gt`：大于（Greater Than）
- `-ge`：大于等于（Greater Than or Equal）
- `-lt`：小于（Less Than）
- `-le`：小于等于（Less Than or Equal）

在`(( ))`中使用的比较操作符：

- `==` 或 `=`：相等（Equal）
- `!=`：不相等（Not Equal）
- `>`：大于（Greater Than）
- `>=`：大于等于（Greater Than or Equal）
- `<`：小于（Less Than）
- `<=`：小于等于（Less Than or Equal）

通过这些比较操作符，可以在条件测试中比较数值和字符串，并根据比较结果进行逻辑判断和控制流程。需要注意的是，`test`命令中使用的比较操作符通常需要在参数之前加上连字符（如`-eq`），而在`(( ))`和`[ ]`中使用的比较操作符则直接写在表达式中。

请注意，比较操作符的拼写是英文单词的简写，如"eq"代表"equal"，"ne"代表"not equal"等。

以下是一些示例：

在`test`命令和`[ ]`中的示例：

```bash
if [ $num -eq 5 ]; then
    echo "数字等于5"
fi

if [ "$str1" != "$str2" ]; then
    echo "字符串不相等"
fi
```

在`(( ))`中的示例：

```bash
if (( num == 10 )); then
    echo "数字等于10"
fi

if (( count > 0 )); then
    echo "count大于0"
fi
```

这些比较操作符允许您根据条件测试的结果来控制Shell脚本的执行路径，从而实现不同的逻辑和行为。在使用这些比较操作符时，请根据具体情况选择适当的操作符和正确的语法。

# 12 函数

在Shell中，函数是一种可重复使用的代码块，它可以接受参数、执行特定的任务，并返回结果。函数可以帮助您组织和模块化Shell脚本，使其更加可读和易于维护。以下是关于Shell函数的详细讲解。

### 函数定义和调用

在Shell中，函数定义的一般语法如下：

```bash
function_name() {
    # 函数体，包含一系列的命令和逻辑
}
```

或者使用紧凑形式：

```bash
function_name() { command1; command2; ...; }
```

要调用函数，只需使用函数名加上括号：

```bash
function_name
```

### 函数参数

函数可以接受参数，以便在函数内部使用。在函数定义中使用`$1`、`$2`等特殊变量来引用传递给函数的参数。例如：

```bash
greet() {
    echo "Hello, $1!"
}

greet "Alice"  # 调用函数，并传递参数
```

在上述示例中，函数`greet`接受一个参数，并在函数体中使用`$1`引用该参数的值。

### 函数返回值

函数可以通过`return`语句返回一个退出状态码，范围为0-255。在函数中使用`return`语句后，将退出函数并返回指定的状态码。例如：

```bash
add() {
    return $(($1 + $2))
}

add 3 5  # 调用函数，并传递参数
result=$?  # 保存函数的返回值
echo "Sum: $result"
```

在上述示例中，函数`add`接受两个参数，并返回它们的和。在函数体中，使用`return`语句返回计算结果。

### 局部变量

在函数内部定义的变量默认是全局的，可以在函数外部访问。如果希望在函数内部创建局部变量，可以使用`local`关键字。例如：

```bash
my_func() {
    local name="Alice"
    echo "Hello, $name!"
}

my_func  # 调用函数
echo "Name: $name"  # 错误！无法在函数外部访问局部变量
```

在上述示例中，变量`name`使用`local`关键字在函数内部定义，成为局部变量。该变量无法在函数外部直接访问。

### 示例

下面是一个更完整的示例，展示了函数的定义、参数传递、返回值等：

```bash
# 定义函数，接受两个参数并计算它们的乘积
multiply() {
    local result=$(($1 * $2))
    echo "Product: $result"
    return $result
}

# 调用函数并传递参数
multiply 4 5

# 保存函数的返回值
result=$?

# 输出返回值
echo "Return value: $result"
```

在上述示例中，函数`multiply`接受两个参数，并计算它们的乘积。在函数体中，使用`local`定义局部变量`result`来保存计算结果。最后，函数通过`return`语句返回结果，并在函数外部使用`$?`来获取返回值。

总结：

- 函数是一种可重复使用的代码块，用于执行特定的任务。  
- 函数定义使用`function_name() { }`的语法。
- 函数可以接受参数，并使用`$1`、`$2`等特殊变量引用参数的值。
- 函数可以使用`return`语句返回退出状态码，并通过`$?`获取返回值。
- 可以使用`local`关键字在函数内部创建局部变量。
- 函数可以帮助组织和模块化Shell脚本，提高代码的可读性和可维护性。















