![image-20240222092333634](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402220923698.png)

# 2.18工作记录

==骑车到公司所花的时间：11分1秒==

==第一次技术支持花费的时间：32分17秒==

==写总结规划的时间：13分08秒==

____

今天除了技术支持要完成的还有驱动手册13期的编写，这里的编写不仅仅是markdown形式的手册，除此之外还有word形式的手册要写，果姐姐明天回来，这是一定要完成的。技术支持今天是第一天除了最开始的时候人数问题还多一点点，但是后面的基本就没啥了，现在就是半个小时看一下，整点和半点看一下就行，现在开始写手册了。

早上四点的时候起床已经将手册的大体框架写的差不多了，现在要做的就是从前到后一点点的将markdown版本的手册写完，这里的要求仅仅是写完，当写完之后就开始迁移了，将markdown的文字迁移到word上，在迁移的过程中读一遍，正好进行检查，现在开始。

# 2.19工作记录

==骑车到公司所花的时间：12分45秒==

==第一次技术支持花费的时间：0秒==

==写总结规划的时间：13分08秒==

-----

昨天终于是将13期的驱动写完了，不容易不容易，昨天早起的行为很高兴,有一种正反馈，而从今天开始就要开始真正的录课了，还是那句早上已经写过的话，当你遇到一个摇摆不定的事情的时候，那就努力的去做呗，反正只要不做就永远没有成功的可能。

当然这只是一个大的目标，一个大目标之下必然要有一系列的小目标，每天的规划已经挺好了，这就是要完成的事情，具体内容如下所示：

![image-20240219092830557](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402190928579.png)

十点之前是不能去那个录视频的屋子里的，在十点的时候他们会开会，而我也有一个小时的时间进行整理内容，写今天的规划等等。

上面的是一个大目标，除此之外还有一个大目标呀，那就是解决工作时间QQ带来的问题，目前仍旧是想要按照时间来进行管理和区分的，只要能克制住看QQ的这个有损注意力的这个习惯，上班的效率真的会大大提高，幸福程度也会大大提升，现在的做法是找一个小工具，每过20分钟，或者每个小时的25分和55分用来提醒我看QQ，非技术支持的时间就跟着这个指示来，目前对我有影响的是想要看有没有人跟我说话，跟我说话的人我能注意的，而且想回复的不多，只有三四个人，法师、果姐姐、苏姐姐、棒棒糖，然后对上面这些人的回复进行分析，法师那个地方主要是工作和一些任务和工作上的事情，现在来统计一下法师跟我发的消息频率，2月的天数太少了，现在来统计1月的，3天，在一月的30天中，法师有6天跟我说过话，在月初的时候会有个工资确认，有两天是关于房子的事情，2天是因为工作的事情，法师找我的频率可太低了，而且一般情况下找我的都是月初以及确认相关的事宜，其他一些情况基本都是口头描述的，还是口语交际比较多，根据大数定律，法师不会找我，所以法师这一条就过去了。

然后来分析苏姐姐，苏姐姐一般都是关于B站客户问的问题的，其他的都是属于我主动想聊天找的了，这里的优先级很小，甚至可以说是完全不着急，所以这些完全可以之后时间到了的时候再回复。

再次重申一下，在25到30 55到整点的时候，是可以聊天的，以及回复客户的问题，这时候QQ可以一直保持在明面上，那个时钟也会尽可能的保持五分钟的显示时间，目前想着的到也还行，看看具体的实践吧。

现在来分析果姐姐，果姐姐这里问题可真的太大了，只要一有事就去找果姐姐，无论是大事、小事、工作上的事情还是其他的事情，都是要找果姐姐，这其实是不对的，你也不能一直这样，在打开QQ之前满心欢喜的以为果姐姐会来回个话，而大多情况下是没有的，而说话说的多了之后难免就有不一样的想法，想法又会产生矛盾，这是必然的事情，而对于果姐姐的那些问题还有任务，也并不是及时的，换句话来说，这些并不需要很高的实时性，有什么着急的事情，自然而然的就会通过口头表达的形式来找我，完全没有必要在QQ上，而且你每次回复果姐姐回复的这么快，也差不多算是秒回吧，但是反过来呢，果姐姐基本上从来不是秒回你，有很多时候甚至是过去了好久了，都没有回复你，可能恰好看到，也可能恰好心情好，这才真正回复了你，这样你懂了吗，而果姐姐敲键盘的时候，你甚至都以为是在给你发消息，这时候再想想你自己，你也在飞速的敲键盘呀，但你在敲键盘的时候都是在跟人说话吗，绝大多数都不是吧，我觉大多是的时间都是写手册和写记录，除了技术支持的时候说话比较多之外，其他时候都是正常，所以果姐姐这个地方也可以过了，在非技术支持的时候也是跟其他人一样。

而至于其他人，就没啥可说的了，棒棒糖太懒了，也不知道什么时候能有一定的认知，而田田太笨了，也可能是我有偏见~~，这没办法，有对象的同龄人和没对象的同龄人也只能区别对待呀，这些的回复都不着急。

行了，综上来看全部的人的回复都不需要即使了，也就是秒回，其实就算是秒回又能代表什么呢？其实什么都没有，客户那里完全没有感激，带给你自己的却是很严重的问题，损己而不利人，你说这是何必呢？所以这种没有价值的责任心都该丢掉，这里是责任心了，那正常上班，完成其他的工作就不是任务了吗，当然不是，你这里的责任心有了，那里的责任心就没有了，你能说这是有责任心的表现吗，不能吧，是你技术支持的时候就好好的技术支持，不是你技术支持的时候就安安心心的钻研问题、无论是写手册、录视频、钻研问题等等，都不应该是看QQ，因小而失大，就目前上面提出的挺好的。就先这样。

___

上面的这个问题不是一天两天就能搞定的，这个问题需要长时间的去积累、去解决，根据随机性原则，总有一条方法是最适合我的，但需要时间去遍历，这些就放在后台呗，现在要开始今天的主线任务了，今天要录完两节视频，如下所示：

![image-20240219102758027](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402191027048.png)

分别是视频的第一节和第二节，其实在前面还应该有个第0节，但是那个呢是要在最后，全部的内容都讲完之后的一个总结，告诉客户这个整套视频要学习的是哪些，之前我还想直接总览全局，现在看来这是不可能的，不论是法师还是王老师，他们的视频你会发现都是在最后才进行总结的，难道你没有发现吗，都有先驱者或者说是巨人给你探路了，那你就不用犹豫了，跟着他们的路继续向前走就行了。

都十点半了，也不知道他们咋还没有开会，不清楚，但没啥关系，我可以多多总结一会儿，也就剩下了一个小时了，我要去体验一下设备吗，思考一下，去吧，现在也不知道苹果用的录课软件是什么，伤脑筋，我最终的截图软件不出意外肯定是QQ截图了，怎么好用怎么来呗，这个无所谓了。剪辑软件就用哔哩哔哩的那个必剪，录屏的话我肯定是用我最熟悉的Ocam。

这时候就在想要不要创建两个用户呢？自己用自己的用户就行了，事情还少，好像也是一个不错的选择。



# 2.20 星期二 工作记录

今天的任务是这四小节，确实挺简单的，一般很快就过去了，我认为这四节没啥问题，因为都是一些常识性的讲解和安装，所以也不会花费过多的时间，而且后面的框架很不容易，我认为目前的我还没有认识到后面那些章节的关键点，所以目前认为明天需要花费一天的时间整理对应的框架。

![image-20240220091100582](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402200911616.png)

也不仅仅于此，因为当时的想法还不太成熟，现在这样讲解的话，在实现之前的效果是很繁琐的，整理一下步骤.

第一步，首先肯定是要自己学会才能真正的讲解出来的，所以自己学会并理解是所有的第一步，这是无论如何都绕不过去的一个步骤。

在自己理解了之后，然后就是尽可能的写出来，将你学习到的东西，整理成markdown的形式，这次肯定不会提供word形式的手册了，当也不一定，其实转换成word形式的手册也不是难事，只不过有些麻烦罢了，需要一点一点的进行复制，但我认为这个视频所要起到的作用是宣传，弥补我们在这个反面的短板，所以最适合初学者用户的才是最好的，只要用户看的舒服，最终的形式其实都无所谓了。其实在学习的过程中进行适当的笔记记录，后面的成册的手册，也只是最终的书面化的效果而已。

在确定逻辑和内容没问题之后，第三个步骤就是整理对应的稿子和最终效果，出现在视频里面的结果必然是经过很多次的尝试之后才确定下来的内容，所以一定会有相对应的稿子和最终效果的，其实在这个阶段可以将这两个整合在一起，就像昨天的录课时候的那种效果，分段样式的进行稿子和最终效果，对想的没错，但具体的实施效果肯定也不会这样一起的，最终还是要分开，整理的时候可以合一起。

所以整理内容真的并不简单，虽然只是简单的四个字，但是却包含了学习知识、整理内容成手册的形式、完成稿子和最终效果，虽然感觉有些困难，但还是要尽可能的努力呀，最近这些天我认为过的不错，在早上或者晚上的时候整理自己的思想，重新塑造自己的世界观，从第一次看这个up的视频开始到现在已经过去了一个月了，从最开始的迷茫到过年时候的迷失，再到目前的有所得，当然在未来的某一天，你可能意识到现在做的事情的价值观仍旧是有问题的，但是至少从现在的角度出发，你现在的所思所想就是最正确的事情。当目前的这些思想塑造完成之后，剩下的就是尽可能的去努力了，其实现在也差不多了，虽然时间过了仅仅三天，但是每次我能成功起床，看到外面的天还黑着，人们都在沉睡，而只有我或者很少的一部分人在努力，我就感觉良好，我终于又一次站在了命运的面前，平起平坐。

____

今天要录制的是四节视频，先把昨天剩下的视频剪掉，剪辑完成了，昨天的两节仅仅只是试水，今天要讲解的内容和昨天要讲解的内容还有些区别，趁着上午还有一个小时的时间研究一下下午的课程要怎样讲，如果是按照之前的方式，那就是单纯的实际操作了，但是并没有截图的过程，所以我这里应该要有昨天的那种步骤和截图吗。我认为是需要的，如果只是照着文档来念一遍，或者单纯的操作一遍，其实也是有问题的，虽然这样可以很快的结束战斗，可以很快的将视频给录完，但是这样录完的视频真的符合现在录制视频的价值观吗，与这个视频的整体初衷就相背离了，其实直到今天也没有真正清楚的认识到这个视频的初衷是什么，做这个视频的意义是跟黑马那样，做一个真正适合初学者的，并且精致，能让初学者真正学到东西的视频。

==核心：做一个真正适合嵌入式Linux初学者的，精致并且能让初学者学到东西的视频==

而我的做法是怎样的呢，也就是最终的实现效果，在我的观点里（==先去看看狂神老师是怎样讲解软件安装的==），这次是以git视频为例进行观看的，但是这次看的不是内容，而是老师的讲解方法和技巧。

狂神的讲解方法是根据手册进行讲解，其实跟我的这种方式是相同的，但又有些不同，狂神在讲解一般内容的时候尤其是docker那节最让我深刻，但我认为他也是提前写好了一个手册，最终又将手册转化为了最终效果，但我又不是很想破坏我的手册，所以目前想到的折中方案仍旧是使用两个手册，我想想啊，总感觉还是有些不对，没有问题，这样做是对的，按照你想的来呗，同样的，也是一个是手册，一个是板书，这两个不是冲突的，我最开始的想法是对的，也不用非要跟人家是一样的效果，而且我认为我这样的效果更好呢？

但是那就有些地方需要推敲了，因为现在的稿子和最终效果里面是没有写这里相关的内容的，之前想的是这几个章节不需要有这些内容，直接跟着手册，操作一遍就能通过了，但是经过昨天第一节和第二节视频的录制，以及今天上午的整理和学习，认为这个地方需要改进，怎样让用户更好接受怎么来？所以下午需要先整理好最终效果，这样修改的话，稿子也要修改，也不是一件简单的工程，尽可能的快点吧。

____

中午的午休结束了，现在还有五个小时的时间，目前在思考，是将后面的四节重新写一下稿子，还是录制一节写一节呢？就这么四节了，这样吧，今天录制一节看看情况，然后后面的三节今天应该是录制不到，所以今天只有安装vmware这一小节。

在三点半的时候，终于算是录制完了这一期，我再看一下规划,明天本来的任务是tabby，现在好了又多了一个Ubuntu，但是我认为我可以直接去里面，里面和外面最终要实现的效果是相同的，那我为什么要在外面呢，实际上也能看一下QQ，而且没有效果，所以完全没必要呀。

还是不对，如果不是要录视频还是不要在那个屋子里呆着了，总感觉怪怪的，有两个矛盾的点，那个屋子没人进行监督，如果一个人的话下午很有可能就飞了，然后是有罪恶感，因为没有在录课，如果在这个屋子的话就不会有这种羞愧的感觉，但是看QQ的这个问题还是很严重，要好多种方法一起使用才能其效果，就目前的情况来看，首先是要有一个时钟软件来不断的提醒你，现在的时间在一分一秒的走，而每间隔十五分钟会提醒你该看QQ了，这时候就适当的看一下，但是这时候要分为两种情况，一种是技术支持的时候一种是非技术支持的时候，技术支持的时候每隔十五分钟就看一下，如果没人问问题就直接进行到下一个十五分钟，而有人问问题就回答一下，当非技术支持的时候，仍旧是每隔15分钟看一下，但是这个时候只是看十五分钟到了之后是不是有好友来询问你问题了，如果有问题就看着回复一下，如果没问题就进入下一个十五分钟。除了这个软件之外，还有一个地方很重要，那就是QQ群的状态，在之前的时候QQ群是全部放到群管理里面的，但是这样的话还是会不停的点进去，从而消耗多余的精力，后来尝试了一下解开全部的限制之后，仍旧是存在问题，那就是他会闪烁，也可能那个时候使用的是另一台电脑，所以后面又全部不闪烁，免打扰了，这样就只有好友能闪烁我，除此之外，我发现耳塞也是一个很重要的内容，在没有耳塞的情况下，很容易的就迷失了，一般情况下不是无脑刷网页就是去聊天，没有意义呀。

____

从今天晚上开始就不再看老岁月的视频了，总是需要自己消化和运用的，俗话说的好，贪多嚼不烂，这是很正确的一个观点，规定到周六晚上吧，严谨一点，周六晚上可以看视频，之前就不看了，从今天晚上和明天开始将时间花费.

___

# 2.21 星期三 工作记录

​	今天的任务是录完后面三节的视频，但是在录完之前还有很多要修改的地方，就比如手册、稿子、最终效果，等等，任意一点完不成都将无法进行录制的工作，上午打算的是写完上面说的这些，然后下午的话是完成录制的工作。

​	先分析一下昨天，有些规定要修改，不然禁受不住，以后星期中的那一次就取消了，以后就是换到星期六晚，其他要说的就没了，这只是一个小插曲，之前的睡眠也都清零，明天四点起床，要做的事情不多，就是写稿子，继续向下学习，其他的就没啥要总结的了，关于三观的确立，目前就先这样，总要花费一些时间去慢慢的体会，不论什么事情都是要有一个理解的过程。

____

然后开始今天的工作，昨天在写稿子的时候遇到了一个很严重的问题，在之前的时候同样也遇到了，那就是在写稿子以及手册的时候无法真正的静心，或者这样说，他无法真正的进入到这种心流的状态，不能全身心的投入，而是陷入了一种低效率的工作，这时候你能说没有在工作吗，不是，肯定是在工作的，但是无论是从行为上还是心理上都没有协调配合，事实上都在默默的排斥这种行为，分析一下原因吧?

难道是因为写稿子并没有什么意义吗？这肯定不是呀，如果没有稿子你就无法正常的录制视频，当然你也想像法师那样直接说出来，但经过推理和尝试，你发现那种方式是不适合你的，或者说我认为他的这种方式是不对的，经不起推敲，当然我也并不能说出来，我只是对我现在这种讲解方式有着高度的自信而已，所以说了这么多，稿子是很重要的一环，你可能认为他枯燥、乏味，但这个步骤永远不可缺少，它的地位无可撼动。

为什么你会认为他枯燥乏味呢？其实任何要做的事情，你认为枯燥乏味，其实就是没有进入心流的状态？而心流是怎样进入的呢？是技巧也可以说是能力和要做事情的难易程度形成了一个差不多的平衡，这时候你做起事情来会很投入，完全感受不到时间的流失，而关于写稿子和手册这个地方同样也是如此，那应该怎样调整呢，可以从两个方面来入手，正是我们所说的技巧和难度，技巧在这个时间点是绝对的，无法更改的，所以能修改的就只有难易程度，那应该如何通过修改难易程度来达到心流状态呢？

我认为写稿子很枯燥，在难易程度上是怎样的呢，原因我也不知道能写多少点，先一个一个来，首先一个就是你没有规定时间，当没有一个截止时间限制的话，那绝对是无法投入的，你会不经意间就分心了，看着时间还很长，他会在你心里不断的向后延期，直到你慢慢悠悠的做完为止。其他的写不出来了，这绝对就是时间的问题了，规定时间内完成正确的事情。

___

然后是QQ的问题了，QQ默认我让他不闪烁了，但是那样不知道有没有人给我发消息，而且我之前还默认将状态栏隐藏掉了，唯有未知的才是你心中神往的，唯有距离才会产生美，既然心流可以用在解决上面的问题上，能不能应用在我看QQ这个上面呢？可以这样想，在规定的时间内不看QQ也是一件要做的事情，同样可以分为技巧和难度，这里的技巧可以量化，而且技巧是限时的，会随着时间而波动，难度其实并不大，所吸引你的无非是看了QQ之后能消除心里的那点神秘感，是不是有人给你说话了，然而事实上，跟你说话的人也确实是不多，昨天也分析过了，所有跟你说话的人都分析了一遍，你会发现任何人都没有即时性，认识到这一点之后，其实就通透多了，现在你懂了吗。行了，现在开始今天的工作。

____

最终效果更新一下，将稿子和最终效果合成一个了，因为我发现在真正录制的时候使用的也是分开的，这样会导致最终会重新整合在一起，既然这样的话，那为什么不直接就整理好呢，而且这样的话也会少打开一些文档，最终也只会保留一个文档，这样何乐而不为，不再那样的眼花缭乱。

____

今天本来是要完成tabby的，但是改了好久的稿子，本来以为改了稿子或者说最终效果很简单很简单，但是在实际讲解下来发现并不是我想象中的那样的，就比如需要作图，还需要重新写稿子，这些都要花费很多的时间和精力，尤其是昨天之前，今天上午的时候正因为这个问题还分析了半天，技巧和难度达不到平衡，而实际上是因为并没有限定时间，现在在想能不能用家里的电脑录呢，我可不可以强制改成1080P大小的，好像并没有意义，我也没必要在家就将完整的视频录制出来，我其实也仅仅只需要写完最终效果就好了，最多在家里演练一下，这个想法是没问题的。现在还有半小时下班，然后想一下tabby要怎样讲解。

首先tabby是一个终端软件，那这个终端是什么呢？我甚至认为这一小节应该讲解一下终端的发展历史，讲解什么是终端。



# 2.22 星期四 工作记录

​	昨天录完了视频的第四节和第五节，目前与预定的时间差了一天，但有些事情在做着做着的时候就有东西要添加，这也是无可避免的，而录视频的本质就是想要将更好、更精致的内容呈现给客户，虽然现在的这一版本也可以正常实现，但那样又还有什么意义呢？所以遵循主线的原则一定是对的，尽力的去做就行了。

但是在家的效率真的就挺低的，在家的时候花费了一个多小时的时间用来写反思，但反思很有效果，目前认为是值得的，出了问题就解决，有办法就提出，调整之后再尝试，不断的试错罢了，看来以后手机倒计时也应该少用，早晨的时候正是因为手机倒计时才导致分心看了一会儿无用的东西，所以以后只有第一时间洗漱使用倒计时，其他时间就不使用手机倒计时了，而是使用那个定时器的倒计时，这样分心的可能性就会被大幅度的减少，而且我发现一个人长时间的保持一件事情除了陷入心流的状态，其他时间是很难的，虽然你知道做的这件事情是对的，但是一直持续的做这件事情就是不行，可能还是不够热爱吧，现在的想法是让自己变的热爱，先解决这个无法长时间聚集注意力的事情，可以学着上学那样，使用计时器设置一个时间，然后当时间到达之后出去欣赏一两首音乐，然后重新开始新一轮的计时，目前想到的办法是这样的，因为如果直接看电脑来消遣的话，那很容易就跑偏了，行了这些事情晚上再说，现在的话就回归到工作上来，现在继续写对应的手册。	

___

重新写一下tabby这个章节应该要讲解哪些内容？首先tabby是一个终端软件，但在此之前并没有介绍终端的概念，所以在第一小节中理所当然的应该介绍终端，什么是终端，以及ubuntu打开终端的方法。在第一节可以稍微提一下远程终端，在第二节讲解tabby软件的下载和安装，第三节来讲解通过ssh远程连接ubuntu，第四节就是字体设置以及快捷键的讲解了。

昨天晚上和早上学习和简单写了一下要讲解的内容，先把手册搞完。

___

哈哈哈，终于搞完了已经写好稿子的这些了，虽然这些内容确实都不难，只能说这是一个初期的尝试，等后面的流程熟悉之后，如果一直像这个星期一样进行反思的话，那也会尽可能的加快脚步的，就比如最开始的时候是最终效果和稿子分开的，在实际操作之后，稿子和最终效果都合成到了最终效果里面，所以现在重新整理一下步骤。

1. 学习相关的内容，这里学习的时候一定要注意写笔记，当你学习完成之后可以通过笔记来回忆起学习的内容，其实就类似于在学校时候记录的笔记
2. 整理成相应的手册，这里的手册跟上面的笔记并不一样，上面的笔记是给自己看的，而这个笔记是给用户看的，这是有区别很不一样，我自己的笔记只需要我自己看懂就行了，但是给客户的资料就不能这样，其实很多时候我自己的笔记也都写不好，甚至很多时候都没有，绝大多数情况下，都是文档在推动着我学习，而不是我推着文档的进度。
3. 写最终效果，这里的最终效果是稿子和演示的集合体，稿子是以第二小节的手册为前提来完成的，但是在讲解的时候可以讲解多一些或者忽略一些东西，讲解的和写的内容不完全一样，具体的方向和程度靠自己来把握，当这里完成之后，那就是最终讲解时候看的东西，就是第三步完成的东西，来完成的最终录制。
4. 录制视频：无论是多么牛的人，都会出错，或许真的有人可以一镜到底，但是目前的我是真的做不到，所以我只能通过稿子的方式来实现，并且录制的时候难免会磕磕绊绊，但是通过剪辑和分段，还能算优秀的过去这些，这就是我录视频的全部步骤了。

从明天开始就要写驱动视频了，这一周过的真好呀，假如生命中的每一周都能像这一周这样，那该多好呀。



# 2.23 星期五 工作记录

​	今天是技术支持，今天想要磨砺一下技术支持时间段内的学习注意力，就跟正常时间内看QQ的频率一样就行了，最开始的九点，就是直到什么时候解决完问题，什么时候结束，而后面的时候都是根据具体的事件而来，今天的任务是两节内容，不出意外肯定是完不成的，今天的真正任务是看视频，而且我要完成的任务在后面，所以这里还跟前面的第13期的视频不一样，第十三期我只需要写前面，后面的就不需要看了，因为这样看一遍的效果真的很差，而且实际应用的效果不太行，不如透过现象看本质，去学习一下里面的C语言的内容，但是这里的14期我要写的是后面的内容，肯定是跟前面的内容有联系的，所以要一点一点的向后看视频。

![image-20240223103723198](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231037231.png)

第十四期手册编写步骤：

1. 看全部的14期视频，看的时候不能仅仅只是看，而是需要写非常详细、非常详细的内容，可能还并不止于此，我认为都需要写出来详细的心路例程

2. 第一遍视频看完之后，就可以来第二遍了，在第二遍的时候就需要整理总结第一个步骤当中的内容，然后形成最终的手册。

   目前就这两条内容，其他要注意的也没啥，然后现在开始呗。

____

## 步骤一 第一遍学习

>1.基础知识
>
>​	什么是单总线
>
>​	外设介绍：ds18b20
>
>2.驱动编写：
>
>​	驱动编写步骤以及涉及到的知识点
>
>​	单总线时许代码编写
>
>​	使用路基分析仪直观认识单总线
>
>3.实践课
>
>​	使用ioctl设置分辨率
>
>​	课后作业

其实层次还是很分明的，所以这样看起来这章也不是很难，反正目前就是这样看的，我先来讲一下大体的逻辑，因为后面要讲解的都是一系列的协议，而为了在后面的学习中有足够的知识储备，所以需要在这一期的视频里讲解单总线，但如果只是讲解单总线的定义啥的，难免会很空洞，所以肯定要使用一个外设来进行讲解，所以这里选取了ds18b20这个温度传感器来讲。这样第一部分的基础内容的只是就有了，首先介绍一下什么是单总线，然后在第二个章节中简单的介绍一下ds18b20。

既然是实验视频，总是不可能没有实验的，在第一部分只是介绍，第二部分当然是具体的学习步骤了，就比如这个ds18b20 单总线驱动的编写，这个ds18b20是用来获取温度的，但是他是怎样获取的温度呢？我认为是我给他发一段指令，然后他会给我返回一段指令，这段指令里面就包括温度信息，当然这只是我想的，具体是怎样的指令呢？这就需要使用逻辑分析仪来进行逐步分析指令了，目前这是我的理解，现在开始学习。

## 1.什么是单总线？

单总线是DALLAS公司推出的串行扩展总线技术，与 SPI、I2C等穿行数据通信方式不同，单总线只需要一根信号线，单总线用一根信号线，既可以传输时钟又可以传输数据，而且数据是双向的，所以单总线具有节省IO、结构简单，便于维护和扩展的特点。

常见的单总线器件主要有温湿度传单器DHT11，温度传感器DS18B20。

单总线并不只可以实现一主一丛，也可以一主多从，可以根据地址进行区分，从而体现了便于扩展的有优点。 

>单总线的通信步骤：
>		单总线都是主从结构，当主句呼叫从机时，从机才会应答，所以主机都必须要严格遵循单总线的命令时许，如果命令时序不对，则机器不会相应。
>
>1.初始化
>
>2.ROM操作命令
>
>3.功能命令

## 2.DS18B20介绍

### 2.1 芯片概述

>- DS18B20是一种数字温度计，可实现温度测量和报警功能。
>- DS18B20支持9到12位分辨率的温度测量，可通过可编程非易失性存储单元来设置温度的下限和上限报警。
>- DS18B20使用单总线协议与上位机进行通信，只需一根信号线和一根地线。
>- DS18B20的温度测量范围为-55°C至+125°C（-67°F至+257°F），测试精度可达到士0.4°C。
>- DS18B20可以直接通过信号线供电，无需额外的供电电源。
>- 每个DS18B20具有一个全球唯一的64位序列号，可用于多个DS18B20的组网。
>- DS18B20可以串联在同一条单总线上，多个DS18B20可以由一个处理器控制。
>- DS18B20的组网方式适用于HVAC环境控制、建筑、设备、粮情测温、工业测温以及过程监测控制等应用领域。

### 2.2 基本性能

- DS18B20采用单总线接口，只需一个端口引脚进行通信。
- 每颗DS18B20芯片具有全球唯一的64位序列号。
- DS18B20具有最高12位的温度测量精度。
- DS18B20的温度转换速度小于750毫秒。
- DS18B20具有用户可自定义的非易失性存储器，可设置温度报警。
- DS18B20具有多点分布式测温功能，无需外围元器件。
- DS18B20支持报警搜索命令，可识别并标记超过设定温度的器件。
- DS18B20具有超强的静电保护能力。
- DS18B20可通过数据线供电，供电电压范围为2.5V至5.5V。
- DS18B20的温度测量范围为-55°C至+125°C（-67°F至+257°F）。
- DS18B20提供贴片的MSOP8和SOP8封装，以及3脚的TO-92和TO-92S封装。
- DS18B20在-10°C至70°C范围内的精度为±0.4°C。
- DS18B20可选的温度分辨率为9位至12位。

### 2.3 应用场景

1. 温度控制：DS18B20可用于各种温度控制系统，包括室内温度控制、恒温设备、温室控制等。
2. 工业系统：DS18B20广泛应用于工业领域，用于监测和控制工业设备、机械、制造过程中的温度。
3. 消费品：DS18B20可用于消费品中的温度监测和控制，例如家电、电子产品、汽车等。
4. 粮情测温：DS18B20被用于农业和粮食储存领域，用于监测和控制粮食仓库、谷物储存设施中的温度。
5. 温度计：DS18B20本身就是一种数字温度计，可用于个人使用、实验室、医疗设备等场景中的温度测量。
6. 任何感热系统：由于DS18B20具有广泛的温度范围和精度，它可以应用于任何需要温度感测和控制的系统。

### 2.4 DS18B20内部结构

![image-20240223140232819](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231402907.png)

DS18B20的EEPROM大小为九个字节，具体如下所示：

![image-20240223140344746](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231403828.png)

0 1：存放温度的低位和高位

2：存放温度的上限报警

3：存放温度的下限 报警

4：配置寄存器

5：保留位

6 7：存放用户字节

8：CRC校验

上电状态依赖EEPROM中的值

## 3.DS18B20寄存器介绍

### 3.1 配置寄存器

  在上个小节中讲到，DS18B20中有一个E2PROM，他存有9个字节，而12位置用来存放温度的高位和低位，34用来存放报警的温度，6是配置寄存器，6保留，78 存放用户字节，8存放CRC校验，所以这个视频中讲解的就是第4位的配置寄存器，他是1个字节，8位。

![image-20240223142308023](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231423150.png)

###  3.2 温度测量寄存器

![image-20240223143820061](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231438183.png)

11-15 符号位，如果都为1代表负数，如果都是0代表正数

4-10代表整数部分

0-3代表小数部分  

![image-20240223144324787](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402231443913.png)

## 4 DS18B20指令介绍

### 4.1 ROM指令

| 指令     | 指令代码 | 功能                                                         |
| :------- | :------- | :----------------------------------------------------------- |
| 读ROM    | 33H      | 用于读取DS18B20芯片中的全球唯一序列号                        |
| 匹配ROM  | 55H      | 在发送该指令后，接着发送64位序列号，与DS18B20匹配            |
| 搜索ROM  | FOH      | 用于确定挂载在同一个单总线上的DS18B20的数量和序列号          |
| 跳过ROM  | CCH      | 忽略序列号，直接向总线上的DS18B20发送温度转换命令            |
| 警告搜索 | ECH      | 执行后，只有当温度超过设置的上限或下限时，相应的DS18B20才会响应 |

### 4.2 RAM指令

| 指令           | 指令代码 | 功能                                       |
| :------------- | :------- | :----------------------------------------- |
| 温度转换指令   | 44H      | 将温度转换结果存放在RAM中                  |
| 读暂存器指令   | BEH      | 读取暂存器中的内容                         |
| 写暂存器指令   | 4EH      | 写入暂存器中的内容                         |
| 复制暂存器指令 | 48H      | 将暂存器中的第3、4字节的内容复制到EEPROM中 |
| 恢复RAM指令    | ECH      | 将EEPROM中的内容恢复到RAM中的第3、4字节中  |



### 4.3操作举例

 当单总线上只有一个DS18B20时，以下是相应操作的顺序及指令：

1. 开始进行温度转换：
   - 发送复位信号。
   - 发送ROM指令0xCC（跳过搜索）。
   - 发送RAM指令0x44（进行温度转换）。
2. 读取温度：
   - 发送复位信号。
   - 发送ROM指令0xCC（跳过搜索）。
   - 发送RAM指令0xBE（读取暂存器）。
3. 设置DS18B20：
   - 发送复位信号。
   - 发送ROM指令0xCC（跳过搜索）。
   - 发送RAM指令0x4E（写暂存器）。
   - 发送要写入的数据。



当单总线上有多个DS18B20时，以下是相应操作的顺序及指令：

1. 开始进行温度转换：
   - 发送复位信号。
   - 发送ROM指令0x55（匹配指令）。
   - 发送每个DS18B20的地址。
   - 发送RAM指令0x44（进行温度转换）。
2. 读取温度：
   - 发送复位信号。
   - 发送ROM指令0x55（匹配指令）。
   - 发送每个DS18B20的地址。
   - 发送RAM指令0xBE（读取暂存器）。
3. 设置DS18B20：
   - 发送复位信号。
   - 发送ROM指令0x55（匹配指令）。
   - 发送每个DS18B20的地址。
   - 发送RAM指令0x4E（写暂存器）。
   - 发送要写入的数据。

-----

心中的郁结还是没能解开，真的就很服气，我这几天辛辛苦苦打造的世界观、人生观、价值观，就这样被冲击了，虽然嘴上说的不在意、不在意，但是真的不在意吗，那当然是不可能的，借酒消愁是不可能消愁的，最终的结果，也只能是愁更愁，晚上多看分析看看，看看怎样才能解决这个问题，否则还是会一直持续下去的，所以昨天晚上的行为其实是不对的，不对好像也不对，互相矛盾了，今天晚上和明天早上打算是看完视频，并且写完对应的笔记的，明天是周六，而且今天是晚起床了，这不是借口，所以明天是要四点起床的，要是试试三点半起床试试？好像也可以，哈哈，三点半和四点，听起来就只差半小时，但是感觉都不一样了，还是算了把，等先熟悉了四点起床再说了。

#  2.24 星期六

本来打算的是今天早上早起，但是确实有些疲惫，有点困困的，所以上午睡到了七点半，所以也并没有完成定下的目标，也就是看完全部的驱动视频，并且写下完整的笔记，昨天看了差不多一半，其实本来可以看的更多的，但是由于昨天的心情并不好，调整的情绪也并不好，所以昨天有些狂躁、无心工作，今天就完全可以静下心来了，总不能白睡这么长的时间吧，也差不多找到了自己生命的意义，那就是在正确的时间做你认为正确的事情，或许每个时间段的心境并不一样，但是在每个分立的时间段之内，你确实做了你认为正确的事情，而且你认为正确的事情，一定是让你获得极大满足的事情，当然这个满足可能并不会立刻到来，是做这件事情的结果让你满足，中间做这件事情的过程可能是痛苦的，但是它是正确的，只要正确，最终就一定能得到心灵上的满足。

____

今天继续贯彻和测试QQ的查看和测试，昨天可能是因为心情问题有些许的烦躁，所以最终的效果并不是很好，记得善于记录。

看了一下苹果写的手册，我感觉真的好丑呀，难度是我对我自己太自信的原因？可是我真的感觉好丑呀，啊啊啊啊啊。写手册这么多年的果姐姐手册都写的这样难看，这是为什么呢？我竟然还以为手册写的好看而有了优越感，吐血。

其实是我的问题，关于田田的这个，虽然我并不喜欢田田，但是看到人有了对象，就感觉有了一种不一样的感觉，吐血，现在来分析一下为什么会有这样的感觉呢？可能曾经也有希望，而且交集太多的原因，但你这种思想确实是错的，你想的是，这么早就有了对象，从而损失了很多你认为珍贵的东西，但是你自己也说过了，这些只是你认为珍贵的，但是对于其他人来说，就比如田田，更加的喜欢现在的日子，找个喜欢自己的对象，生一个可可爱爱的小娃娃，然后安安稳稳，快快乐乐的度过一生，在你看来，这些并不是你想要追求的，但这也不是你干涉别人的理由呀，你其实连自己都管不住，又何谈管别人呢？

确实现在对于田田的看法，更像是对待一个小妹妹，现在就应该是不管田田做什么，只管支持就行了，不然你还能怎么做呢？其他你什么也做不了好吧，田田现在这样就挺好的，所以你这种过时的想法就抛弃吧。

所以感谢，让我又一次走出思想的误区，哦对明天大哥肯定要开车，不然说什么明天也要喝一个，哈哈。

____

## 1.编写复位时序

![image-20240224102407650](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402241024726.png)

~~~c
/**
 * 复位 DS18B20 温度传感器
 */
void ds18b20_reset() {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    
    // 将 GPIO 输出设置为低电平
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    
    // 延时 700 微秒
    udelay(700);
    
    // 将 GPIO 输出设置为高电平
    gpiod_set_value(ds18b20->ds18b20_gpio, 1);
    
    // 将 GPIO 方向设置为输入
    gpiod_direction_input(ds18b20->ds18b20_gpio);
    
    // 等待直到 DS18B20 将总线拉低
    while (gpiod_get_value(ds18b20->ds18b20_gpio)) ;
    
    // 等待直到 DS18B20 将总线拉高
    while (!gpiod_get_value(ds18b20->ds18b20_gpio));
    
    // 延时 480 微秒
    udelay(480);
}
~~~

## 2.验证复位时序

![image-20240224112358012](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402241123068.png)

## 3 编写写时序驱动代码

![image-20240226134819079](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261348122.png)



~~~c
/**
 * 向 DS18B20 写入单个位(bit)
 * @param bit 要写入的位(bit)，0 或 1
 */
void ds18b20_writebit(unsigned char bit) {
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    
    // 将 GPIO 输出设置为指定的位(bit)
    gpiod_set_value(ds18b20->ds18b20_gpio, bit);
    
    // 若 bit 为 1，则延时 10 微秒
    if (bit)
        udelay(10);
    
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    
    // 延时 65 微秒
    udelay(65);
    
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    
    // 延时 2 微秒
    udelay(2);
}

/**
 * 向 DS18B20 写入一个字节(byte)数据
 * @param data 要写入的字节数据
 */
void ds18b20_writebyte(int data) {
    int i;
    
    for (i = 0; i < 8; i++) {
        // 逐位写入数据
        ds18b20_writebit(data & 0x01);
        data = data >> 1;
    }
}
~~~

## 4.编写读时序驱动代码

![image-20240226134830343](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402261348406.png)

~~~c
/**
 * 从 DS18B20 读取单个位(bit)
 * @return 读取到的位(bit)，0 或 1
 */
unsigned char ds18b20_readbit(void) {
    unsigned char bit;
    
    // 将 GPIO 方向设置为输出
    gpiod_direction_output(ds18b20->ds18b20_gpio, 1);
    
    // 将 GPIO 输出设置为低电平
    gpiod_set_value(ds18b20->ds18b20_gpio, 0);
    
    // 延时 2 微秒
    udelay(2);
    
    // 将 GPIO 方向设置为输入
    gpiod_direction_input(ds18b20->ds18b20_gpio);
    
    // 延时 10 微秒
    udelay(10);
    
    // 读取 GPIO 的值作为位(bit)
    bit = gpiod_get_value(ds18b20->ds18b20_gpio);
    
    // 延时 60 微秒
    udelay(60);
    
    return bit;
}

/**
 * 从 DS18B20 读取一个字节(byte)数据
 * @return 读取到的字节数据
 */
int ds18b20_readbyte(void) {
    int data = 0;
    int i;
    
    for (i = 0; i < 8; i++) {
        // 读取单个位(bit)并根据位的位置进行左移操作
        data |= ds18b20_readbit() << i;
    }
    
    return data;
}
~~~

## 5 功能函数编写

 温度读取

~~~c
/**
 * 从 DS18B20 读取温度值
 * @return 读取到的温度值
 */
int ds18b20_readtemp(void) {
    int temp_l, temp_h, temp;
    
    // 复位 DS18B20
    ds18b20_reset();
    
    // 发送写入字节命令 0xCC（跳过 ROM）
    ds18b20_writebyte(0xCC);
    
    // 发送写入字节命令 0x44（启动温度转换）
    ds18b20_writebyte(0x44);
    
    // 延时 750 毫秒，等待温度转换完成
    mdelay(750);
    
    // 复位 DS18B20
    ds18b20_reset();
    
    // 发送写入字节命令 0xCC（跳过 ROM）
    ds18b20_writebyte(0xCC);
    
    // 发送写入字节命令 0xBE（读取温度值）
    ds18b20_writebyte(0xBE);
    
    // 读取温度低位字节
    temp_l = ds18b20_readbyte();
    
    // 读取温度高位字节
    temp_h = ds18b20_readbyte();
    
    // 将温度高位字节左移 8 位
    temp_h = temp_h << 8;
    
    // 组合温度值
    temp = temp_h | temp_l;
    
    return temp;
} 
~~~

文件操作集的read函数

~~~c
/**
 * 从 DS18B20 读取温度并将其返回给用户空间
 * @param file 文件指针
 * @param buf 用户空间缓冲区指针
 * @param size 缓冲区大小
 * @param offs 偏移量指针
 * @return 成功读取的字节数或错误代码
 */
ssize_t ds18b20_read(struct file *file, char __user *buf, size_t size, loff_t *offs) {
    int ds18b20_temp;
    
    // 从 DS18B20 读取温度值
    ds18b20_temp = ds18b20_readtemp();
    
    // 将温度值复制到用户空间缓冲区
    if (copy_to_user(buf, &ds18b20_temp, sizeof(ds18b20_temp))) {
        return -1; // 复制失败，返回错误代码
    }
    
    return 0; // 成功读取并复制温度值
}
~~~



## 6.应用程序的编写

~~~c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void ds18b20_get_temp(int value, char *sig, float *temp) {
    if ((value >> 11) & 0x01) {
        *sig = '-';
        value = ~value + 1;  // 取补码，表示负数
        value &= ~(0xF8 << 8);  // 清除高5位，保留低11位
    } else {
        *sig = '+';
    }
    *temp = value * 0.0625;  // 将温度值乘以0.0625，得到实际温度值
}

int main(int argc, char *argv[]) {
    int fd;
    int data;
    char sig;
    float temp;

    fd = open("/dev/ds18b20", O_RDWR);  // 打开设备文件 /dev/ds18b20
    if (fd < 0) {
        printf("打开文件失败！\n");
        return -1;
    }

    while (1) {
        if (read(fd, &data, sizeof(data)) < 0) {  // 从设备文件中读取数据
            printf("读取数据失败！\n");
            return -1;
        }
        ds18b20_get_temp(data, &sig, &temp);  // 将读取的数据转换为温度值
        printf("温度为 %c%.4f\n", sig, temp);  // 打印温度值
    }

    close(fd);  // 关闭设备文件
    return 0;
}
~~~

## 7.单总线的通讯时序

## 8.ioctl设置分辨率

~~~c
#define SET_RESOLUTION IOW('A', 'int')
#define SET_RESOLUTION_9 9
#define SET_RESOLUTION_10 10
#define SET_RESOLUTION_11 11
#define SET_RESOLUTION_12 12

/**
 * DS18B20 温度传感器的 ioctl 函数
 * @param file 文件指针
 * @param cmd 命令
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
long ds18b20_ioctl(struct file *file, unsigned int cmd, unsigned long args) {
    if (cmd == SET_RESOLUTION) {  // 判断命令是否为设置分辨率
        if (args >= SET_RESOLUTION_9 && args <= SET_RESOLUTION_12) {  // 判断参数是否在有效的分辨率范围内
            set_resolution(args);  // 调用设置分辨率的函数
            return 0;  // 返回成功
        }
    }
    // 如果不匹配 SET_RESOLUTION 或者 args 不在有效范围内，不执行任何操作
    return -1;  // 返回失败
}

/**
 * 设置 DS18B20 温度传感器的分辨率
 * @param args 分辨率参数
 */
void set_resolution(int args) {
    ds18b20_reset();  // 复位 DS18B20 温度传感器
    ds18b20_writebyte(0xCC);  // 发送跳过 ROM 命令
    ds18b20_writebyte(0x4E);  // 发送写配置寄存器命令
    ds18b20_writebyte(60);  // 发送配置字节 1，设置温度上限阈值
    ds18b20_writebyte(10);  // 发送配置字节 2，设置温度下限阈值

    switch (args) {
        case SET_RESOLUTION_9:  // 设置分辨率为 9 位
            ds18b20_writebyte(0x1F);  // 发送配置字节 3，设置分辨率为 9 位
            break;
        case SET_RESOLUTION_10:  // 设置分辨率为 10 位
            ds18b20_writebyte(0x3F);  // 发送配置字节 3，设置分辨率为 10 位
            break;
        case SET_RESOLUTION_11:  // 设置分辨率为 11 位
            ds18b20_writebyte(0x5F);  // 发送配置字节 3，设置分辨率为 11 位
            break;
        case SET_RESOLUTION_12:  // 设置分辨率为 12 位
            ds18b20_writebyte(0x7F);  // 发送配置字节 3，设置分辨率为 12 位
            break;
        default:
            break;
    }
}

/**
 * 检查参数的有效性
 * @param args 参数
 * @return 返回执行结果，成功返回 0，失败返回 -1
 */
int check_args(int args) {
    int ret = -1;  // 返回值，默认为失败

    ds18b20_reset();  // 复位传感器
    ds18b20_writebyte(0xCC);  // 发送指令字节 0xCC
    ds18b20_writebyte(0xBE);  // 发送指令字节 0xBE
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节
    ds18b20_readbyte();  // 读取一个字节

    switch (args) {
        case SET_RESOLUTION_9:
            if (ds18b20_readbyte() == 0x1F) {  // 读取一个字节并与 0x1F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_10:
            if (ds18b20_readbyte() == 0x3F) {  // 读取一个字节并与 0x3F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_11:
            if (ds18b20_readbyte() == 0x5F) {  // 读取一个字节并与 0x5F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        case SET_RESOLUTION_12:
            if (ds18b20_readbyte() == 0x7F) {  // 读取一个字节并与 0x7F 进行比较
                ret = 0;  // 设置返回值为成功
            }
            break;
        default:
            break;
    }

    return ret;  // 返回结果
} 

~~~

测试app

~~~c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdlib.h>

#define SET_RESOLUTION IOW('A', 'o', int)

/**
 * 根据传感器读取的原始数据计算温度值
 * @param value 传感器读取的原始数据
 */
void ds18b20_get_temp(int value) {
    char sig;   // 温度正负号
    float temp; // 温度值

    // 判断温度正负号
    if ((value >> 11) & 0x01) {
        sig = '-';
        value = ~value + 1;
        value &= ~(0xf8 << 8);
    } else {
        sig = '+';
    }

    // 计算温度值
    temp = value * 0.0625;

    // 打印温度信息
    printf("温度为 %c%.4f\n", sig, temp);
}

int main(int argc, char *argv[]) {
    int fd;    // 文件描述符
    int data;  // 读取的数据
    int args;  // 参数值

    // 打开设备文件
    fd = open("/dev/ds18b20", O_RDWR);
    if (fd < 0) {
        printf("打开设备文件出错\n");
        return -1;
    }

    // 获取命令行参数
    args = atoi(argv[1]);
    printf("参数值为 %d\n", args);

    // 检查参数范围
    if (args < 9 || args > 12) {
        printf("错误！参数范围应为 9 - 12\n");
        return -1;
    }

    // 设置分辨率
    ioctl(fd, SET_RESOLUTION, args);

    while (1) {
        // 读取数据
        read(fd, &data, sizeof(data));

        // 处理并打印温度信息
        ds18b20_get_temp(data);
    }

    return 0;
}
~~~

## 9 读取当前设置的分辨率

   ~~~c
   #define SET_RESOLUTION IOW('A', 0, 'int')
   #define GET_RESOLUTION IOR('A', 1, 'int')
   #define SET_RESOLUTION_9 9
   #define SET_RESOLUTION_10 10
   #define SET_RESOLUTION_11 11
   #define SET_RESOLUTION_12 12
   /**
    * ds18b2驱动的自定义ioctl函数。
    *
    * @param file 文件结构指针
    * @param cmd IOCTL命令
    * @param args IOCTL参数
    * @return 成功返回0，失败返回-1
    */
   long ds18b2_ioctl(struct file *file, unsigned int cmd, unsigned long args) {
       int resolution;
   
       // 检查命令是否为SET_RESOLUTION
       if (cmd == SET_RESOLUTION) {
           // 检查参数是否在有效范围内
           if (args >= 9 && args <= 12) {
               // 调用set_resolution函数，使用提供的参数设置分辨率
               set_resolution(args);
           } else {
               // 参数不在有效范围内，返回-1表示失败
               return -1;
           }
       } else if (cmd == READ_RESOLUTION) {
           // 读取分辨率
           resolution = read_resolution();
           // 将分辨率的值复制给用户空间的args
           if (copy_to_user((int *)args, &resolution, sizeof(resolution))) {
               // 复制失败，返回-1表示失败
               return -1;
           }
       }
       // 返回0表示成功
       return 0;
   }
   
   /**
    * 设置 DS18B20 温度传感器的分辨率
    * @param args 分辨率参数
    */
   void set_resolution(int args) {
       ds18b20_reset();  // 复位 DS18B20 温度传感器
       ds18b20_writebyte(0xCC);  // 发送跳过 ROM 命令
       ds18b20_writebyte(0x4E);  // 发送写配置寄存器命令
       ds18b20_writebyte(60);  // 发送配置字节 1，设置温度上限阈值
       ds18b20_writebyte(10);  // 发送配置字节 2，设置温度下限阈值
   
       switch (args) {
           case SET_RESOLUTION_9:  // 设置分辨率为 9 位
               ds18b20_writebyte(0x1F);  // 发送配置字节 3，设置分辨率为 9 位
               break;
           case SET_RESOLUTION_10:  // 设置分辨率为 10 位
               ds18b20_writebyte(0x3F);  // 发送配置字节 3，设置分辨率为 10 位
               break;
           case SET_RESOLUTION_11:  // 设置分辨率为 11 位
               ds18b20_writebyte(0x5F);  // 发送配置字节 3，设置分辨率为 11 位
               break;
           case SET_RESOLUTION_12:  // 设置分辨率为 12 位
               ds18b20_writebyte(0x7F);  // 发送配置字节 3，设置分辨率为 12 位
               break;
           default:
               break;
       }
   }
   
   /**
    * 检查参数的有效性
    * @param args 参数
    * @return 返回执行结果，成功返回 0，失败返回 -1
    */
   int check_args(int args) {
       int ret = -1;  // 返回值，默认为失败
   
       ds18b20_reset();  // 复位传感器
       ds18b20_writebyte(0xCC);  // 发送指令字节 0xCC
       ds18b20_writebyte(0xBE);  // 发送指令字节 0xBE
       ds18b20_readbyte();  // 读取一个字节
       ds18b20_readbyte();  // 读取一个字节
       ds18b20_readbyte();  // 读取一个字节
       ds18b20_readbyte();  // 读取一个字节
   
       switch (args) {
           case SET_RESOLUTION_9:
               if (ds18b20_readbyte() == 0x1F) {  // 读取一个字节并与 0x1F 进行比较
                   ret = 0;  // 设置返回值为成功
               }
               break;
           case SET_RESOLUTION_10:
               if (ds18b20_readbyte() == 0x3F) {  // 读取一个字节并与 0x3F 进行比较
                   ret = 0;  // 设置返回值为成功
               }
               break;
           case SET_RESOLUTION_11:
               if (ds18b20_readbyte() == 0x5F) {  // 读取一个字节并与 0x5F 进行比较
                   ret = 0;  // 设置返回值为成功
               }
               break;
           case SET_RESOLUTION_12:
               if (ds18b20_readbyte() == 0x7F) {  // 读取一个字节并与 0x7F 进行比较
                   ret = 0;  // 设置返回值为成功
               }
               break;
           default:
               break;
       }
   
       return ret;  // 返回结果
   } 
   
   
   
   /**
    * 读取分辨率。
    *
    * @return 分辨率值
    */
   int read_resolution(void) {
       int ret;
   
       // 复位传感器
       ds18b20_reset();
   
       // 发送指令字节0xCC，跳过ROM操作，直接与单个设备通信
       ds18b20_writebyte(0xCC);
   
       // 发送指令字节0xBE，读取当前设备的配置寄存器
       ds18b20_writebyte(0xBE);
   
       // 读取4个字节的数据，但实际上只有最后一个字节是分辨率信息
       ds18b20_readbyte();
       ds18b20_readbyte();
       ds18b20_readbyte();
       ds18b20_readbyte();
   
       // 读取最后一个字节，即分辨率信息
       ret = ds18b20_readbyte();
   
       // 返回分辨率值
       return ret;
   }
   ~~~



app

~~~c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdlib.h>

#define SET_RESOLUTION    _IOW('A', 'o', int)
#define READ_RESOLUTION   _IOR('A', 'p', int)
#define DS18B20_DEVICE    "/dev/ds18b20"

/**
 * 根据传感器读取的原始数据计算温度值
 * @param value 传感器读取的原始数据
 */
void ds18b20_get_temp(int value) {
    char sig;   // 温度正负号
    float temp; // 温度值

    // 判断温度正负号
    if ((value >> 11) & 0x01) {
        sig = '-';
        value = ~value + 1;
        value &= ~(0xf8 << 8);
    } else {
        sig = '+';
    }

    // 计算温度值
    temp = value * 0.0625;

    // 打印温度信息
    printf("温度为 %c%.4f\n", sig, temp);
}

/**
 * 根据传感器分辨率值打印分辨率信息
 * @param value 传感器分辨率值
 */
void ds18b20_get_resolution(int value) {
    switch (value) {
        case 0x1F:
            printf("分辨率为 9 位\n");
            break;
        case 0x3F:
            printf("分辨率为 10 位\n");
            break;
        case 0x5F:
            printf("分辨率为 11 位\n");
            break;
        case 0x7F:
            printf("分辨率为 12 位\n");
            break;
        default:
            break;
    }
}

int main(int argc, char *argv[]) {
    int fd;
    int data;
    int args;
    int resolution;

    // 打开设备文件
    fd = open(DS18B20_DEVICE, O_RDWR);
    if (fd < 0) {
        printf("无法打开设备文件\n");
        return -1;
    }

    // 获取设置的分辨率参数
    args = atoi(argv[1]);
    printf("设置的参数为：%d\n", args);

    // 检查参数范围
    if (args < 9 || args > 12) {
        printf("错误！参数范围为 9 - 12\n");
        return -1;
    }

    // 设置分辨率
    ioctl(fd, SET_RESOLUTION, &args);

    // 读取分辨率
    ioctl(fd, READ_RESOLUTION, &resolution);
    ds18b20_get_resolution(resolution);

    while (1) {
        // 读取温度数据
        read(fd, &data, sizeof(data));
        ds18b20_get_temp(data);
    }

    // 关闭设备文件
    close(fd);

    return 0;
}
~~~

----



-----

行了，终于算是搞完了，然后开始整理自己呢，还是开始整理上面的内容呢？先将后面的内容大体分析一下吧。

今天还是有些浮躁，这是为什么呢?因为今天是周六，还是因为今天的任务导致的呢？亦或者是技术支持导致的呢？都有可能，只能尽可能的去一个个的去排除这些问题，但是这些都是不可复现的，目前大概率来看还是技术支持导致的，问题之前也分析过，因为技术支持要不停的看QQ，所以在技术支持的时候就会无可避免的分心，而只要一分心，就会无法集中注意力，从而让学习的效率大大的降低，这可真的太难了，除此之外，这个还会产生连锁反应，效率低了就让我产生了浮躁的心理，这就会让我不停的看QQ，从而又一次分心，从而变的更加的焦虑。就像下面这样：

![image-20240224174245469](https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402241742515.png)

​	所以我应该要怎样解决这个问题呢？如果是在一般情况下，也就是没有技术支持的时候，我是没有问题的，这样也就从根本上解决了这些个问题，就正常不看QQ就行了，不看QQ的分析，之前已经写过了，不过分关注QQ即可，但是技术支持的时候呢？我认为这个15分钟看一次的时间频率依然有问题，再改一下，如果是非技术支持的时候，就半小时看一次QQ，技术支持的时候就正常的十五分钟。

目前看起来的话，听音乐，不去听外界的声音就会安静下来，但是我不可能不去听外面的声音的，但是音乐确实能给我救赎，让我的心静下来，考虑一下是不是可以将我的头戴耳机拿来呢，感觉可以试试。我都已经严格的控制了看QQ的次数了，目前为什么仍旧















 
